{"meta":{"title":"Let's Swift!","subtitle":"SangMin's study blog","description":"","author":"SangMin Jeon","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-11-12T10:28:56.000Z","updated":"2019-11-12T10:28:56.814Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-11-12T10:28:48.000Z","updated":"2019-11-12T10:28:48.191Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-11-12T10:29:11.000Z","updated":"2019-11-12T10:30:20.095Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Dependency Manager","slug":"20","date":"2020-02-20T04:13:00.000Z","updated":"2020-02-20T10:11:04.781Z","comments":true,"path":"2020/02/20/","link":"","permalink":"http://yoursite.com/2020/02/20/","excerpt":"Dependency Manager 여러가지 라이브러리를 사용할 때 버전을 구분해서 사용해야 하는 경우, 서로 충돌나지 않도록, 혹은 버전을 쉽게 알 수 있도록 라이브러리에 관해 전반적으로 관리할 수 있는 것을 이야기한다. Cocoa pod 설치 1sudo gem install cocoapods","text":"Dependency Manager 여러가지 라이브러리를 사용할 때 버전을 구분해서 사용해야 하는 경우, 서로 충돌나지 않도록, 혹은 버전을 쉽게 알 수 있도록 라이브러리에 관해 전반적으로 관리할 수 있는 것을 이야기한다. Cocoa pod 설치 1sudo gem install cocoapods 123456$ pod init $ vi Podfiletarget 'CocoaPodsExample' do use_frameworks!pod 'SnapKit' // 사용할 라이브러리 작성 end 1234$ pod repo update$ pod install// pod install을 이전에 한 번도 수행한 적이 없을 경우 약 5 ~ 15분 소요$ open [ProjectName].xcworkspace Carthage Cocoa pod 보다 늦게 나옴 1$ brew update &amp;&amp; brew install carthage 코코아 팟 과는 다르게, 깃헙에 직접 접근해서 사용하는 것임 코코아 팟은 코코아 팟에 등록 된 라이브러리만 사용 가능 코드도 볼 수 없음 바이너리화 되어있어서 대신 이미 빌드가 되어있기 때문에 빌드 시간이 코코아팟보다 짧음 Carthage 빌드 프로젝트 생성 터미널에서 해당 프로젝트 경로로 이동 vi Cartfile 12344. 사용할 라이브러리 작성 - github \"SnapKit/SnapKit\" 123455. 저장 후 터미널에서 - ~~~bash carthage update 프로젝트를 켜고 Build Phase -&gt; Link Binary With Libraries -&gt; ‘+’버튼 -&gt; ‘Add Other…’ -&gt; ‘Add files’ -&gt; 프로젝트의 폴더에서 ‘Carthage’ 폴더 -&gt; ‘Build’ -&gt; ‘iOS’ -&gt; ‘SnapKit.framework’ -&gt; 열기 왼쪽 상단의 ‘+’ 버튼 -&gt; ‘New Run Script Phase’ -&gt; shell 부분에 1/usr/local/bin/carthage copy-frameworks -&gt; Input Files에 $(SRCROOT)/Carthage/Build/iOS/SnapKit.framework import SnapKit &lt;!--￼7--&gt;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"FireBase_2nd","slug":"FireBase-2nd","date":"2020-02-19T10:00:58.000Z","updated":"2020-02-19T12:54:31.868Z","comments":true,"path":"2020/02/FireBase-2nd/","link":"","permalink":"http://yoursite.com/2020/02/FireBase-2nd/","excerpt":"Analytics 하나의 서비스를 내면, 이걸 쓸까? 어떤걸 더 좋아할까?에 대해 궁금하게 됨 어떤 액션이 일어났을 때, 로그가 찍히고 저장이 되도록 하면 해당 로그 정보 데이터를 이용할 수 있음 이때 analytics가 필요 Event Logging실시간 디버깅설정 필요함","text":"Analytics 하나의 서비스를 내면, 이걸 쓸까? 어떤걸 더 좋아할까?에 대해 궁금하게 됨 어떤 액션이 일어났을 때, 로그가 찍히고 저장이 되도록 하면 해당 로그 정보 데이터를 이용할 수 있음 이때 analytics가 필요 Event Logging실시간 디버깅설정 필요함 Edit scheme -&gt; Run -&gt; Arguments -&gt;’-FIRAnalyticsDebugEnabled’ 입력 12345678// 입력 할 때마다 로그를 보내고 싶음 @IBAction func enterAction(_ sender: UIButton) &#123; self.saveUserInfo() // 이벤트 로깅 Analytics.logEvent(\"입력하기_버튼_로그_보내기\", parameters: [\"키\" : 1, \"기기\" : UIDevice.current.name]) // 어떤 내용을 전달하고 싶으면 parameter에 Analytics.logEvent(\"입력하기_버튼_클릭\", parameters: nil) &#125; Remote Config 개발자와 기획자는 사용자가 좋아할까? 궁금함 예를 들어 하트 버튼을 좋아할까? 좋아요 버튼을 좋아할까? 궁금함 어떤 버튼이 더 반응이 좋은지 테스트 할 수 있음 그래서 같은 버전의 사용자여도 앱의 모양이 다른 경우가 지금 실험중인 기능 (이미지) 키를 만들어줌 Test Code 짜보면 많이 도움이 된다. 12345import XCTestclass FastCampusFirebaseExampleTests: XCTestCase &#123;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[]},{"title":"Codable","slug":"18","date":"2020-02-18T03:58:12.000Z","updated":"2020-02-20T10:07:19.414Z","comments":true,"path":"2020/02/18/","link":"","permalink":"http://yoursite.com/2020/02/18/","excerpt":"Codable encodable과 decodable 두 프로토콜을 합쳐서 codable이라 한다. 부호화 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해서 목적에 맞는 다른 형태나 형식으로 변환하는 처리 혹은 그 처리 방식 복호화 압축 파일을 다시 풀거나 암호화 된 내용을 원래 내용으로 되돌리는 일","text":"Codable encodable과 decodable 두 프로토콜을 합쳐서 codable이라 한다. 부호화 정보의 형태나 형식을 표준화, 보안, 처리 속도 향상, 저장 공간 절약 등을 위해서 목적에 맞는 다른 형태나 형식으로 변환하는 처리 혹은 그 처리 방식 복호화 압축 파일을 다시 풀거나 암호화 된 내용을 원래 내용으로 되돌리는 일 Coding Key 딕셔너리의 키 처럼 사용하는 키 키를 이용해서 파싱하겠다! 12345678910111213141516struct Dog: Decodable &#123; let age: Int let name: String&#125; private enum CodingKeys: String, CodingKey &#123;case agecase name&#125;init(from decoder: Decoder) throws &#123;let values = try decoder.container(keyBy: CodingKeys.self)age = try values.decode(Int.self, forKey: .age)name = try values.decode(String.self, forKey: .name) &#125;&#125; 특정 타입의 배열로 변환 할 때 딕셔너리로 변환할 때도 역시 타입을 명시해주어야 한다. Nasted Key Latitude, longitude, AdditionalInfo가 같은 레벨의 키이고, elevation은 AdditionalInfo의 value가 되는 dictionary의 키인 상황이다. elevation이 한 단계 안쪽의 레벨이기 때문에 Latitude, longitude, AdditionalInfo와 동일 선상에서 파싱할수 없기 때문에 키 enum이 더 필요하다 Encoding Error 주어진 값으로 인코딩 할 수 없을 때 Decoding Error userDefault에 는 커스텀 타입을 그대로 넣을 수가 없기 때문에 파일로 저장하기 위한 데이터가 아니라, 메모리에서 바로 쓰기 위함 이기 때문에 encode한 후, decode 해야함","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"JSON","slug":"17","date":"2020-02-17T04:01:17.000Z","updated":"2020-02-17T05:37:11.301Z","comments":true,"path":"2020/02/17/","link":"","permalink":"http://yoursite.com/2020/02/17/","excerpt":"JSON 현재 거의 표준으로 사용되고 있는 데이터 교환 형식 두 개의 구조를 기본으로 가짐 Name: Value 형태의 쌍 값 들의 순서화 된 리스트. XML에 비해 기능이 적고 구조가 단순하여, 파싱이 쉽고 빠르고 적은 용량 사람 뿐만 아니라, 기계가 분석하고 생성하는 것에도 상대적으로 용이함","text":"JSON 현재 거의 표준으로 사용되고 있는 데이터 교환 형식 두 개의 구조를 기본으로 가짐 Name: Value 형태의 쌍 값 들의 순서화 된 리스트. XML에 비해 기능이 적고 구조가 단순하여, 파싱이 쉽고 빠르고 적은 용량 사람 뿐만 아니라, 기계가 분석하고 생성하는 것에도 상대적으로 용이함 swift에서 json사용하기 json형식의 String String을 data로 변환 datafmf json객체로 변환 Json data로 변환 가능한지 여부는 isValidJSONObject(_:) 메서드를 통해 확인 가능","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"3rd_TestReview","slug":"3rd-TestReview","date":"2020-02-14T12:42:43.000Z","updated":"2020-02-18T07:54:56.604Z","comments":true,"path":"2020/02/3rd-TestReview/","link":"","permalink":"http://yoursite.com/2020/02/3rd-TestReview/","excerpt":"3차 시험 리뷰[이론]try, try? try! 의 공통점과 차이점 공통점 : throws 키워드가 사용된 함수를 사용할 때, 오류 발생에 대비해 처리 방법을 결정한다. try : do ~ catch 구문 내에서만 사용하며, 오류 발생 시에는 catch문에서 처리 try? : Optional 값을 반환하며, 오류 발생 시 nil 반환. Do ~ catch 필요 x try! : Optional 강제 언래핑, 오류 발생시 앱 종료. Do ~ catch 필요 x","text":"3차 시험 리뷰[이론]try, try? try! 의 공통점과 차이점 공통점 : throws 키워드가 사용된 함수를 사용할 때, 오류 발생에 대비해 처리 방법을 결정한다. try : do ~ catch 구문 내에서만 사용하며, 오류 발생 시에는 catch문에서 처리 try? : Optional 값을 반환하며, 오류 발생 시 nil 반환. Do ~ catch 필요 x try! : Optional 강제 언래핑, 오류 발생시 앱 종료. Do ~ catch 필요 x forEach, map, filter, reduce에 대해 설명 forEach : 컬렉션의 각 요소에 동일 연산을 적용하며, 반환 값이 없는 형태 map : 컬렉션의 각 요소에 동일 연산 적용, 변형된 새 컬렉션 반환 filter : 컬렉션의 각 요소를 평가하여, 조건을 만족하는 요소만을 새로운 컬렉션으로 반환 reduce : 컬렉션의 각 요소들을 결합하여 단일 타입으로 반환 Geocode와 Reverse Geocode의 차이 Geocode : Placemark -&gt; Coordinate (지명을 좌표로 변환) Geocode reverse : Coordinate -&gt; Placemark (좌표를 지명으로 변환) [실습]1. x ~ y 까지의 숫자 중 홀수만 더하되, while문과 defer를 사용해서 풀이 defer : defer 내부의 코드를, defer가 위치한 현재 스코프를 벗어 날 때 실행한다. defer 문을 이용해서 등록한 코드는 메모리의 stack에 쌓이게 되어, 해당 스코프를 빠져나오는 시점에 정의 된 역순으로 실행된다. while문은 조건이 true일때 내부 코드들이 반복적으로 실행되고, false일 때 실행이 중단된다. 123456789101112131415161718192021func sumOddNumbers(from lowerBound: Int, to upperBound: Int) &#123; // 시작 숫자가 끝 숫자보다 작을 때만 실행 guard lowerBound &lt;= upperBound else &#123; return &#125; var sum = 0 // lowerBound부터 시작 var number = lowerBound // upperBound에서 끝 while number &lt;= upperBound &#123; // 마지막에 실행 defer &#123; number += 1 &#125; // 짝수면 넘어가고, 홀수면 홀수 합 if number % 2 == 0 &#123; continue &#125; sum += number &#125; print(sum)&#125;sumOddNumbers(from: 1, to: 10) // 25sumOddNumbers(from: 1, to: 100) // 2500sumOddNumbers(from: 100, to: 500) // 60000 고차함수(high order function)만을 이용하여 출력2-1. 1부터 100까지의 숫자를 가진 배열에서 홀수만을 골라 각 숫자에 1씩 더해준 배열 출력12let oneToHundred = Array(1...100)print(oneToHundred.filter &#123;!$0.isMultiple(of: 2)&#125;.map &#123; $0 + 1 &#125;) 2-2. [“1”, “2”, “3”, “4”, “5”, “A”, “B”, “C”, “D”] 배열에서 숫자만 골라 그것을 제곱한 숫자들을 모두 더한 결과를 출력12let strings = [\"1\", \"2\", \"3\", \"4\", \"5\", \"A\", \"B\", \"C\", \"D\"]print(strings.compactMap(Int.init).map&#123;$0 * $0&#125;.reduce(0, +)) 단일 연결 리스트 (Sigle Linked List) 구현하기 조건 12345678910111213141516protocol LinkedListStack &#123; var isEmpty: Bool &#123; get &#125; // 노드가 있는지 여부 var size: Int &#123; get &#125; // 전체 개수 func push(node: Node) // 데이터 삽입 func pop() -&gt; String? // 데이터 추출 func peek() -&gt; String? // 마지막 데이터 확인&#125;final class Node &#123; var value: String? var next: Node? init(value: String?) &#123; self.value = value &#125;&#125; 풀이 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647final class SingleLinkedList: LinkedListStack &#123; // 빈 value를 가진 Node를 head로 지정 private var head: Node = Node(value: nil) // head의 다음 노드가 없으면 true 그렇지 않으면 false var isEmpty: Bool &#123; head.next == nil &#125; var size = 0 // 마지막 노드 설정 private var lastNode: Node? &#123; // head의 다음 노드가 없으면 head가 마지막 노드 guard var node = head.next else &#123; return head &#125; // next가 없는 노드를 찾을 때까지 반복 while let nextNode = node.next &#123; node = nextNode &#125; return node &#125; func push(node newNode: Node) &#123; size += 1 // 마지막 노드의 뒤에 새로운 노드 추가 // 추가한 노드가 마지막 노드가 될 수 있도록 lastNode?.next = newNode &#125; // 마지막 노드의 값 출력 func peek() -&gt; String? &#123; lastNode?.value &#125; // next 값이 있는 노드를 func pop() -&gt; String? &#123; var node = head // 해당 노드의 다음 노드가 next 노드가 있을 때까지만 반복 // 다음 노드가 next가 없다면 다음 노드는 마지막 노드이므로, 마지막 노드의 직전 노드를 찾는 과정 while let _ = node.next?.next &#123; node = node.next! &#125; // 노드의 다음 값이 없다는 의미는 현재 리스트에 head만 남았다는 의미이므로 nil 반환 guard let popValue = node.next?.value else &#123; return nil &#125; // nil을 삽입하여 마지막 노드 삭제 node.next = nil size -= 1 return popValue &#125;&#125; 출력 12345678910111213141516171819let linkedList = SingleLinkedList()linkedList.isEmptylinkedList.push(node: Node(value: \"A\"))linkedList.push(node: Node(value: \"B\"))linkedList.peek()linkedList.sizelinkedList.isEmptylinkedList.pop()linkedList.push(node: Node(value: \"C\"))linkedList.peek()linkedList.sizelinkedList.pop()linkedList.pop()linkedList.pop()linkedList.sizelinkedList.isEmpty","categories":[{"name":"Test","slug":"Test","permalink":"http://yoursite.com/categories/Test/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"GCD,","slug":"13","date":"2020-02-13T04:16:28.000Z","updated":"2020-02-20T11:02:11.835Z","comments":true,"path":"2020/02/13/","link":"","permalink":"http://yoursite.com/2020/02/13/","excerpt":"GCD (Grand Central Dispatch) GCD는 멀티 코어 프로세서 시스템에 대한 응용 프로그램 지원을 최적화하기 위해 Apple에서 개발한 기술로 스레드 관리와 실행에 대한 책임을 어플리케이션 레벨에서 운영체제 레벨로 넘김 작업의 단위는 Block이라 불리며 DispatchQueue가 이 Block들을 관리","text":"GCD (Grand Central Dispatch) GCD는 멀티 코어 프로세서 시스템에 대한 응용 프로그램 지원을 최적화하기 위해 Apple에서 개발한 기술로 스레드 관리와 실행에 대한 책임을 어플리케이션 레벨에서 운영체제 레벨로 넘김 작업의 단위는 Block이라 불리며 DispatchQueue가 이 Block들을 관리 DispatchQueueSerial queue 직렬 Concurrent Queue 병렬 동시 수행 그렇지만 병렬 방식도 종류가 나뉜다. Concurrency : 논리적인 병렬성 - 쓰레드가 나뉘어서 여러 작업을 동시에 실행 Parallelism : 물리적인 병렬성 - 겉으로 보기에는 동시에 실행 되는 것처럼 보이지만 아주 빠른 속도로 두 가지 작업을 번갈아 가면서 실행 (context switching) Work Item Execution Synchronous : sync 메서드를 이용해 동기적으로 실행되면, 작업이 완료 될 때까지 대기한 뒤 메서드에서 return 호출 해당 스레드의 다른 작업들은 모두 정지 특정 작업이 완료 되어야 다른 작업을 실행할 수 있음 Asynchronous : Async 메서드를 이용해 비동기적으로 실행되면, 즉시 메서드에서 return을 호출하고 작업 수행 작업을 등록만 하고 return하고 끝내버린 후, 그 뒤에 있는 작업을 실행하고, 비동기로 실행한 작업은 별도로 다른 곳에서 실행 sync, async를 언제쓰나? 네트워크 관련 업무를 할 때 사용하는 경우가 많다. 큰 파일을 읽어야 하는 작업을 할 때, 해당 업무가 종료 된 후 다음 작업으로 넘어가면 비효율적이기 때문에 이런 경우에 비동기(async)를 사용하는 경우가 많다. 이에 반해 sync는 사용하는 경우가 많지 않다. System Dispatch Queue system이 제공하는 queue main과 global이 있으며, 앱 실행 시 생성된다. Main : UI와 관련 된 작업은 모두 main 큐를 통해서 수행하며, Serial queue에 해당된다 Main 큐를 sync 메서드로 동작시키면 교착상태에 빠진다 우리가 실행하는 작업 때문에, 시스템에서 실행해야 하는 작업을 수행하지 못하게 된다면, 문제가 될 것이기 때문에 sync 메서드를 사용할 수 없다. Main 큐는 비동기로 동작한다. 특히, UI와 관련 된 작업은 모두 main큐를 통해서 수행하게 된다. 앱을 켰을 때, 다른 작업이 실행중이어도 UI는 그려져있는 상태여야 하기 때문 Global : UI를 제외한 작업에서 사용하며, Concurrent Queue에 해당 sync, async 메서드 모두 사용 가능 QoS 클래스를 지정하여 우선 순위 설정 가능 작업간의 우선순위를 구분하고 싶을 때, qos를 준다. QoS 우선 순위가 높을 수록 더 빨리 수행되고, 많은 전력 소모 수행 작업에 적절한 QoS 클래스를 지정해주어야 더 반응성이 좋아지며, 효율적인 에너지 사용 가능 User Interactive : 즉각 반응해야 하는 작업, 반응성과 성능에 중점 Main 쓰레드에서 동작하는 인터페이스 새로 고침, 애니메이션 작업 등 즉각 수행 되는 유저와의 상호작용 작업에 할당 User Initiated: 몇 초 이내의 짧은 시간 내 수행해야 하는 작업으로 반응성 및 성능에 중점 문서를 열거나, 버튼을 클릭해 액션을 수행하는 것 처럼 빠른 결과를 요구하는 유저와의 상호작용 작업에 할당 Utility 수 초에서 수 분에 걸쳐 수행되는 작업 데이터를 읽어들이거나 다운로드 하는 등 작업을 완료하는데 어느정도 시간이 걸릴 수 있으며 보통 진행 표시줄로 표현 BackGround : 수 분에서 수 시간에 걸쳐 수행되는 작업 색인 생성, 동기화, 백업 같이 사용자가 볼 수 없는 작업에 할당 저전력 모드에서는 네트워킹을 포함하여, 백그라운드 작업은 일시 중지 Custom Dispatch Queue 개발자가 별도로 만들어서 사용하는 Dispath Queue main 쓰레드가 아닌 곳에서 실행이 됨 Serial, Concurrent 및 QoS 등의 여러 옵션을 지정하여 생성 가능 1234567// 커스텀 큐 생성let Queue = DispatchQueue(label: \"com.fastCampus.example\")// 옵션까지 설정하는 커스텀 큐 생성let queueOptions = DispatchQueue(label: \"com.fastCampus.example\", qos: .userInteractive, attributes: [.concurrent]) Work Item custom queue에서 실행해야 하는 특정 작업을 미리 생성해 둘 수 있다. (WorkItem) 12345678910111213141516171819202122// work Item 생성// 이런식으로 동작하는 워크 아이템을 만들어 둔다.private func createDispatchWorkItem() -&gt; DispatchWorkItem &#123; // 25%, 50% , 75%, 100% let workItem = DispatchWorkItem &#123; let bigNumber = 8_000_000 let divideNumber = 2_000_000 for i in 1...bigNumber &#123; guard i % divideNumber == 0 else &#123; continue &#125; print(i / divideNumber * 25, \"%\") &#125; &#125; return workItem &#125;let workItem = createDispatchWorkItem() // 커스텀 큐 생성 let myQueue = DispatchQueue(label: \"kr.giftbot.myQueue\") // 해당 커스텀 큐가 해야 할 작업을 미리 만들어 둔 workItem으로 할당한다. myQueue.async(execute: workItem) wait() wait() 메소드를 사용하면, async 메소드를, sync 메소드 처럼 사용 할 수 있다. 1234567myQueue.async(execute: workItem) // 비동기이기 때문에 일단 workItem 등록하고 return myQueue.async(execute: workItem) // 아래의 두 프린트 먼저 실행 된 후, 뒤늦게 myQueue의 workItem 실행 print(\"before waiting\") print(\"after waiting\") 1234567891011myQueue.async(execute: workItem) // before Wating이 실행 된 후, workItem이 실행 되고, 마지막으로 after를 실행하고 싶으면?? myQueue.async(execute: workItem) print(\"before waiting\") // wait()를 사용한다. // async를 sync 처럼 쓸 수 있기 때문에 // before가 실행 된 후, workItem이 실행 되고, 종료 된 이후에 after가 실행된다. workItem.wait() // 해당 큐의 작업이 완료 될 때 까지 다음 작업 실행 대기 print(\"after waiting\") 대기 시간을 지정할 수도 있다 1234// 3초로 가정let timeLimit = 3.0// 3초간만 wait, 이후 작업 실행let timeoutResult = self.workItem.wait(timeout: .now() + timeLimit) Initially inactive 커스텀 큐를 생성 할 때 설정한다 .initiallyInactive로 설정한 큐는 등록만 해놓고 실행이 되지 않는다. activate()는 등록 된 작업을 실행하겠다. 라는 의미이다. 그렇기 때문에 activate()를 연달아 여러 번 사용해도 작업이 여러 번 실행되지는 않는다. 12345let inactiveQueue = DispatchQueue( label: \"kr.giftbot.inactiveQueue\", // 여기 attributes: [.initiallyInactive, .concurrent] ) 설정 값이 .initiallyInactive인 커스텀 큐는 실행이 되지 않다가, activate() 함수가 실행되는 순간부터 작업을 실행한다. 12345678910let workItem = createDispatchWorkItem() // 다른 큐는 여기서 등록해놓고 아래의 do something을 실행하지만 // inactiveQueue는 .initiallyInactive로 설정 되었기 때문에 실행되지 않는다. inactiveQueue.async(execute: workItem) print(\"= Do Something... =\") // 아래의 activate 메서드를 통해 활성화 한다. // activate 메서드를 통해 필요한 타이밍에 커스텀 큐를 실행할 수 있다. inactiveQueue.activate() Group Notify 순서 보장과는 관계없이 복수의 task를 그룹화 하고, 해당 그룹의 작업이 끝난 시점을 알려주는 것을 말한다. 12345678910let group = DispatchGroup()// 세 가지 task, 각각 종료하는데 걸리는 시간이 다름customQueue1.async(group: group) &#123; calculate(task:1, limit: 12_000_000)&#125;customQueue2.async(group: group) &#123; calculate(task:1, limit: 5_000_000)&#125;customQueue3.async(group: group) &#123; calculate(task:1, limit: 2_000_000)&#125;// 그룹화// 위의 세 task를 그룹으로 묶었기 때문에 모든 작업이 끝난후 main큐에서 print 메소드가 실행된다.group.notify(queue: .main) &#123; print(\"모든 작업 완료\")&#125; Cancel task를 취소하는 메소드 isCanclled 프로퍼티가 필요하다. 123456789101112131415161718192021222324252627 myWorkItem = DispatchWorkItem &#123; let bigNumber = 8_000_000 let divideNumber = bigNumber / 4 for i in 1...bigNumber &#123; guard i % divideNumber == 0 else &#123; continue &#125; // cancel() 메소드가 호출되면, true로 바뀜 guard !self.myWorkItem.isCancelled else &#123; return &#125; print(i / divideNumber * 25, \"%\") &#125; &#125; // N초안에 실행 안되면 취소하고 싶은 task DispatchQueue.global().async(execute: myWorkItem) // 3초로 지정 let timeLimit = 3.0 // N DispatchQueue.global().async &#123; let timeoutResult = self.myWorkItem.wait(timeout: .now() + timeLimit) switch timeoutResult &#123; // 시간 안에 실행이 완료되면 success case case .success: print(\"success within \\(timeLimit) seconds\") // 시간 안에 실행이 완료되지 못하면 timeOut case .timedOut: self.myWorkItem.cancel() print(\"timed out\") &#125; &#125; URL Loading System URL과 상호작용하고, 표준 인터넷 프로토콜을 통해 서버와 통신하기 위한 시스템 주요 클래스 URLSession, URL, URLSessionTasks, URLRequest, URLResponse 􏰵등 Session 클라이언트와 웹 서버간 네트워크 연결이 지속 유지 되어지고 있는 상태를 말한다. 사용자가 브라우저를 열어 서버에 접속한 뒤 접속을 종료할 때 시점까지 http 프로토콜은 클라이언트가 서버에 request를 보내면, 서버는 클라이언트에게 response를 하고, 서로 접속을 끊는다. 그리고 접속을 끊는 순간 클라이언트와 서버의 통신은 끝나고, 상태 정보는 유지 되지 않는다. 그렇기 때문에 통신을 할 때마다 클라이언트는 자신이 누구인지 계속 인증을 해야하는 비효율성이 존재함 예를 들면 네이버에 로그인을 하고, 서비스를 이용 하면서 이동 할 때마다 새로 로그인을 해야하는 것! 이를 해결하기 위해 쿠키와 세션을 사용함 URL Session 네트워크 데이터 전송 작업에 관련된 클래스 그룹을 조정하는 객체 대부분의 네트워킹 API와 마찬가지로 URLSession API 역시 비동기 동작 네트워크와 통신을 하려면 몇 초이든 분명 시간이 걸리기 때문에 동기로 동작하게 되면 그 시간 동안 사용자가 아무 동작도 수행할 수 없기 때문에 비동기로 동작한다. URLSessionCon􏱱guration에 의해 세션 동작 결정 HTTP 요청을 보내고 받는 핵심 객체 Network API LifeCycle SessionCon􏱱guration을 설정하고, Session 생성 URL 또는 URLRequest 객체 생성 사용 목적에 맞는 Task를 결정하고, 이에 해당하는 Completion Handler 파라미터 전달, 또는 Delegate메서드 구현 생성한 Session을 통해 Task 수행 작업 완료 후 미리 설정한 Completion Handler 또는 Delegate 메서드가 호출되고 실행 종료 요청에 대한 응답 처리 Completion handler 와 delegate 중 선택 Completion handler 구현 시 delegate 메서드는 호출되지 않음 둘 중 하나를 선택하여 사용하는데, 왠만하면 delegate 쓸 일은 별로 없을듯 비교적 간단한 응답 처리는 completion handler를 이용하고, 세세한 처리가 필요할 때는 delegate 구현 URLSession Configuration URLSession이 데이터 업로딩/다운로딩을 수행할 때 사용되는 정책과 동작을 정의하기 위한 설정 객체 URLSession 사용을 위한 첫 단계 시간 제한, 캐싱 정책, Cellular 제한 여부, 연결 요구사항 등 URLSession에서 사용할 여러 유형의 정보를 설정 URLSession 생성시 Configuration 객체의 설정을 복사하는 형태이므로, 그 이후의 설정 변경은 반영되지 않음 새로운 설정을 적용해야 한다면 새로운 세션 객체를 만들어서 사용","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"fireBase","slug":"fireBase","date":"2020-02-12T09:53:55.000Z","updated":"2020-02-12T11:08:11.842Z","comments":true,"path":"2020/02/fireBase/","link":"","permalink":"http://yoursite.com/2020/02/fireBase/","excerpt":"Fire Base pod init Firebase 로그인 프로젝트 만들기 아이덴티파이어 입력 plist 파일 다운로드 및 복붙 pod install Appdelegate 가서 import Firebase Did finish 메서드 안에 1FirebaseApp.configure()","text":"Fire Base pod init Firebase 로그인 프로젝트 만들기 아이덴티파이어 입력 plist 파일 다운로드 및 복붙 pod install Appdelegate 가서 import Firebase Did finish 메서드 안에 1FirebaseApp.configure() SDK 설치 끝! 서버를 대체해 주는 툴 서버를 Fimuxd","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"specialLecture","slug":"specialLecture","permalink":"http://yoursite.com/tags/specialLecture/"}]},{"title":"Network, Closure","slug":"11","date":"2020-02-11T04:19:03.000Z","updated":"2020-02-19T04:33:27.103Z","comments":true,"path":"2020/02/11/","link":"","permalink":"http://yoursite.com/2020/02/11/","excerpt":"URI URL : 어떤 자원의 위치에 대한 절대 경로값을 지닌 문자열 어떤 특정 주소, 또는 파일 리소스에 접근하기 위한 주소 값 어떤 자원의 위치에 대한 절대 경로 값을 지닌 문자열 URN : 위치에 독립적이고, 지속되는 형태의 자원을 가르키기 위한 유일한 식별자 ex) ISBN URL은 주소, URN은 주민등록번호에 비유할 수 있다. URI는 URL, URN을 포괄하는 개념","text":"URI URL : 어떤 자원의 위치에 대한 절대 경로값을 지닌 문자열 어떤 특정 주소, 또는 파일 리소스에 접근하기 위한 주소 값 어떤 자원의 위치에 대한 절대 경로 값을 지닌 문자열 URN : 위치에 독립적이고, 지속되는 형태의 자원을 가르키기 위한 유일한 식별자 ex) ISBN URL은 주소, URN은 주민등록번호에 비유할 수 있다. URI는 URL, URN을 포괄하는 개념 IRI (International Resource Identifier) URI의 상위 개념으로서 확장된 버젼 최근에는 UTF-8로 바뀌어서 웹사이트 주소에 한글도 적을 수 있다. 이를 이용해서 비슷해 보이는 문자를 악용하기도 한다. URI (ASCII character set) Endian 컴퓨터에서 어떤 크기의 데이터를 메모리에 저장할 때 바이트 단위로 나누어 저장한다. CPU 아키텍처에 따라 바이트 저장순서가 달라질 수 있기 때문에 두 가지로 나뉜다. Big - Endian : 낮은(시작) 주소에 상위 바이트부터 기록, Sparc / RISC CPU 계열예) 32비트형 (4바이트) 값: 0x01020304 Little - Endian : 낮은(시작) 주소에 하위 바이트부터 기록, Intel CPU 계열예) 32비트형 (4바이트) 값: 0x01020304 위와 같이, 시스템마다 저장하는 방식이 다르다. 공통된 약속의 Endian을 사용하고, 수신측에서 각자의 시스템에 맞는 방식으로 변환한다. 다른 방법으로는 Byte 단위 전송이 있다. Endian 문제는 Byte 단위로 저장할 때 순서의 차이에 의해 발생하기 때문에, 애초에 1Byte 단위로 데이터를 보내면 바이트 순서에 구애받지 않고 통신이 가능하다. 123456789let number: UInt32 = 0x12345678let convertedToBig = number.bigEndianif number == convertedToBig &#123;print(\"BigEndian \\(number)\")&#125; else &#123;print(\"LittleEndian \\(number)\")&#125; Rest API 자원을 정의하고 자원에 대한 주소를 지정하는 방법 등을 의미하는 네트워크 아키텍처 원리의 모음 OSI 7계층 Closure 코드에서 사용하거나 전달할 수 있는 독립적인 기능을 가진 블럭 함수도 클로저의 일종 capture list [a, b] : 선언 된 시점을 기준으로 값을 저장한다. Value Type 12345678910111213141516171819202122232425262728var a = 0var b = 0var c = 0var result = 0// 1. 1, 2, 3, 6 저장(a, b, c) = (1, 2, 3)result = a + b + c// 여기서 [a, b]안에 [1, 2] 저장let valueCapture2 = &#123; [a, b] in result = a + b + c print(\"내부 값 :\", a, b, c, result)&#125;// 다시 7, 8, 9, 저장(a, b, c) = (7, 8, 9)result = a + b + c// 결과 : 7, 8, 9, 24print(\"초기 값 :\", a, b, c, result)// 이 안에서 1, 2가 캡쳐 되어 있기 때문에 결과 값 : 1, 2, 9, 12valueCapture2()// result는 캡쳐 된 이후 값을 변경해 주지 않았기 때문에// 결과 : 7, 8, 9, 12print(\"최종 값 :\", a, b, c, result) Reference Type 1234567891011121314151617181920212223242526272829303132// reference 타입은 값을 직접 가지고 있는게 아니라, 값이 저장되있는 위치를 가리키는 포인터가 저장되어있음final class RefType &#123; var number = 0&#125;var x = RefType()var y = RefType()print(\"초기 값 :\", x.number, y.number)// refCapture()를 실행해도 나중에 할당한 5가 반영된다.// x 캡쳐let refCapture = &#123; [x] in print(\"내부 값 :\", x.number, y.number)&#125;x.number = 5y.number = 7// 결과 : 변경 값 : 5 7print(\"변경 값 :\", x.number, y.number)// 캡쳐 실행!refCapture()// 결과 : 내부 값 : 5 7// 얘는 먼저 캡처를 하고 나중에 x.number에 5를 할당했는데 왜 refCapture()를 실행했을 때 5가 들어가 있을까?// 이 x는 값을 가진게 아니라 값을 가진 주소를 가지고 있기 때문에(reference Type) 캡처를 해도, 주소는 바뀌지 않았고, 값이 바뀌어서 캡쳐를 해봐야 의미가 없다. 캡쳐 된 것은 포인터지, 값이 아님// 결과 : 최종 값 : 5 7print(\"최종 값 :\", x.number, y.number) Capture ExampleNoEscaping 기본 값 함수에서 사용 된 파라미터는 함수 종료와 함께 소멸 Self 키워드 불필요 Escaping 함수나 메서드의 파라미터 중 클로져 타입에 @escaping을 적용한다. 해당 파라미터가 함수 종료 이후 시점에도 어딘가에 남아 실행 될 수 있음을 나타냄 해당 파라미터가 함수 외부에 저장되거나, 비동기로 동작할 때 사용 self 키워드 명시","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"UIDevice","slug":"10","date":"2020-02-10T04:26:11.000Z","updated":"2020-02-10T06:38:00.137Z","comments":true,"path":"2020/02/10/","link":"","permalink":"http://yoursite.com/2020/02/10/","excerpt":"","text":"UIDevice 디바이스 이름 / 모델 / 화면 방향 등 OS 이름 / 버전 인터페이스 형식 (phone, pad, tv 등) 배터리 정보 근접 센서 정보 멀티태스킹 지원 여부 위 정보들을 담고 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"2nd Test Review","slug":"2ndTestReview","date":"2020-02-10T01:30:52.000Z","updated":"2020-02-10T04:24:28.675Z","comments":true,"path":"2020/02/2ndTestReview/","link":"","permalink":"http://yoursite.com/2020/02/2ndTestReview/","excerpt":"2nd Test ReviewUp casting과 down Casting의 차이? 업캐스팅 : 상속관계에 있는 자식클래스가 부모클래스로 형 변환하는 것 반드시 성공하며, as 키워드 사용 다운캐스팅 : 형제 클래스나, 다른 서브 클래스 등 상위 클래스에서 파생된 각종 서브 클래스로의 타입 변환을 의미함 반드시 성공한다는 보장이 없으므로 as? 또는 as! 키워드 사용 as : 타입 변환이 확실하게 가능한 경우, (업캐스팅, 자기 자신으로의 캐스팅)에만 사용가능, 그 외에는 컴파일 에러 as? : 강제 타입변환시도, 변환이 성공하면 optional값을 가지며, 실패시에는 nil 변환 as! : 강제 타입변환시도, 성공시 언래핑 된 값을 가지며, 실패시 런타임에러","text":"2nd Test ReviewUp casting과 down Casting의 차이? 업캐스팅 : 상속관계에 있는 자식클래스가 부모클래스로 형 변환하는 것 반드시 성공하며, as 키워드 사용 다운캐스팅 : 형제 클래스나, 다른 서브 클래스 등 상위 클래스에서 파생된 각종 서브 클래스로의 타입 변환을 의미함 반드시 성공한다는 보장이 없으므로 as? 또는 as! 키워드 사용 as : 타입 변환이 확실하게 가능한 경우, (업캐스팅, 자기 자신으로의 캐스팅)에만 사용가능, 그 외에는 컴파일 에러 as? : 강제 타입변환시도, 변환이 성공하면 optional값을 가지며, 실패시에는 nil 변환 as! : 강제 타입변환시도, 성공시 언래핑 된 값을 가지며, 실패시 런타임에러 TableView에서 셀을 재사용할 때 사용되는 두 메서드의 차이점 register메소드를 통해 사용할 셀을 등록했거나, 스토리보드에서 셀을 만들었을 때 반환 타입이 옵셔널이기 때문에 입력한 identifier가 틀리거나 없어도 nil을 반환할 뿐, 오류가 발생하진 않음 1dequeueReusableCell(withIdentifier:) 그 외의 경우 미리 등록한 identifier를 찾지 못하면, 반드시 런타임에러 1dequeueReusableCell(withIdentifier:, for:) safeAreaInsets, safeAreaLayoutGuide의 차이점 safeAreaInset view와 safeArea 영역 간의 간격 정보 Frame 기반으로 레이아웃을 잡을 때 사용 safeAreaLayoutGuide safeArea 영역의 경계선 부분 오토레이아웃 기반으로 레이아웃을 잡을 때 사용 Strong refrence Cycle에 대해 설명, 예시코드 작성 서로 다른 인스턴스간 순환 cycle이 되는 강한 참조를 유지하고 있어 더 이상 사용되지 않거나 외부에서 접근할 수 있는 수단이 없음에도 불구하고, 각 인스턴스가 다른 인스턴스를 지속해서 활성 상태로 만들게 되는 상태를 말함 123456789101112131415class A &#123; var b : B?&#125;class B &#123; var a: A init(a: A) &#123; self.a = a&#125;&#125;var a: A? = A()var b: B? = B(a: a!)a.b = ba = nilb = nil Strong, unowned, Weak 각각의 특징과 차이점에 대해 설명 Strong : 강한참조 기본 값 인스턴스 참조 시 RC 1증가 Unowned : 미소유 참조 RC 증가 x 참조하는 인스턴스 해제시에도 기존 포인터 주소 유지 Weak : 약한 참조 RC 증가 x 참조하던 인스턴스 해제시 nil 값으로 변경 InTrinsic Content Size란 무엇? 어떤 특징? 고유의 콘텐츠 크기 (잘라내거나 줄이지 않고, 온전히 표현 할 수 있는 최소한의 크기) 뷰에 따라 다른 형태를 가질 수 있음 Ex) UIButton은 width, height에 대한 크기를 가지고, UISlider는 width에 대한 크기만 가짐 별도의 제약을 주지 않는다면 이 크기가 오토레이아웃에서 자동으로 반영","categories":[{"name":"Test","slug":"Test","permalink":"http://yoursite.com/categories/Test/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Algorithm","slug":"4","date":"2020-02-04T04:18:42.000Z","updated":"2020-02-04T04:19:29.375Z","comments":true,"path":"2020/02/4/","link":"","permalink":"http://yoursite.com/2020/02/4/","excerpt":"","text":"Algorithm","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"Data Structure","slug":"3","date":"2020-02-03T04:11:59.000Z","updated":"2020-02-03T07:44:43.054Z","comments":true,"path":"2020/02/3/","link":"","permalink":"http://yoursite.com/2020/02/3/","excerpt":"​ 자료를 효율적으로 이용할 수 있도록 저장하는 방법을 의미 링크드 리스트 면접 질문으로 내기 참 좋은 부분임 삽입 하거나, 삭제할 때 그 순서에 대해 주의해야 한다. 연결 방향이 유실 되면 이후 부분에는 접근을 할 수 없게 됨 Single Linked List 구현해보기","text":"​ 자료를 효율적으로 이용할 수 있도록 저장하는 방법을 의미 링크드 리스트 면접 질문으로 내기 참 좋은 부분임 삽입 하거나, 삭제할 때 그 순서에 대해 주의해야 한다. 연결 방향이 유실 되면 이후 부분에는 접근을 할 수 없게 됨 Single Linked List 구현해보기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import UIKitprotocol LinkedListStack &#123; var size: Int &#123; get &#125; // 전체 개수 var isEmpty: Bool &#123; get &#125; // 노드가 있는지 여부 func push(node: Node) // 데이터 삽입 func pop() -&gt; String? // 데이터 추출 func peek() -&gt; String? // 마지막 데이터 확인&#125;final class Node &#123; var value: String? var next: Node? init(value: String) &#123; self.value = value &#125;&#125;// head -&gt; nilfinal class SingleLinkedList: LinkedListStack &#123; private var head: Node = Node(value: \"\") // head 자체는 아무 값이 없고, 실질적인 마지막 값은 head.next // head 자체에 마지막 값을 저장하는 방식으로 해도 됨 var size: Int = 0 &#123; didSet &#123; size = size &lt; 0 ? 0 : size &#125; &#125; // tail, 가장 중요함 이 부분을 잘 이해하는게 포인트 private var lastNode: Node? &#123; guard var node = head.next else &#123; return nil&#125; while let nextNode = node.next &#123; node = nextNode &#125; return node &#125; var isEmpty: Bool &#123; return head.next == nil &#125; // 데이터 삽입 func push(node newNode: Node) &#123; size += 1 guard let node = lastNode else &#123; return head.next = newNode &#125; node.next = newNode &#125; // 마지막 노드 자체를 지워버리는게 아니라 마지막 노드를 가리키는 녀석에서 연결을 끊어버리는거 // A -&gt; B -&gt; C 가 있으면 C를 지우는게 아니라 B.next에 nil을 할당해버리는 것임 그럼 C가 삭제 됨 // node의 nextNode가 next값이 없을 때까지 (A의 nextNode의 next 값은 C니깐 B의 nextNode(C)의 next 값이 nil인 경우까지 반복문을 돌리는 것) // B를 찾았으니깐, B.next를 nil로 만들면 C가 지워지는 것 // 데이터 추출 func pop() -&gt; String? &#123; size -= 1 guard var node = head.next else &#123; return nil &#125; while let nextNode = node.next &#123; guard nextNode.next != nil else &#123; node.next = nil return nextNode.value &#125; node = nextNode &#125; // head에 A가 할당되어있는 상황이 아니라, head는 nil이고, head.next가 A인 상황임 // 아래의 nil을 할당하는 상황은 head -&gt; A -&gt; nil // A를 pop해야하니깐 head.next에 nil을 넣어주는 것!! head.next = nil return node.value &#125; // 마지막 노드가 있으면 value return, 없으면 nil return // 마지막 데이터 확인 func peek() -&gt; String? &#123; return lastNode?.value &#125;&#125; Double Linked List 양 방향으로 연결된 리스트 prev가 없으면 가장 첫 데이터인거고 next가 없으면 가장 마지막 데이터 A -&gt; B-&gt; D 사이에 C를 삽입 할 때? 순차적으로 C의 next와 prev를 먼저 만들고, 기존 B -&gt; D B &lt;- D를 끊어주어야 한다. 제거 할 때도 마찬가지 B-&gt; D B &lt;- D를 먼저 만들어 놓고 C를 삭제해야 데이터 유실이 안됨 Circular Linked List Double은 tail쪽에 가까운 데이터에 접근할 때는 tail에서, head에 가까운 데이터에 접근할 때는 head에서 접근하는게 빠름 Circular는 첫 데이터와 마지막 데이터가 연결 되어 있으므로 tail에 가까운 데이터도 head에서 빠르게 접근할 수 있음 배열 VS LinkedList 스택을 구현할 때, 배열로 해도 되고, 링크드리스트로도 구현할 수 있으나 방식에 따라 장,단점이 있다 배열 : 구조가 간단하고 빠르다 링크드 리스트 : 구조 및 사이즈 유연성, 데이터 타입 변형 가능 배열은 연속된 공간을 만들어서 사용하기 때문에 구조가 단순함 배열은 특정 공간을 미리 확보하고 사용함. 그래서 타입이 같아야함. Any 타입의 배열은 내부적으로는 링크드 리스트로 되어있다는 것!! Any 타입의 배열은 각 요소마다 타입이 다르니깐!! Queue 일반적으로 링크드 리스트로 구현이 됨 배열로도 할 수는 있음 그렇지만 약간의 문제가 있다 앞에서 지우고 뒤에서 추가하는 것을 반복하면 계속 앞에 빈 공간이 생기게 되어서 뒤의 모든 데이터를 계속 앞으로 밀어서 빈 공간을 메꿔야함 (매번 전부 위치를 옮겨야 하니 비효율적임) 연속 된 공간이라는 제약 때문에 문제가 발생함! (한줄 요약) Circular Queue 배열로 큐 구현시 발생하는 문제점을 해결하기 위해 원형 큐 사용 Deque (Double Ended Queue) 양쪽에서 enqueue, dequeue가 가능하도록 만든 구조 Graph 정점 : 독립 된 개체, 동그라미로 표현 간선 : 두 정점을 잇는 개체, 선, 또는 연결선 무방향성 : 방향성이 없는 간선을 가진 그래프 방향성 : 방향성이 있는 간선을 가지고 있는 그래프 그래프를 그리는 이유? 복잡한 요소들을 제거하고, 필요한 부분만 단순하게 표현하여 데이터를 쉽게 파악 할 수 있음 Depth-First Search (DFS)탐색 된 첫 번째 노드는 먼저 자세히 탐색하는 방법 stack을 이용해서 탐색 구현 Breadth-First Search (BFS)인접 노드들을 먼저 차례대로 탐색하는 방법 큐를 이용해서 탐색구현 전공자에게는 요녀석들을 코드로 구현해보라고 할 수도 있음 (코딩 테스트) 아주 어렵지도, 쉽지도 않은 문제 이런게 있다 정도만 일단 알고 있자 Tree 그래프의 한 종류로 볼 수 있음 연결 되어있고, 순환이 되어있지 않고, 방향성이 없는 그래프 간선 (두 정점을 잇는 선)을 추가하면 순환이 발생하고, 제거하면 연결이 끊김 순환 (Cicle)이 있으면 tree라고 볼 수 없음 끊어져 있으면, 각각은 트리로 볼 수 있지만 전체적으론 트리로 볼 순 없음 완전 이진 트리 정도는 알고 있으면 좋다 이진 탐색 트리 (Binary Search Tree) 노드의 좌측 서브트리에는 그 노드의 값보다 작은 값을 가진 노트, 우측에는 큰 값을 가진 노드로 구성 그래프를 사용해서 숫자를 정렬하면 어느 부분에서 유리할까? 탐색 속도가 빠름 요소가 7개인 배열은 원하는 숫자를 탐색하려면 최악의 경우 7번 탐색을 해야함 하지만 이진 탐색 트리를 사용하면 더 빠르다 좌측이 작은 값, 우측이 큰 값이니깐, 계속 비교해 가면서 좌측, 우측으로 가면 탐색 횟수가 더 적기 때문이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"}]},{"title":"Error Handling","slug":"31","date":"2020-01-31T03:56:22.000Z","updated":"2020-01-31T05:59:04.956Z","comments":true,"path":"2020/01/31/","link":"","permalink":"http://yoursite.com/2020/01/31/","excerpt":"Error Handling 프로그램 동작 중 예상 가능한 오류가 발생했을 댸 이를 감지하고 복구하기 위한 일련의 과정 에러가 발생한 함수에서 처리를 하지 않고 에러를 발생시킨 함수를 ‘호출’한 함수에서 처리 (throw) Type throw가 없는걸 있는 곳에 넣을 수는 있는데, 있는걸 없는 곳에 넣을 수는 없음","text":"Error Handling 프로그램 동작 중 예상 가능한 오류가 발생했을 댸 이를 감지하고 복구하기 위한 일련의 과정 에러가 발생한 함수에서 처리를 하지 않고 에러를 발생시킨 함수를 ‘호출’한 함수에서 처리 (throw) Type throw가 없는걸 있는 곳에 넣을 수는 있는데, 있는걸 없는 곳에 넣을 수는 없음 Try? as? 와 유사함 (형변환 할 때, 성공하면 optional 타입, 안되면 nil) do~catch와 유사하게 사용함 정상적으로 수행하면 optional값을 반환하고, 오류가 발생하면 nil반환 잘 되면 data를 return 할 것이고 안되면 nil 반환 Try! 오류가 발생하지 않는다고 확신할 수 있는 경우에만 try! 사용 확신하는에 왜 굳이 try를 붙일까? throw가 붙어있는 함수를 처리할 때는 try가 필요함 defer 현재 코드블럭이 종료되기 직전에 무조건 실행되어야 하는 코드 블럭 defer가 호출 되면, 등록 됨. 등록이 되어야 해당 스코프 안에서 역순으로 실행 됨 ( 호출이 안되면, 등록도 안됨, 코드가 있다고 해서 무조건 등록이 되는 것은 아니다!) 예를 들어 if 문 안에 defer가 있으면, 해당 if문이 전부 다 실행되고, 마지막에 defer가 실행된다. (어디에 위치해 있든 상관없이) defer가 먼저 등록된 녀석이, 나중에 등록된 녀석보다 늦게 실행 됨 throw를 하는 경우는 내가 직접 쓰는 경우도 있고, 애플이 프레임워크를 제공해 줄 때, 사용자가 어떻게 쓸 지 모르니깐 미리 명시를 해준다. 에러 처리를 어떻게 할지는 사용자가 알아서하는 거임. 라이브러리에 있는 경우가 많음 throws가 있는 함수는 에러를 다른 함수로 던져서 처리하고, 없으면 내부에서 do ~ catch \u0010써서 처리한다. 반복문은 정해진 횟수 안에서 안끝나고 계속 도는게 아니라 한 반복자가 끝나면 끝났다가 다시 실행하는 거?? NSError","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"homework_CollectionView","slug":"homework-CollectionView","date":"2020-01-30T08:39:03.000Z","updated":"2020-01-30T08:42:02.998Z","comments":true,"path":"2020/01/homework-CollectionView/","link":"","permalink":"http://yoursite.com/2020/01/homework-CollectionView/","excerpt":"","text":"Collection View 과제 다중선택 가능 삭제버튼 누르면 지워지기 다 지워지면 다시 새로 채우기","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Collection View","slug":"28","date":"2020-01-28T04:13:04.000Z","updated":"2020-01-28T05:08:43.732Z","comments":true,"path":"2020/01/28/","link":"","permalink":"http://yoursite.com/2020/01/28/","excerpt":"","text":"Collection View 스크롤의 직교 방향이 cell Spacing 스크롤 방향의 거리 line Spacing 테이블뷰는 기본적으로 셀 내부에 이미지, 텍스트레이블을 제공함 컬렉션뷰의 셀에는 이런거 제공 안함 그럼 셀에 올린 이미지뷰를 어떻게 접근할까?","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"High Order Function","slug":"21","date":"2020-01-21T04:13:45.000Z","updated":"2020-01-21T04:14:38.442Z","comments":true,"path":"2020/01/21/","link":"","permalink":"http://yoursite.com/2020/01/21/","excerpt":"","text":"High Order Function","categories":[{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/categories/iOS/"},{"name":"Swift","slug":"iOS/Swift","permalink":"http://yoursite.com/categories/iOS/Swift/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/tags/TIL/"}]},{"title":"Animation","slug":"13","date":"2020-01-13T04:25:00.000Z","updated":"2020-01-13T04:27:58.939Z","comments":true,"path":"2020/01/13/","link":"","permalink":"http://yoursite.com/2020/01/13/","excerpt":"","text":"Animation compactMap : Returns an array containing the non-nil results of calling the given transformation with each element of this sequence.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"MapKit 과제","slug":"homework-MapKit","date":"2020-01-11T11:29:29.000Z","updated":"2020-01-11T11:37:01.234Z","comments":true,"path":"2020/01/homework-MapKit/","link":"","permalink":"http://yoursite.com/2020/01/homework-MapKit/","excerpt":"","text":"Map Kit 과제 입력한 주소들을 차례로 잇는 선 구현하기 Text Field에 주소를 입력하면 해당 위치로 애니메이션과 함께 맵 이동 입력한 위치에 Annotation 추가하기 입력한 위치 주변에 사각형으로 PolyLine 그리기 Annotation의 title값으로 행선지 이름, subTitle 값으로 행선지 주소 표현하기","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"ScrollView 과제","slug":"homework-ScrollView","date":"2020-01-11T11:29:17.000Z","updated":"2020-02-15T02:35:18.366Z","comments":true,"path":"2020/01/homework-ScrollView/","link":"","permalink":"http://yoursite.com/2020/01/homework-ScrollView/","excerpt":"","text":"ScrollView 과제 UIPageControl 사용할 것 뷰 간의 우선순위를 적용하여 스토리보드 상에 표현되는 화면과, 실제 빌드 한 이후의 화면을 구분 지을 것 스크롤뷰 내부에서 오토레이아웃 적용할 것","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Scroll View","slug":"10","date":"2020-01-10T03:59:43.000Z","updated":"2020-01-11T11:28:05.997Z","comments":true,"path":"2020/01/10/","link":"","permalink":"http://yoursite.com/2020/01/10/","excerpt":"Scroll View 제한된 뷰의 크기보다 더 큰 크기를 가진 컨텐츠를 표현하기 위한 뷰 Content Size : 현재 보여지는 뷰에 관계 없이 스크롤뷰가 표현 할 수 있는 전체 컨텐츠 크기 일반적인 UIView는 오토레이아웃을 지정할 때 screen view 내부에서 상대적인 위치를 지정할 수 있음 시작과 끝 지점이 정해져있기 때문이다. 위치를 지정을 해줘도 스크롤링을 하게 되면 뷰의 위치가 달라지기 때문에 상하좌우 위치정보뿐만 아니라 추가적으로, 위치 값과 크기 값이 정해져야함 ScrollView 내부에 위치한 UI객체들에게 오토레이아웃을 적용하려면? ScrollView의 Size Inspector에서 Content Layout Guides의 체크를 풀어줘야한다. 이유는 잘 몰겠음..","text":"Scroll View 제한된 뷰의 크기보다 더 큰 크기를 가진 컨텐츠를 표현하기 위한 뷰 Content Size : 현재 보여지는 뷰에 관계 없이 스크롤뷰가 표현 할 수 있는 전체 컨텐츠 크기 일반적인 UIView는 오토레이아웃을 지정할 때 screen view 내부에서 상대적인 위치를 지정할 수 있음 시작과 끝 지점이 정해져있기 때문이다. 위치를 지정을 해줘도 스크롤링을 하게 되면 뷰의 위치가 달라지기 때문에 상하좌우 위치정보뿐만 아니라 추가적으로, 위치 값과 크기 값이 정해져야함 ScrollView 내부에 위치한 UI객체들에게 오토레이아웃을 적용하려면? ScrollView의 Size Inspector에서 Content Layout Guides의 체크를 풀어줘야한다. 이유는 잘 몰겠음.. fixed를 freedom으로 바꾸면 스토리 보드상에서 뷰의 표현 범위가 넓어진다. 실제로 넓어지는게 아니라 스토리보드상의 표현 범위만 넓어지는 것 뷰의 우선순위를 이용하여 실제 빌드 되는 화면과, 스토리보드상에 표현되는 화면을 다르게 설정 할 수 있다. 우측의 스토리보드 화면은 각 뷰의 width가 0.25로 보이지만 스크롤을 이용하여 화면이 다르게 표시 되게끔 하려면 Width 값이 1이 되어야함 width 값이 1인 constraint와 width값이 0.25인 constraint. 2개를 만든다. 0.25인 녀석의 우선순위를 1보다 먼저 놓으면 스토리보드 상에는 0.25로 설정된 것이 표현된다. 이 때 0.25인 녀석을 빌드 할 때 삭제 되도록 설정하면 실제 앱이 구동될 때는 1인 녀석이 구동된다. 0.25 constraint의 attribute Inspector에서 ‘Remove at build time’ 체크 스크롤뷰의 컨텐트 사이즈는 확대, 축소에 따라 계속 달라진다. 1배율일때가 가장 작음 왜냐면 화면에 보여지는 사이즈가 작으니깐.. Scroll View 내부의 Image 최대, 최소 배율 설정하기 view의 크기와 실제로는 view보다 커서 스크롤뷰를 이용해서 볼 수 있는 이미지의 배율을 설정할 수 있다. UIScrollView에서 무언가를 줌 인,아웃을 해야한다면, delegate에서 어떤 UI 객체에 대해 실행할 것인지 표기해주어야 한다. 스크롤뷰의 zoomScale 속성을 이용하면 확대, 축소 기능도 구현 가능! // 두배로 확대하기! scrollView.setZoomScale(zoomScale * 2, animated: true) &lt;!--￼0--&gt; ScrollView의 OffSet 속성을 이용하여 스크롤 이동하기 offSet? bound의 개념인 듯 (설명어려움) 어디서부터 content가 시작되는지. 에 대한 값 인듯 아래와 같은 경우 현재 scrollView의 contentOffSet.x 값은 0 scrollView의 contentOffSet.x 값에 150을 더하면.. 123 let newOffSet = CGPoint(x: scrollView.contentOffset.x + 150, y: scrollView.contentOffset.y)// offSet 셋! scrollView.setContentOffset(newOffSet, animated: true)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Core Location & Map Kit","slug":"9","date":"2020-01-09T04:08:46.000Z","updated":"2020-01-11T10:35:18.342Z","comments":true,"path":"2020/01/9/","link":"","permalink":"http://yoursite.com/2020/01/9/","excerpt":"Core Location 기기의 지리적 위치 정보를 가져와야 할 때 사용하는 프레임 워크 MapKit 과는 차이가 있다. (지도) 사용자에게 권한을 허가 받아야만 사용할 수 있다. MKMapView와 UITapGestureRecognizer를 같이 사용하여 지도상에 내가 터치한 위치 값을 받는 기능도 사용할 수 있다. @IBAction func recognizeTap(gesture: UITapGestureRecognizer) { let touchPoint = gesture.location(in: gesture.view) let coordinate = mapView.convert(touchPoint, toCoordinateFrom: mapView) let location = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude) } &lt;!--￼0--&gt;","text":"Core Location 기기의 지리적 위치 정보를 가져와야 할 때 사용하는 프레임 워크 MapKit 과는 차이가 있다. (지도) 사용자에게 권한을 허가 받아야만 사용할 수 있다. MKMapView와 UITapGestureRecognizer를 같이 사용하여 지도상에 내가 터치한 위치 값을 받는 기능도 사용할 수 있다. @IBAction func recognizeTap(gesture: UITapGestureRecognizer) { let touchPoint = gesture.location(in: gesture.view) let coordinate = mapView.convert(touchPoint, toCoordinateFrom: mapView) let location = CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude) } &lt;!--￼0--&gt; 실시간 위치 정보 업데이트 1234567891011121314151617181920212223242526272829303132333435func startUpdatingLocation() &#123; // 허가 상태를 받아옴 let status = CLLocationManager.authorizationStatus() // 상태가 사용할 때, 혹은 항상이면 ~~ 해라 guard status == .authorizedWhenInUse || status == .authorizedAlways else &#123; return &#125; // 위치 서비스 이용 가능한 상태이면 guard CLLocationManager.locationServicesEnabled() else &#123; return &#125; // locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters // locationManager.distanceFilter = 10.0 // 실제로 위치 업데이트 locationManager.startUpdatingLocation() &#125;extention ViewController: CLLocationManagerDelegate &#123; func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; // 반드시 하나의 값은 가지고 있어서 강제 언래핑 해도 됨 let current = locations.last! let coordinate = current.coordinate // 캐시 된 정보가 오래 된 거면 무시하고 10초 이내 것만 처리..(뭔솔?) if (abs(current.timestamp.timeIntervalSinceNow) &lt; 10) &#123; // if !setUp &#123; // span 단위는 1도 (경도 1도는 약 111킬로미터) let span = MKCoordinateSpan(latitudeDelta: 0.001, longitudeDelta: 0.001) // 현 위치를 중앙으로 넣고 span 만큼 보여주도록 설정 let region = MKCoordinateRegion(center: coordinate, span: span) mapView.setRegion(region, animated: true) //setUp.toggle() addAnnotaion(location: current) //&#125; &#125; &#125;&#125; 특정 좌표에 핀 찍기 1234567//&lt;CLLocationManagerDelegate&gt;func addAnnotaion(location: CLLocation) &#123; let annotation = MKPointAnnotation() annotation.coordinate = location.coordinate mapView.addAnnotation(annotation) &#125; CLLocationManagerDelegate 문서 읽어볼 것 CLPlaceMark CLPlaceMark 객체는 지정된 위도와 경도에 대한 장소 표시 데이터를 저장함 장소표시데이터? 국가, 주, 도시, 주소, 이 밖의 지리적으로 관련 된 정보가 포함되어있음 좌표(위경도)를 받아서 장소표시데이터를 저장하기 때문에 반대로 장소표시데이터를 이용하여 좌표를 얻어낼 수도 있음 국가별로 주소체계가 다르기 때문에 우리나라의 주소 체계와는 맞지 않는 property가 있으니 유의할 것 Ex) placeMark.subThroughfare : 값이 없음 -&gt; 에러 아래 코드 클로저 내부의 ‘placeMark’가 CLPlaceMark 타입 12345678910111213func geocodeAddressString(_ addressString: String) &#123; print(\"\\n---------- [ 주소 -&gt; 위경도 ] ----------\") let geocoder = CLGeocoder() geocoder.geocodeAddressString(addressString) &#123; (placeMark, error) in if error != nil &#123; return print(error!.localizedDescription) &#125; guard let place = placeMark?.first else &#123; return &#125; // 위경도값 출력 print(place.location?.coordinate) &#125; &#125; 12345678910111213141516171819202122func reverseGeocode(location: CLLocation) &#123; let geocoder = CLGeocoder() geocoder.reverseGeocodeLocation(location) &#123; placeMark, error in print(\"\\n---------- [ 위경도 -&gt; 주소 ] ----------\") if error != nil &#123; return print(error!.localizedDescription) &#125; // 국가별 주소체계에 따라 어떤 속성 값을 가질지 다름 guard let address = placeMark?.first, let country = address.country, let administrativeArea = address.administrativeArea, let locality = address.locality, let name = address.name else &#123; return &#125; let addr = \"\\(country) \\(administrativeArea) \\(locality) \\(name)\" print(addr) self.geocodeAddressString(addr) &#125; &#125; Annotation (핀 찍기) 특정 위치에 좌표값 (CLLocationCoordinate2D 타입)을 이용하여 Annotation을 추가할 수 있다. 123456789101112131415func addAnnotation(add: CLLocationCoordinate2D) &#123; // Annotation 객체 생성 let annotation = MKPointAnnotation() // Annotation의 property 설정 annotation.title = self.placeName annotation.subtitle = self.placeStreetAddress //annotation.subtitle = \"서울특별시\" // Annotation의 좌표 설정 annotation.coordinate = add // Annotation 추가 mapView.addAnnotation(annotation) &#125; PolyLine 그리기 지도상에 두 가지 이상의 좌표를 이용하여 특정 위치와, 다른 위치를 연결하는 선을 그릴 수 있음 이동 경로 등을 표시하는데 사용가능 polyLine을 추가한 후에는 렌더링을 해주어야 화면에 표시가 된다 123456789101112131415161718192021222324252627282930313233// 사각형 그리기 func addRectangle(coordinate: CLLocationCoordinate2D) &#123; print(\"-------- 사각형 그리기 -----------\") let center = coordinate var point1 = center; point1.latitude += 0.01; point1.longitude -= 0.01 var point2 = center; point2.latitude += 0.01; point2.longitude += 0.01 var point3 = center; point3.latitude -= 0.007; point3.longitude += 0.01 var point4 = center; point4.latitude -= 0.007 ; point4.longitude -= 0.01 // 위치 정보 배열 let points:[CLLocationCoordinate2D] = [point1, point2, point3, point4, point1] // polyLine 객체 생성 let polyLine = MKPolyline(coordinates: points, count: points.count) // polyLine 추가 mapView.addOverlay(polyLine) &#125; extension ViewController: MKMapViewDelegate &#123; func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; if let polyLine = overlay as? MKPolyline &#123; let renderer = MKPolylineRenderer(polyline: polyLine) // 얘네를 안주면 화면에 표시가 안됨 - 색도 없고, 선 두께도 없으니깐 renderer.strokeColor = .red renderer.lineWidth = 2 return renderer &#125; return MKOverlayRenderer(overlay: overlay) &#125;&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Gesture Recognizer","slug":"01-07-HomeWork","date":"2020-01-08T07:58:29.000Z","updated":"2020-01-08T08:05:19.057Z","comments":true,"path":"2020/01/01-07-HomeWork/","link":"","permalink":"http://yoursite.com/2020/01/01-07-HomeWork/","excerpt":"","text":"Gesture Recognizer 이전에 탭한 위치에서 거리가 10 이상이면 새로운 탭 (count 1 up)으로 계산할 것 touchbegan, UITapGestureRecognizer, UIGestureRecognizerDelegate의 shouldReceive 메서드 사용하여 세 가지 방식으로 구현할 것","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Gesture Recognizer","slug":"07","date":"2020-01-08T07:36:41.000Z","updated":"2020-01-08T07:37:34.229Z","comments":true,"path":"2020/01/07/","link":"","permalink":"http://yoursite.com/2020/01/07/","excerpt":"Gesture Recognizer 터치, 확대/축소, 회전, 드래깅, long press (길게 누르기). 등등 상호작용을 받아들이는 작업 뷰 위에 gesture recognizer를 올려서 사용! 스토리 보드에 gesture 라고 쳐보면 나옴 이 녀석들을 뷰 위에 올리면 됨 (필요한 액션 별로) 사실 viewController에 touch라고 액션을 캐치 할 수 있는 메서드가 있긴 함 (잠깐 언급)","text":"Gesture Recognizer 터치, 확대/축소, 회전, 드래깅, long press (길게 누르기). 등등 상호작용을 받아들이는 작업 뷰 위에 gesture recognizer를 올려서 사용! 스토리 보드에 gesture 라고 쳐보면 나옴 이 녀석들을 뷰 위에 올리면 됨 (필요한 액션 별로) 사실 viewController에 touch라고 액션을 캐치 할 수 있는 메서드가 있긴 함 (잠깐 언급) 1234567891011override func viewDidLoad() &#123; super.viewDidLoad() let tapGesture = UITapGestureRecognizer()target: self,action: #selector(handleTap(_:))view.addGestureRecognizer(tapGesture)&#125;@objc func handleTap(_ sender: UITapGestureRecognizer) &#123;// code&#125; The states of a gesture discrete - 제스쳐가 인식이 되었을 때 액션 메소드가 정확히 한번만 호출 되는 것 continuous - 기준이 충족 되면 액션이 반복적으로 호출 됨 TouchView Controller touchesBegan - 터치가 시작 되었을 때 1234override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; // 첫 터치가 있으면 구문 실행 guard let touch = touches.first else &#123; return &#125;&#125; touchesMoved - 터치 후 손을 떼지 않고 이동 1234override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; guard let touch = touches.first else &#123; return &#125; let touchPoint = touch.location(in: touch.view)&#125; touchesEnded - 손을 뗀 상태 Gesture스토리보드에서 TapGestureRecognizer를 뷰 위나, 이미지뷰 위로 끌어서 해볼것임 Tap - 눌렀다 땜 (3이면 세번 탭) Touch - 그냥 접촉 (3이면 세 손가락으로 터치) Tap Gesture Recognizer Swipe Gesture Recognizer 1sender.direction = .right (.left, .up, .down) Rotation Gesture Recognizer 1imageView.transform = imageView.transform.rotated(by: sender.rotation) Pan Gesture Recognizer (drag) -&gt; 드래그해서 이미지 위치 옮기기 123456789101112131415161718192021var initialCenter = CGPoint.zero @IBAction func panGesture(_ sender: UIPanGestureRecognizer) &#123; guard let dragView = sender.view else &#123;return&#125; // 그냥하면 안됨 스토리보드에서 이거 체크해주던지 아래처럼 코드로 써줘야함 dragView.isUserInteractionEnabled = true let translation = sender.translation(in: dragView.superview) if sender.state == .began &#123; initialCenter = dragView.center &#125; if sender.state != .cancelled &#123; dragView.center = CGPoint(x: initialCenter.x + translation.x, y: initialCenter.y + translation.y) &#125; else &#123; dragView.center = initialCenter &#125; &#125; Long Press Recognizer","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"URL Scheme & ImagePicker","slug":"06","date":"2020-01-06T04:02:22.000Z","updated":"2020-01-06T08:19:33.929Z","comments":true,"path":"2020/01/06/","link":"","permalink":"http://yoursite.com/2020/01/06/","excerpt":"URL Scheme &amp; Image Picker 어떤 버튼을 눌렀을 때 다른 앱을 열 수 있도록 하는 것 설정 1234guard let url = URL(string: UIApplication.openSettingsURLString), UIApplication.shared.canOpenURL(url) else &#123;return&#125; UIApplication.shared.open(url)","text":"URL Scheme &amp; Image Picker 어떤 버튼을 눌렀을 때 다른 앱을 열 수 있도록 하는 것 설정 1234guard let url = URL(string: UIApplication.openSettingsURLString), UIApplication.shared.canOpenURL(url) else &#123;return&#125; UIApplication.shared.open(url) 메일 (그냥 켜고 싶으면 받는 사람 지우면 됨, 다중으로 보내려면 , 넣고 여러 개 쓰면 됨. 띄어쓰기 금지) 12345let scheme = \"mailto:jeonsangmin77@gmail.com\" guard let url = URL(string:scheme) else &#123; return &#125; UIApplication.shared.open(url) 참조, 제목 등등도 미리 작성해놓으려면? (숨은 참조는 bcc) 1let scheme = \"mailto:jeonsangmin77@gmail.com?cc=foo@bar&amp;subject=title&amp;body=MyText\" 메세지 (body에 한글을 넣으려면 변환 과정이 필요함) 12345let url = URL(string: \"sms:010-9999-9999&amp;body=Hello\")! guard UIApplication.shared.canOpenURL(url) else &#123; return &#125; UIApplication.shared.open(url) Web 페이지 등도 같은 방법으로 string 값만 바꿔주면 됨 위의 세 가지는 시스템 App 3rd Party App 화이트리스트 등록 필요 최초 1회 넘어갈 때 이동을 허락하면 이후부터는 바로 넘어감 info.plist 우클릭 openAs, sourcecode에 들어가서 안에 1234&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;fb&lt;/string&gt; &lt;/array&gt; MyApp의 URL Scheme 등록하기 Infoplist -&gt; info -&gt; URL Schemes에 등록 실습 MyApp 하나 새로 만들고 해당 앱의 AppDelegate에 1234567891011121314151617func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -&gt; Bool &#123; print(\"sourceApplication :\", options[.sourceApplication] ?? \"\") print(\"app :\", app) print(\"url :\", url) if let scheme = url.scheme &#123; print(\"scheme :\", scheme) &#125; if let host = url.host &#123; print(\"host :\", host) &#125; if let query = url.query &#123; print(\"query :\", query) &#125; return true &#125; 입력 MyApp에 접근할 앱에 info 등록 해놓고 켜보면 값 넘길 수 있음 123456 let url = URL(string: \"smApp://host?name=abc&amp;age=10\")!/* - scheme: myApp - host: host - query: name=abc&amp;age=10*/ Image Picker UIImagePickerControllerDelegate, UINavigationControllerDelegate 사진이나, 동영상을 촬영할 때는 카메라, 앨범, 마이크 등에 대한 접근 권한을 추가해주어야 한다. Infoplist 에서 Privacy usage camera… 등등등 위 두가지 delegate extension에 채택하고 시작 imagePicker Delegate에 didCancle 메서드는 cancle 버튼 눌렀을 때 동작한다. 수행할 작업이 없으면 생략한다. didFinishPickingMediaWithInfo 에서 주로 작업한다. 이미지 선택 12imagePicker.sourceType = .savedPhotosAlbum present(imagePicker, animated: true) 사진 촬영 123456789101112131415guard UIImagePickerController.isSourceTypeAvailable(.camera) else &#123; return &#125; imagePicker.sourceType = .camera print(imagePicker.mediaTypes) // video는 소리가 들어가기 때문에 마이크 사용에 대한 권한허용이 필요함. 안해주면 어플 죽음 let mediaTypes = UIImagePickerController.availableMediaTypes(for: .camera) imagePicker.mediaTypes = mediaTypes ?? [] // imagePicker.mediaTypes = [\"public.image\"] // [\"public.image\"] == kUTTypeImage 같기 때문에 아래 처럼 써주는 게 좋음! // imagePicker.mediaTypes = [kUTTypeImage as String] // imagePicker.mediaTypes = [kUTTypeImage, kUTTypeMovie] as [String] present(imagePicker, animated: true) 지연 촬영 12345678910guard UIImagePickerController.isSourceTypeAvailable(.camera) else &#123; return &#125; imagePicker.sourceType = .camera imagePicker.mediaTypes = [kUTTypeImage as String] present(imagePicker, animated: true) &#123; // 2초 뒤 delay 촬영 DispatchQueue.main.asyncAfter(deadline: .now() + 2, execute: &#123; self.imagePicker.takePicture() &#125;) &#125; 동영상 촬영 12345678910111213guard UIImagePickerController.isSourceTypeAvailable(.camera) else &#123; return &#125; imagePicker.sourceType = .camera // Movie - 소리포함, kUTTypeVideo - 영상만! imagePicker.mediaTypes = [kUTTypeMovie as String] // \"public.movie\" imagePicker.cameraCaptureMode = .video // .photo 둘 중 뭐가 처음에 뜨게 하는지 결정! imagePicker.cameraDevice = .rear // .front 전면, 후방 카메라 선택 present(imagePicker, animated: true) // 동영상 촬영 시작 - 종료 // imagePicker.startVideoCapture() // imagePicker.stopVideoCapture() 사진 수정 모드 허용/비허용 1imagePicker.allowsEditing.toggle() Delegate12345678910111213141516171819202122232425262728293031func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) &#123; // 사진 앨범을 누르는 순간 동작! print(\"=== imagePickerController ===\") let mediaType = info[.mediaType] as! NSString if UTTypeEqual(mediaType, kUTTypeImage) &#123; let originalImage = info[.originalImage] as! UIImage let editedImage = info[.editedImage] as? UIImage let selectedImage = editedImage ?? originalImage // imageView.image = originalImage imageView.image = selectedImage if picker.sourceType == .camera &#123; // souce의 picker type이 카메라 일때만 저장! UIImageWriteToSavedPhotosAlbum(selectedImage, nil, nil, nil) &#125; &#125; else if UTTypeEqual(mediaType, kUTTypeMovie) &#123; // 동영상 -&gt; 앨범에 저장 if let mediaPath = (info[.mediaURL] as? NSURL)?.path, UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(mediaPath) &#123; UISaveVideoAtPathToSavedPhotosAlbum(mediaPath, nil, nil, nil) &#125; &#125; // let originalInamge = info[.originalImage] as! UIImage // imageView.image = originalInamge picker.dismiss(animated: true) &#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Calculator Practice","slug":"20","date":"2019-12-20T03:59:59.000Z","updated":"2019-12-20T04:00:35.631Z","comments":true,"path":"2019/12/20/","link":"","permalink":"http://yoursite.com/2019/12/20/","excerpt":"","text":"","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Cell Style","slug":"19","date":"2019-12-19T04:08:56.000Z","updated":"2019-12-19T06:31:02.765Z","comments":true,"path":"2019/12/19/","link":"","permalink":"http://yoursite.com/2019/12/19/","excerpt":"","text":"Cell Style델리게이트, 태그, 테이블뷰의 특정 셀의 row값을 이용해서, 특정셀을 가져와서 작업하는 방법","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"TableView 과제","slug":"homework_1218","date":"2019-12-18T08:40:35.000Z","updated":"2019-12-18T08:56:16.368Z","comments":true,"path":"2019/12/homework_1218/","link":"","permalink":"http://yoursite.com/2019/12/homework_1218/","excerpt":"Table View Multiple Selection수행 과제 첫 목록은 1부터 지정한 숫자까지 테이블뷰로 출력 갱신(Refresh)할 때 마다 지정한 수의 +50 사이의 숫자로 지정한 수 만큼만 무작위로 출력 출력 되는 숫자들은 중복 값이 있으면 안됨 특정 Cell을 선택하고, 갱신하면 선택 된 숫자만 남기고, 나머지 숫자들만 다시 무작위로 출력 특정 Cell 복수 선택 가능 단, 7보다 낮은 수는 선택 할 수 없도록 처리할 것","text":"Table View Multiple Selection수행 과제 첫 목록은 1부터 지정한 숫자까지 테이블뷰로 출력 갱신(Refresh)할 때 마다 지정한 수의 +50 사이의 숫자로 지정한 수 만큼만 무작위로 출력 출력 되는 숫자들은 중복 값이 있으면 안됨 특정 Cell을 선택하고, 갱신하면 선택 된 숫자만 남기고, 나머지 숫자들만 다시 무작위로 출력 특정 Cell 복수 선택 가능 단, 7보다 낮은 수는 선택 할 수 없도록 처리할 것 시연 화면 선택 한 값들이 맨 위에 남는지 주목","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift,","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"TableView","slug":"TableView","permalink":"http://yoursite.com/tags/TableView/"}]},{"title":"UITable View","slug":"17","date":"2019-12-17T04:02:58.000Z","updated":"2019-12-18T09:32:52.059Z","comments":true,"path":"2019/12/17/","link":"","permalink":"http://yoursite.com/2019/12/17/","excerpt":"UITable View테이블 뷰도 여러 스타일이 있음 기본 스타일 하나 이상의 행을 가짐 Grouped Table Views 관련 된 아이템들을 하나의 그룹으로 그룹핑 Code아래와 같이 생성한다. (50개의 숫자)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import UIKitfinal class TableViewExample: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 테이블뷰 객체 생성 let tableView = UITableView(frame: view.frame) // 반드시 선언 (빈 셀을 출력하지는 않으므로, 셀에 들어갈 내용에 관한 부분 -&gt; delegate 패턴) tableView.dataSource = self // 재사용을 위해 cell 등록 tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"CellID\") // 뷰에 add view.addSubview(tableView) &#125;&#125;// MARK: -DataSourceextension TableViewExample: UITableViewDataSource &#123; // 출력할 행(row)의 갯수 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 50 &#125; // 행의 셀 indexPath (배열 형태로 구성 되어있기 때문에 셀 하나가 배열 값 하나임. 그래서 index 주소가 필요함) func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;// let cell = tableView.dequeueReusableCell(withIdentifier: \"CellID\", for: indexPath)// cell.textLabel?.text = \"\\((indexPath.row) + 1)\"// return cell // 셀 타입 정의 let cell: UITableViewCell // reusableCell에 Cell // 셀 갯수가 화면에 표시 될 수 있는 양보다 많으면 스크롤이 생김, 이 때 스크롤을 내리면 위에서 표현 되지 못한 셀들이 나오게 됨 // 화면에 표시 될 때마다 셀 객체를 생성하는 것은 좋지 않기 때문에 // 스크롤을 올렸다 내리는 과정에서, 화면에서 보였다가, 안보이는 셀 객체들을 매번 생성하는 것이 아니라 재사용해야함. // 아래 코드는 재사용을 위한 처리 if let reusableCell: UITableViewCell = tableView.dequeueReusableCell(withIdentifier: \"CellID\") &#123; cell = reusableCell &#125; else &#123; cell = UITableViewCell(style: .default, reuseIdentifier: \"CellID\") &#125; cell.textLabel?.text = \"\\(indexPath.row)\" return cell &#125; &#125;","text":"UITable View테이블 뷰도 여러 스타일이 있음 기본 스타일 하나 이상의 행을 가짐 Grouped Table Views 관련 된 아이템들을 하나의 그룹으로 그룹핑 Code아래와 같이 생성한다. (50개의 숫자)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import UIKitfinal class TableViewExample: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // 테이블뷰 객체 생성 let tableView = UITableView(frame: view.frame) // 반드시 선언 (빈 셀을 출력하지는 않으므로, 셀에 들어갈 내용에 관한 부분 -&gt; delegate 패턴) tableView.dataSource = self // 재사용을 위해 cell 등록 tableView.register(UITableViewCell.self, forCellReuseIdentifier: \"CellID\") // 뷰에 add view.addSubview(tableView) &#125;&#125;// MARK: -DataSourceextension TableViewExample: UITableViewDataSource &#123; // 출력할 행(row)의 갯수 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 50 &#125; // 행의 셀 indexPath (배열 형태로 구성 되어있기 때문에 셀 하나가 배열 값 하나임. 그래서 index 주소가 필요함) func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123;// let cell = tableView.dequeueReusableCell(withIdentifier: \"CellID\", for: indexPath)// cell.textLabel?.text = \"\\((indexPath.row) + 1)\"// return cell // 셀 타입 정의 let cell: UITableViewCell // reusableCell에 Cell // 셀 갯수가 화면에 표시 될 수 있는 양보다 많으면 스크롤이 생김, 이 때 스크롤을 내리면 위에서 표현 되지 못한 셀들이 나오게 됨 // 화면에 표시 될 때마다 셀 객체를 생성하는 것은 좋지 않기 때문에 // 스크롤을 올렸다 내리는 과정에서, 화면에서 보였다가, 안보이는 셀 객체들을 매번 생성하는 것이 아니라 재사용해야함. // 아래 코드는 재사용을 위한 처리 if let reusableCell: UITableViewCell = tableView.dequeueReusableCell(withIdentifier: \"CellID\") &#123; cell = reusableCell &#125; else &#123; cell = UITableViewCell(style: .default, reuseIdentifier: \"CellID\") &#125; cell.textLabel?.text = \"\\(indexPath.row)\" return cell &#125; &#125; SectionTable View에서 각 셀의 indexPath를 출력해보면 12345[0, 0][0, 1]... 위와 같이 배열의 형태로 출력된다. 첫 번째는 Section을 의미하고, 두 번째는 행의 index를 나타낸다. 위와 같이 A, B, C, D 로 section을 나눌 수 있다. Dictionary 형태로 data를 저장한다. 123456let fruitsDict = [ \"A\": [\"Apple\", \"Avocado\"], \"B\": [\"Banana\", \"Blackberry\"], \"C\": [\"Cherry\", \"Coconut\"], \"D\": [\"Durian\"]] key는 section, value는 row이다. dataSource에 섹션 부분을 추가한다. 1234567891011121314151617// section titlefunc tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; sectionTitles[section]&#125;// section의 row 갯수 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 딕셔너리 넣을거니깐, 딕셔너리의 키값의 갯수 만큼 let titles = fruitsDict.keys.sorted() // 키 뽑아냄 let key = titles[section] // key의 배열의 갯수 return fruitsDict[key]!.count // 아래와 같이 축약한다. //return fruitsDict[sectionTitles[section]]!.count&#125; 끝~","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"로그인 화면 구현하기","slug":"homework-1214","date":"2019-12-16T12:22:41.000Z","updated":"2019-12-16T12:44:43.886Z","comments":true,"path":"2019/12/homework-1214/","link":"","permalink":"http://yoursite.com/2019/12/homework-1214/","excerpt":"Login Practice123456789101112131415161718192021[ 필수 구현 기능 ]// 스토리보드, 코드 자유1. 별도 첨부한 이미지와 같이 UI 구현. 원하는 형식으로 바꿔도 무관2. 텍스트 필드는 UITextFieldDelegate 이용3. 키보드에 의해 아이디와 비밀번호 textField가 가릴 수 있으므로 키보드가 나타날 때는 텍스트필드 위로 끌어올리고 내려갈 때는 같이 내려가기4. 미리 설정해둔 아이디와 비밀번호가 동일할 경우 로그인이 완료된 메인 화면으로 이동 5. 메인 화면에서는 입력받은 아이디를 출력하는 Label을 띄우고 다시 로그인 화면으로 돌아갈 수 있는 Sign Out 버튼 구성 [ 추가 기능 (1) ]1. 미리 설정해둔 아이디와 비밀번호가 다를 경우 텍스트필드의 바탕화면을 일시적으로 빨갛게 만들었다가 원상 복구하기2. 텍스트필드에 입력할 수 있는 최대 글자 수는 16자까지/*3. 아이디와 비밀번호는 모두 4 ~ 16자 사이여야 함*/[ 추가 기능 (2) ]1. 자동 로그인한 번 로그인에 성공했으면 Sign Out을 하기 전에는 앱을 껏다 켜도 자동 로그인된 상태로 메인 화면으로 진입/*2. 회원 가입 페이지회원가입 페이지를 만든 뒤 회원 가입한 유저의 아이디와 비밀번호를 추가하고그것으로도 로그인 할 수 있도록 구현하기*/","text":"Login Practice123456789101112131415161718192021[ 필수 구현 기능 ]// 스토리보드, 코드 자유1. 별도 첨부한 이미지와 같이 UI 구현. 원하는 형식으로 바꿔도 무관2. 텍스트 필드는 UITextFieldDelegate 이용3. 키보드에 의해 아이디와 비밀번호 textField가 가릴 수 있으므로 키보드가 나타날 때는 텍스트필드 위로 끌어올리고 내려갈 때는 같이 내려가기4. 미리 설정해둔 아이디와 비밀번호가 동일할 경우 로그인이 완료된 메인 화면으로 이동 5. 메인 화면에서는 입력받은 아이디를 출력하는 Label을 띄우고 다시 로그인 화면으로 돌아갈 수 있는 Sign Out 버튼 구성 [ 추가 기능 (1) ]1. 미리 설정해둔 아이디와 비밀번호가 다를 경우 텍스트필드의 바탕화면을 일시적으로 빨갛게 만들었다가 원상 복구하기2. 텍스트필드에 입력할 수 있는 최대 글자 수는 16자까지/*3. 아이디와 비밀번호는 모두 4 ~ 16자 사이여야 함*/[ 추가 기능 (2) ]1. 자동 로그인한 번 로그인에 성공했으면 Sign Out을 하기 전에는 앱을 껏다 켜도 자동 로그인된 상태로 메인 화면으로 진입/*2. 회원 가입 페이지회원가입 페이지를 만든 뒤 회원 가입한 유저의 아이디와 비밀번호를 추가하고그것으로도 로그인 할 수 있도록 구현하기*/ 비밀번호 치는 부분은 키보드와 TextField 부분은 녹화 안됨. (보안 때문에 애초에 영상 녹화 할 때 안보이게 처리하는 듯) 오토레이아웃, 위에서 주석 처리 된 부분 구현 안함 SceneDelegate 12345678910111213141516171819202122232425262728import UIKitclass SceneDelegate: UIResponder, UIWindowSceneDelegate &#123; var window: UIWindow? // MARK: - 로그인 상태 여부에 따라 첫 화면 바꾸기 func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) &#123; guard let _ = (scene as? UIWindowScene) else &#123; return &#125; let vcText: String let board = UIStoryboard(name: \"Main\", bundle: nil) if (UserDefaults.standard.string(forKey: \"id\") == nil) &#123; vcText = \"FirstVC\" print(UserDefaults.standard.string(forKey: \"id\")) &#125; else &#123; vcText = \"MainVC\" &#125; let vc = board.instantiateViewController(withIdentifier: vcText) if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene &#123; let sceneDelegate = windowScene.delegate as? SceneDelegate window?.rootViewController = vc sceneDelegate?.window = window window?.makeKeyAndVisible() &#125;&#125; ViewController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//// ViewController.swift// LoginPractice//// Created by MyMac on 2019/12/13.// Copyright © 2019 sandMan. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; // 로고 부분 @IBOutlet weak var viewPackage: UIView! @IBOutlet weak var redView3: UIView! @IBOutlet weak var redView2: UIView! @IBOutlet weak var redView1: UIView! @IBOutlet weak var signInBtn: UIButton! // 화면 하단 입력부분 @IBOutlet weak var viewPack: UIView! @IBOutlet weak var emailImage: UIImageView! @IBOutlet weak var emailTf: UITextField! @IBOutlet weak var emailUnderLIne: UIView! @IBOutlet weak var pwImage: UIImageView! @IBOutlet weak var pwTf: UITextField! @IBOutlet weak var pwUnderLine: UIView! // 개인정보 let account = [\"qqqq\" : \"qqqq\", \"min77@gmail.com\" : \"1234\" ] override func viewDidLoad() &#123; super.viewDidLoad() setUIViews() emailTf.delegate = self pwTf.delegate = self &#125; override func viewDidAppear(_ animated: Bool) &#123; self.emailTf.becomeFirstResponder() print(\"---로그인화면---\") &#125; func setUIViews() &#123; viewPackage.layer.cornerRadius = viewPackage.frame.width / 4 &#125; // 뒤로가기 및 로그아웃 @IBAction func unwindToFirstView(_ unwindSegue: UIStoryboardSegue) &#123; UserDefaults.standard.removeObject(forKey: \"id\") emailTf.text = \"\" pwTf.text = \"\" &#125; @IBAction func unwindFromSignUp(_ unwindSegue: UIStoryboardSegue) &#123; &#125; // MARK: - 로그인 구현 override func shouldPerformSegue(withIdentifier identifier: String, sender: Any?) -&gt; Bool &#123; guard let id = emailTf.text, let pw = pwTf.text else &#123;return false&#125; if account[id] == pw&#123; return true &#125; else &#123; // 아이디, 비번 틀리면 로그인 안되고 텍스트 필드 빨갛게 반짝 UIView.animate(withDuration: 0.3, animations: (&#123; self.emailTf.backgroundColor = .red self.emailTf.backgroundColor = .none self.pwTf.backgroundColor = .red self.pwTf.backgroundColor = .none &#125;)) return false &#125; &#125; override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; guard let mainVC = segue.destination as? MainViewController//, let id = emailTf.text else &#123;return&#125; mainVC.email = UserDefaults.standard.string(forKey: \"id\") ?? \"nil\" &#125; &#125;// MARK: - transform 올리기, 내리기extension ViewController:UITextFieldDelegate &#123; func textFieldDidBeginEditing(_ textField: UITextField) &#123; UIView.animate(withDuration: 0.25, animations: (&#123; self.viewPack.transform = CGAffineTransform(translationX: 0, y: -130) &#125;)) &#125; // didEndEditing은 어떤 식이든 수정이 끝나서 텍스트필드에서 포커싱이 해제 된 이후 실행된다. // 리턴 버튼으로 키보드 내리기 func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123; textField.resignFirstResponder() return true &#125; // 다른 곳 터치하면 키보드 내리기 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)&#123; self.view.endEditing(true) &#125; // 수정 끝나면 transform 내리기 func textFieldDidEndEditing(_ textField: UITextField) &#123; UserDefaults.standard.set(emailTf.text, forKey: \"id\") UIView.animate(withDuration: 0.25, animations: (&#123; self.viewPack.transform = .identity &#125;)) &#125; // 글자수 제한 =&gt; 16자 이상이면 아예 안써짐 func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123; let currentText = textField.text ?? \"\" guard let stringRange = Range(range, in: currentText) else &#123; return false &#125; let updatedText = currentText.replacingCharacters(in: stringRange, with: string) return updatedText.count &lt;= 16 &#125;&#125; MainViewController 123456789101112131415161718192021222324252627282930313233343536373839404142//// MainViewController.swift// LoginPractice//// Created by MyMac on 2019/12/13.// Copyright © 2019 sandMan. All rights reserved.//import UIKitclass MainViewController: UIViewController &#123; @IBOutlet weak var emailIndicator: UILabel! var email = \"\" override func viewDidLoad() &#123; super.viewDidLoad() emailIndicator.text = UserDefaults.standard.string(forKey: \"id\") &#125; @IBAction func signOutBtn(_ sender: UIButton) &#123; // SignOut 버튼 누르면 rootViewController 교체 let board = UIStoryboard(name: \"Main\", bundle: nil) let vc = board.instantiateViewController(withIdentifier:\"FirstVC\") if #available(iOS 13.0, *) &#123; if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene &#123; let window = UIWindow(windowScene: windowScene) let sceneDelegate = windowScene.delegate as? SceneDelegate window.rootViewController = vc sceneDelegate?.window = window window.makeKeyAndVisible() &#125; &#125; &#125; override func viewDidAppear(_ animated: Bool) &#123; print(\"---메인화면---\") &#125; @IBAction func removeAndgoFirst(_ sender: UIButton) &#123; UserDefaults.standard.removeObject(forKey: \"id\") &#125;&#125;","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"StackView","slug":"homework-1216","date":"2019-12-16T12:18:36.000Z","updated":"2019-12-16T12:20:18.894Z","comments":true,"path":"2019/12/homework-1216/","link":"","permalink":"http://yoursite.com/2019/12/homework-1216/","excerpt":"","text":"AutoLayout_StackView","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"AutoLayout","slug":"16","date":"2019-12-16T04:14:33.000Z","updated":"2019-12-16T06:40:50.096Z","comments":true,"path":"2019/12/16/","link":"","permalink":"http://yoursite.com/2019/12/16/","excerpt":"AutoLayout (2nd)Intrinsic Content Size UIView는 위치와 크기를 정해주어야 함 (위치, 크기) Leading, trailing 을 이용해서 사이즈를 정해주던지, 직접 width height를 정해주던지 UILable은 UIView와는 다르게 top과 leading만 맞춰줘도 충분함. 왜?","text":"AutoLayout (2nd)Intrinsic Content Size UIView는 위치와 크기를 정해주어야 함 (위치, 크기) Leading, trailing 을 이용해서 사이즈를 정해주던지, 직접 width height를 정해주던지 UILable은 UIView와는 다르게 top과 leading만 맞춰줘도 충분함. 왜? label은 어떠한 정해진 크기를 이미 가지고 있음 (font size, text 등으로 label의 크기가 결정 됨) 단 label은 trailing 값이 정해지면, 크기가 오른쪽으로 늘어나지 않고 왼쪽으로 늘어남 UIView도 크기가 정해지면 leading과 top만 잡아줘도 위치는 정해짐 UIButton도 Label처럼 잡아주면 된다. 고유의 컨텐츠 사이즈(Intrinsic Content Size) 가 정해짐 UIImage는 두 가지 경우가 있음 (이미지가 있을 때, 없을 때) 없을 때는 UIVIew와 같은 상태 이미지가 있을 때는 이미지 뷰의 크기를 알 방법이 없었지만, 이미지가 들어가는 순간 이미지의 사이즈가 UIImageView의 크기가 됨 UISilder는 위치와 width 값만 잡아줘도 됨 datePicker는 위치만 잡아줘도 됨 CH / CR Content hugging : 텍스트를 예로 들면, hugging이 정해지면, 크기가 제한되기 때문에 글이 길어져도 안커진다 줄어들 때와 관련이 있음 Content Compression Resistance Priority : 늘어날 때와 관련이 있음 Priority (우선 순위)예를 들면 한 UIVIew에 top이 두 개임, 하나는 100만큼, 하나는 150임 =&gt; 두 가지 제약 조건이 충돌이 남 이 때 100짜리에 우선 순위를 좀 더 높게 주면, 150 짜리는 일단 무시 됨 우선 순위를 코드로 지정 할 때는 아래와 같이 사용할 수 있음 12UIVIew.requiredUIView.high Dynamic AutoLayout Example제약 조건 자체를 IBOutlet으로 연결한 후, 여러 방법으로 컨트롤하여 위치를 동적으로 변경 할 수 있다. constant 변경, multiplier변경 123456// center horizentally 제약조건@IBOutlet weak var centerXConstraint: NSLayoutConstraint! override func viewDidAppear(_ animated: Bool) &#123; centerXConstraint.constant = -100 &#125; 우선순위 변경 1centerXConstraint.priority = .defaultHigh // 750 isActive 123456789101112@IBOutlet var centerXConstraint: NSLayoutConstraint!override func viewDidAppear(_ animated: Bool) &#123; // isActive를 false로 꺼놓으면 제약조건을 지운 것과 같은 상태 // (weak일 때)false로 한번이라도 설정이 되면 RC가 0이 되어서 다시 true로 켜도 안됨 // weak을 지우면 false로 했더라도 다시 true로 바꿀 수 있음 centerXConstraint.isActive = false centerXConstraint.constant = 200 centerXConstraint.isActive = true&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Animation","slug":"13","date":"2019-12-13T04:17:28.000Z","updated":"2019-12-13T04:38:47.463Z","comments":true,"path":"2019/12/13/","link":"","permalink":"http://yoursite.com/2019/12/13/","excerpt":"Animation UIWindow - login - main 순으로 실행될 건데, 로그인을 한번 한 이후 자동로그인이 되어서 UIWindow - Main으로 이어지게 되려면? 순서를 바꿔서 UIWindow - main - login인데 로그인이 되어있는 상태라면 main까지만 실행되게해도 됨 present로 뷰를 넘기지 말고, 아예 window를 바꿔버리는 경우도 많음 (RC없어짐)","text":"Animation UIWindow - login - main 순으로 실행될 건데, 로그인을 한번 한 이후 자동로그인이 되어서 UIWindow - Main으로 이어지게 되려면? 순서를 바꿔서 UIWindow - main - login인데 로그인이 되어있는 상태라면 main까지만 실행되게해도 됨 present로 뷰를 넘기지 말고, 아예 window를 바꿔버리는 경우도 많음 (RC없어짐) SecondView를 window로 바꾸기 (iOS13 이상 버전에서 사용) 123456789101112131415161718192021222324@IBAction private func didTapButton(_ sender:UIButton) &#123; if #available(iOS 13.0. *) &#123; if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene &#123; let window = UIWibdow(windowScene: windowScene) window = rootViewController = SecondViewController() let sceneDelegate = windowScene.delegate as? SceneDelegate sceneDelegate?.window = window window.makeKeyAndVisible() &#125; else &#123; UIApplication.shared.delegate as? AppDelegate as! AppDelegate appDelegate.window = UIWindow(frame:UIScreen.main.bounds) window.rootViewCOntroller = ScondViewController() window.makeKaeyAndVisible() appDelegate.window = window &#125; &#125;&#125;if 자동로그인 on &#123; 메인&#125; else &#123; 로그인&#125;","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift,","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"AutoLayout","slug":"12","date":"2019-12-12T04:17:35.000Z","updated":"2019-12-12T08:00:44.856Z","comments":true,"path":"2019/12/12/","link":"","permalink":"http://yoursite.com/2019/12/12/","excerpt":"AutoLayout[프레임 기반] 원점의 위치와 크기를 통해 그릴 영역 계산 가장 유연, 빠른 성능 동적인 변화에 대한 설계 및 디버그, 유지관리에 많은 노력 필요 Auto Resizing안에있는 화살표를 체크하면 width, height 값에 영향, 바깥 화살표를 선택하면 바깥의 view와의 margin에 영향","text":"AutoLayout[프레임 기반] 원점의 위치와 크기를 통해 그릴 영역 계산 가장 유연, 빠른 성능 동적인 변화에 대한 설계 및 디버그, 유지관리에 많은 노력 필요 Auto Resizing안에있는 화살표를 체크하면 width, height 값에 영향, 바깥 화살표를 선택하면 바깥의 view와의 margin에 영향 설정을 했을 때 슈퍼뷰의 크기가 변할 때 서브뷰가 어떻게 반응할 것인가 설정해주는것 Constraints 제약조건을 이용해 유저 인터페이스 정의 뷰 간의 관계 설정을 통한 크기와 위치 계산 내/외부 변경 사항에 동적으로 반응 모든 뷰에 다 설정을 해주어야함, 일부만 제약설정을 해주면 오히려 잘 되던것도 안됨 (뷰끼리 관계를 맺어줬을 때) 뷰 간 관계가 설정되어있지 않다면 일부만 설정해도 상관없음","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift,","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Delegate","slug":"10","date":"2019-12-10T04:05:59.000Z","updated":"2019-12-10T09:33:42.162Z","comments":true,"path":"2019/12/10/","link":"","permalink":"http://yoursite.com/2019/12/10/","excerpt":"[13:00 ~ 14:00] - DelegateExample커스텀뷰를 만들어서 UIView의 클래스를 CustomView로 바꾸고, 커스텀뷰에서는 배경색이 바뀔 때마다, 해당 색을 출력하는 기능을 만듦 123456789101112131415161718192021import UIKitclass CustomView: UIView &#123; // 내가 어떤 뷰를 정의해서 쓰려고 하는 거 // 맨처음에 스토리보드에 만든 뷰를 커스텀뷰 class로 변경!(identity inspector) // 값이 변경될 때마다 해당 값 출력하려면? (프로퍼티 옵저버 못씀) override var backgroundColor: UIColor? &#123; get &#123; super.backgroundColor &#125; set &#123; // 이거 super 생략하면, self인데 그렇게 되면 위에 background 컬러에 set 됨, 무한 재귀 // 배경색이 nil이면 black아니면 newValue super.backgroundColor = newValue ?? .black if newValue == .red &#123; super.backgroundColor = .blue &#125; print(\"새로 변경 될 배경색은 : \", self.backgroundColor!) &#125; &#125;&#125;","text":"[13:00 ~ 14:00] - DelegateExample커스텀뷰를 만들어서 UIView의 클래스를 CustomView로 바꾸고, 커스텀뷰에서는 배경색이 바뀔 때마다, 해당 색을 출력하는 기능을 만듦 123456789101112131415161718192021import UIKitclass CustomView: UIView &#123; // 내가 어떤 뷰를 정의해서 쓰려고 하는 거 // 맨처음에 스토리보드에 만든 뷰를 커스텀뷰 class로 변경!(identity inspector) // 값이 변경될 때마다 해당 값 출력하려면? (프로퍼티 옵저버 못씀) override var backgroundColor: UIColor? &#123; get &#123; super.backgroundColor &#125; set &#123; // 이거 super 생략하면, self인데 그렇게 되면 위에 background 컬러에 set 됨, 무한 재귀 // 배경색이 nil이면 black아니면 newValue super.backgroundColor = newValue ?? .black if newValue == .red &#123; super.backgroundColor = .blue &#125; print(\"새로 변경 될 배경색은 : \", self.backgroundColor!) &#125; &#125;&#125; 그런데 ViewController에서는 이렇게 red를 blue로 바꿔주는 기능, nil을 black으로 바꿔주는 기능이 구현되어있는 CustomView 객체를 사용하는데, NextViewController에서는 같은 CustomView를 사용하는데, 일부 기능만 바꿔서 쓰고, print 메소드는 그대로 사용하고 싶음 이럴 때 사용하는 것이 Delegate Delegate 특정 로직을 내가 아닌 다른 객체가 대신 구현하도록 위임하는 형태의 디자인 패턴 AppDelegate도 똑같은 거임. [오후]","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Struct, ARC","slug":"9","date":"2019-12-09T04:07:29.000Z","updated":"2020-02-12T07:44:33.211Z","comments":true,"path":"2019/12/9/","link":"","permalink":"http://yoursite.com/2019/12/9/","excerpt":"Struct구조체와 클래스 비교 공통점 값을 저장하기 위한 프로퍼티 기능을 제공하기 위한 메서드 초기 상태를 설정하기 위한 생성자 기본 구현에서 기능을 추가하기 위한 확장(Extension) 특정 값에 접근할 수 있는 첨자(Subscript) 특정한 기능을 수행하기 위한 프로토콜 채택 Upper Camel Case 사용","text":"Struct구조체와 클래스 비교 공통점 값을 저장하기 위한 프로퍼티 기능을 제공하기 위한 메서드 초기 상태를 설정하기 위한 생성자 기본 구현에서 기능을 추가하기 위한 확장(Extension) 특정 값에 접근할 수 있는 첨자(Subscript) 특정한 기능을 수행하기 위한 프로토콜 채택 Upper Camel Case 사용 [클래스만 제공하는 기능] 상속 -&gt; 구조체는 상속 안됨 소멸자 (Deinitializer) 구조체도 소멸이 되긴하지만 소멸자(Deinit() 메소드를 사용하면 에러가 남) 참조 카운트 (ARC와 관련 있을 듯) 값 타입 vs 참조 타입123456789101112131415class Dog &#123; var name = \"토리\"&#125;struct Cat &#123; var name = \"릴리\"&#125;let dog = Dog() // 0x1234 -&gt; Dog() // let dog는 Dog클래스를 가리키는 주소값이 고정된 것임let cat = Cat() // Cat() 요게 stack에 직접 들어감 그래서 밑에서 name = '릴리'를 '토리'로 바꾸는게 안되는 거임 상수는 변경할 수 없는 것 처럼dog.name = \"릴리\" // 토리 -&gt; 릴리로 변경 시도cat.name = \"토리\" // 릴리 -&gt; 토리로 변경 시도 (X)// 값은 스텍에 저장되고,// 참조타입은 힙 영역에 포인터가 저장됨 dog에는 Dog()의 주소 값이 Stack에 저장되어 있고, 실제 값은 Heap에 저장되어 있음 dog는 상수이지만, 어차피 주소 값이 저장 되어있어서 주소값만 변경할 수 없는거고 Heap에 저장 된 값은 변경 가능 상수 cat에는 Cat() 자체가 저장되어 있기 때문에, cat.name 변경 불가 ARC 다른 언어의 가비지 컬렉터는 정기적으로 동작하여 런타임 중에 더 이상 사용되지 않는 메모리를 반환하는 방식 레퍼런스 카운트가 0이면 메모리에서 해제되고, 아니면 해제 되지 않음 RC (Reference Counting)변수가 생성되는 순간 카운트 + 1 참조 되는 순간마다 + 1 릴리즈 되는 순간 - 1 0이 되는 순간 메모리에서 제거 됨 -&gt; 이 과정을 ARC는 자동으로 해주는 것임 Auto! 강한참조 : let dog = Dog() 도그클래스를 만드는 순간에 해당 인스턴스가 만들어 질때 도그라는 변수가 그 타입의 참조 카운트를 1 증가 Leak vs Dangling PointerAlloc, init (할당) release (해제) 할당과 해제는 균형이 많아야 함 할당이 많으면 메모리가 낭비되고, 해제가 많으면 허상이 발생함 근데 이것을 수동으로 직접 코드를 입력하여 관리를 해줘야 했음 (빡셈) 수동으로 하기에는 너무 어려워서 초보자들에게 허들이 높았고, 숙련자들에게도 쉽지 않았음 기능에 대한 코드외에 메모리 관리에 대한 코드까지 추가되어서 관리도 어려움 ARC위에 나열한 어려움 등 때문에 Auto Reference Counting이 발표 됨 (2011년) RC 자동 관리 방식 (wwdc 2011 발표) 컴파일러가 개발자를 대신하여 메모리 관리 코드를 적절한 위치에 자동으로 삽입 GC (Garbage Collector) 처럼 런타임이 아닌 컴파일 단에서 처리함 (Heap 스캔이 필요없음, 앱 일시 정지 현상 없음) 메모리 관리 이슈 줄고, 코딩자체에 집중! 클래스의 인스턴스에만 적용 (참조 타입) 활성화 된 참조 카운트가 하나라도 있을 경우 메모리에서 해제 되지 않음 강한 참조 (Strong) : 기본값 참조 될 때마다 카운트 1 증가 약한 참조, 미소유 참조 : 참조 카운트 증가 X ARC in Struct (초기화 했을 때) 스텍 영역에 직접 값이 들어감 1234567struct Point &#123; var x, y: Double&#125;let point1 = Point(x: 0, y: 0)let point2 = point1Point2.x = 5 이 때 참조 타입은 point1의 값도 같이 바뀐다. 왜? 실제 값은 힙에 저장되어있고, 스텍에 저장되어있는 포인터는 같은 위치를 가리키니깐. 그런데 구조체에서는 point2의 x값과 point1의 x 값은 서로 다르다. x 값이 스텍에 직접 저장되어 있기 때문이다. 클래스에서 x 값은 힙에 저장되어 있음 Strong Reference Cycle RC가 0이 되지 않게 만들어버리는 상황! (주의해야함) 객체에 접근 가능한 모든 연결을 끊었는데도 순환참조로 인해 메모리에 계속 쌓이는 상황, 오동작이나 오류를 발생시킬 수 있음 순환참조! (정리해줄것) Weak Reference순환참조에 빠지지 않도록 weak을 선언하면 RC가 올라가지 않으므로 하나가 해제되면 자연스레 0이되어서 순환참조에 빠지는 것을 예방할 수 있음 강사님 수업자료 애니메이션으로 순서 파악해야함.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Sigleton, User Defaluts","slug":"6","date":"2019-12-06T04:01:41.000Z","updated":"2019-12-06T05:36:10.566Z","comments":true,"path":"2019/12/6/","link":"","permalink":"http://yoursite.com/2019/12/6/","excerpt":"Sigleton 특정 클래스의 인스턴스에 접근할 때 항상 동일한 인스턴스만을 반환하도록 하는 설계 패턴 한 번 생성된 이후에는 프로그램이 종료될 때까지 항상 메모리에 상주 어플리케이션에서 유일하게 하나만 필요한 객체에 사용 UIApplication, AppDelegate 등","text":"Sigleton 특정 클래스의 인스턴스에 접근할 때 항상 동일한 인스턴스만을 반환하도록 하는 설계 패턴 한 번 생성된 이후에는 프로그램이 종료될 때까지 항상 메모리에 상주 어플리케이션에서 유일하게 하나만 필요한 객체에 사용 UIApplication, AppDelegate 등 자기 타입을 생성하여 상수에 받아놓고 static! 그리고 접근제어자 private로 외부에서 생성자를 호출하지 못하게 막아놓는거! 123456789101112131415161718class NormalClass &#123; var x = 0&#125;let someObject1 = NormalClass()someObject1.x = 5let someObject2 = NormalClass()someObject2.x = 1let someObject3 = NormalClass()someObject3.x = 10someObject1.x // 5someObject2.x // 1someObject3.x // 10// 각기 다른 객체임! 객체가 여러개야! static var, static let은 타입 프로퍼티이다! 123456789101112131415class SingletonClass &#123; // 자기 자신 클래스의 생성자를 타입 프로퍼티에 할당 static let shared = SingletonClass() // var x = 0&#125;// shared를 호출하면 생성자를 호출한 것과 같은 결과let singleton1 = SingletonClass.sharedsingleton1.x = 10let singleton2 = SingletonClass.sharedsingleton2.x = 20singleton1.x // 20singleton2.x // 20 위의 싱글턴 패턴은 1234567Class Normal &#123; let name = 0&#125;// 아래와 같은 의미!let nor1 = Normal()let nor2 = nor1 12345678910// 이 객체는 프로퍼티에 담지 않았기 때문에 생성되자마자 사라짐SingletonClass().x = 99// 얘는 그래서 새로 생긴거고, shared를 통해서 만들지 않았음SingletonClass().x //// 싱글턴 이기 때문에 위에서 저장한 30이 출력됨singleton1.x //singleton2.x // User Defaults iOS 에서 데이터를 파일에 저장하기 위해 사용하는 대표적인 클래스 중 하나 간단한 정보를 저장하고 불러올 때 사용하며 내부적으로 pList 파일로 저장 메모리에 저장하면 껐다키면 없어져있음! 휘발성임 비교적 느리다. (상대적으로)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"4","slug":"4","date":"2019-12-04T11:04:46.000Z","updated":"2019-12-05T07:20:39.153Z","comments":true,"path":"2019/12/4/","link":"","permalink":"http://yoursite.com/2019/12/4/","excerpt":"타입 캐스팅 (Type Casting)Super Class 로 부터 상속 된 Sub Class는 자기 자신의 타입이기도 하면서, 동시에 SuperClass의 타입이기도 하다.super의 특성을 물려받기 때문이다. 상속을 거듭해 갈 수록 sub는 보다 구체화 되어간다. 123456789101112131415161718192021// Super Class Class Vehicle &#123; var currentSpeed = 0.0 func accelerate() &#123; self.currentSpeed += 1 &#125;&#125;// Sub ClassClass Car: Vehicle &#123; var gear: Int &#123; return Int(self.currentSpeed / 20) + 1 &#125; func wiper() &#123; print(\"창을 닦는다\") &#125;&#125;let trans: Vehicle = Car()","text":"타입 캐스팅 (Type Casting)Super Class 로 부터 상속 된 Sub Class는 자기 자신의 타입이기도 하면서, 동시에 SuperClass의 타입이기도 하다.super의 특성을 물려받기 때문이다. 상속을 거듭해 갈 수록 sub는 보다 구체화 되어간다. 123456789101112131415161718192021// Super Class Class Vehicle &#123; var currentSpeed = 0.0 func accelerate() &#123; self.currentSpeed += 1 &#125;&#125;// Sub ClassClass Car: Vehicle &#123; var gear: Int &#123; return Int(self.currentSpeed / 20) + 1 &#125; func wiper() &#123; print(\"창을 닦는다\") &#125;&#125;let trans: Vehicle = Car() sub인 Car 클래스는 super의 속성을 전부 가지고 있으면서 추가로 gear 변수와 wiper 메소드를 가지고 있다.(보다 구체화) 이러한 이유로 SubClass는 SuperClass 타입이 될 수 있지만 SuperClass는 SubClass 타입이 될 수 없다 상속은 받았지만 기능이 더해지지 않은 sub 클래스여도 super는 sub 타입이 될 수 없다 Q. 상위 클래스 타입으로 선언하여 객체를 초기화 한다면, 사용할 수 있는 프로퍼티나 메소드의 범위가 줄어드는 것이나 마찬가지인데, 굳이 상위 타입으로 선언해서 사용하는 이유가 뭔가요? 그 반대이다 오히려 넓어진다. 예를 들어 Vehicle -&gt; Car -&gt; SUV 순으로 상속이 된다고 가정을 해보면, 1234567func move(param: SUV) &#123; param.accelerate()&#125;func move(param: Vehicle) &#123; param.accelerate()&#125; 위의 move에서는 SUV 클래스의 인스턴스만 인자값으로 받을 수 있지만, 아래의 move는 Vehicle 클래스나 이를 상속받은 모든 클래스를 다 사용할 수 있다. 내가 바보 3대를 노예로 부려먹으려 한다! 근데 아들만 제압하고 아버지, 할아버지를 제압하지 못하면 아들 밖에 못부려먹지만, 할아버지를 제압하면 할아버지, 아버지, 아들까지 다 부려 먹을 수 있음 (인성 ㅎㄷㄷ) 배열, 딕셔너리도 마찬가지 12345var list: [Vehicle]()list.append(Vehicle())list.append(Car())list.append(SUV()) 타입 비교 스위프트는 타입비교 연산자 is를 지원한다 is 왼쪽에는 인스턴스, 오른쪽에는 타입을 명시하여 타입을 비교한다. 12345SUV() is SUV // trueSUV() is Car // trueSUV() is Vehicle // trueCar() is SUV // false 인스턴스를 할당 받을 수 있는 타입이면 true, 아니면 false이다. SUV 객체는 SUV 타입, Car타입, Vehicle 타입이 될 수 있으므로 true, Car 객체는 SUV보다 상위 타입이기 때문에 false 12345678910111213// 그런데 타입이 하나로 명확하게 정해지지 않은 경우?// is를 이용하여 이런경우에는 이렇게, 저런경우에는 저렇게!let someAnyArr: [Any] = [1, 2.0, \"3\"]for data in someAnyArr &#123; if data is Int &#123; print(\"Int type data :\", data) &#125; else if data is Double &#123; print(\"Double type data : \", data) &#125; else &#123; print(\"String type data : \", data) &#125;&#125; 1234var human: Human = Student()type(of: human)// 해당 변수의 타입 human vs 실제 데이터의 타입 student// 컴파일 과정에서는 human 타입으로 인식하지만, 런타임 과정에서는(실제 앱을 실행할 때) student인 것 Type Check (타입 확인)제네릭 : 값이 들어오는 순간 결정 되는 거 123456789// Generic// 받는 인자의 타입에 따라 타입이 결정됨, 미리 타입을 선언하는 방식 아님func printGenericInfo&lt;T&gt;(_ value: T) &#123; let types = type(of: value) print(\"'\\(value)' of type '\\(types)'\")&#125;printGenericInfo(1)printGenericInfo(2.0)printGenericInfo(\"3\") Type Casting as : 타입 변환이 확실하게 가능한 경우(업캐스팅, 자기 자신 등) 에만 사용 가능. 그 외에는 컴파일 에러 as? : 강제 타입 변환 시도. 변환이 성공하면 Optional 값을 가지며, 실패 시에는 nil 반환 as! : 강제 타입 변환 시도. 성공 시 언래핑 된 값을 가지며, 실패 시 런타임 에러 발생 업 캐스팅 상속 관계에 있는 자식 클래스가 부모 클래스로 형변환하는 것 업캐스팅은 항상 성공하며 as 키워드를 사용 (자기 자신에 대한 타입 캐스팅도 항상 성공하므로 as 키워드 사용) 1234567891011121314151617181920212223242526272829class Shape &#123; var color = UIColor.black func draw() &#123; print(\"draw shape\") &#125;&#125;class Rectangle: Shape &#123; var cornerRadius = 0.0 override var color: UIColor &#123; get &#123; return .white &#125; set &#123; &#125; &#125; override func draw() &#123; print(\"draw rect\") &#125;&#125;let rect = Rectangle()rect.colorrect.cornerRadius//(rect as Shape).color//(rect as Shape).cornerRadius -&gt; Shape는 conerRadius 값을 가지고 있지 않아서 오류!//(rect as Rectangle).color -&gt; white//(rect as Rectangle).cornerRadius -&gt; 0.0 다운 캐스팅 형제 클래스나 다른 서브 클래스 등 수퍼 클래스에서 파생된 각종 서브 클래스로의 타입 변환 의미 반드시 성공한다는 보장이 없으므로 옵셔널. as? 또는 as! 를 사용 12345678910111213141516171819let shapeRect: Shape = Rectangle()var downcastedRect = Rectangle()//downcastedRect = shapeRect ////downcastedRect = shapeRect as Rectangle // 반드시 성공한다는 보장이 없음 그래서 에러! 부모 -&gt; 자식//downcastedRect: Rectangle = shapeRect as? Rectangle ////downcastedRect = shapeRect as! Rectangle ////as? : 강제 타입 변환 시도. 변환이 성공하면 Optional 값을 가지며, 실패 시에는 nil 반환//as! : 강제 타입 변환 시도. 성공 시 언래핑 된 값을 가지며, 실패 시 런타임 에러 발생//Q. 아래 value 에 대한 Casting 결과는?let value = 1//(value as Float) is Float // int와 float은 서로 관계 없는 타입//(value as? Float) is Float // nil is Float와 같은 결과임 false//(value as! Float) is Float // 런타임 오류 (value를 Float으로 강제로 변환을 했는데 is Float으로 체크 하는 순간 런타임 오류) 생성자 (Initializer) Swift 의 객체는 사용하기 전 모든 저장 프로퍼티에 대해 초기화 필수 다음 3 가지 중 하나를 택해 초기화 초기값 지정 옵셔널 타입 - nil 값으로 초기화 초기값이 없고, 옵셔널 타입이 아닌 프로퍼티에 대해서는 초기화 메서드에서 설정 Designated Initializer 클래스에 반드시 1개 이상 필요 초기화가 필요한 모든 프로퍼티를 단독으로 초기화 가능한 Initializer 위에서 사용한 init(), init(height: Int, xPosition: Int) 가 여기에 해당 초기화 과정에서 반드시 한 번은 호출 Q. 없는 경우도 있던데? init()이 있는건데 필요없으면 생략되어있는 거임 실제로는 있음 Convenience Initializer 단독으로 모두 초기화할 수 없고 일부만 처리한 뒤 다른 생성자에게 나머지 부분 위임 중복되는 초기화 코드를 줄이기 위해 사용 // 필기.. Failable Initializer인스턴스 생성시 특정 조건을 만족하지 않으면 객체를 생성하지 않는 것 생성이 되면 옵셔널 타입을 반환하게 되며, 생성 실패시에는 nil 반환 Super Class Initializing 서브 클래스는 자기 자신 이외에 수퍼 클래스의 저장 프로퍼티까지 초기화 해야함 서브 클래스는 수퍼 클래스의 지정 생성자(Designated Initializer) 호출 필요 (Convenience는 호출 불가) 수퍼 클래스의 지정 생성자가 기본 init 함수 하나만 있을 경우는 별도로 작성하지 않아도 자동으로 super.init() 메서드 호출 생성자가 여러 개인 경우, 어떤 초기화 메서드를 선택해야 할지 알 수 없으므로 선택해주지 않으면 오류, 이 때는 서브 클래스에서 수퍼 클래스의 생성자를 명시적으로 선택해주어야 함. 편의 생성자(Convenience Initializer)는 무관","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"타입캐스팅","slug":"타입캐스팅","permalink":"http://yoursite.com/tags/%ED%83%80%EC%9E%85%EC%BA%90%EC%8A%A4%ED%8C%85/"},{"name":"typeCasting","slug":"typeCasting","permalink":"http://yoursite.com/tags/typeCasting/"}]},{"title":"강아지, 새, 고양이","slug":"homework-1203","date":"2019-12-04T06:08:48.000Z","updated":"2019-12-16T12:19:23.471Z","comments":true,"path":"2019/12/homework-1203/","link":"","permalink":"http://yoursite.com/2019/12/homework-1203/","excerpt":"버튼 눌러서 뷰끼리 값 전달하기 (StoryBoard ver.) FirstVC 에 Dog, Cat, Bird 라는 이름의 Button을 3개 만들고 숫자를 표시하기 위한 Label 하나 생성 SecondVC 에 UIImageView 하나와 Dismiss 를 위한 버튼 하나 생성 FirstVC에 있는 버튼 3개 중 하나를 누르면 그 타이틀에 맞는 이미지를 SecondVC의 ImageView 에 넣기(이미지는 구글링 등을 통해 활용) 각 버튼별로 전환 횟수를 세서 개는 3회, 고양이는 5회, 새는 7회가 초과되면 화면이 전환되지 않도록 막기(전환 횟수가 초과된 버튼은 그것만 막고, 횟수가 초과되지 않은 버튼으로는 전환 가능) SecondVC에 추가로 UIButton 을 하나 생성하여 그 버튼을 누를 때 마다 개와 고양이, 새 모두에 대해 전환 횟수가 각각 1회씩 추가되도록 구현. 단, 각 버튼의 전환 횟수 제한에 도달하면 더 이상 추가 되지 않음","text":"버튼 눌러서 뷰끼리 값 전달하기 (StoryBoard ver.) FirstVC 에 Dog, Cat, Bird 라는 이름의 Button을 3개 만들고 숫자를 표시하기 위한 Label 하나 생성 SecondVC 에 UIImageView 하나와 Dismiss 를 위한 버튼 하나 생성 FirstVC에 있는 버튼 3개 중 하나를 누르면 그 타이틀에 맞는 이미지를 SecondVC의 ImageView 에 넣기(이미지는 구글링 등을 통해 활용) 각 버튼별로 전환 횟수를 세서 개는 3회, 고양이는 5회, 새는 7회가 초과되면 화면이 전환되지 않도록 막기(전환 횟수가 초과된 버튼은 그것만 막고, 횟수가 초과되지 않은 버튼으로는 전환 가능) SecondVC에 추가로 UIButton 을 하나 생성하여 그 버튼을 누를 때 마다 개와 고양이, 새 모두에 대해 전환 횟수가 각각 1회씩 추가되도록 구현. 단, 각 버튼의 전환 횟수 제한에 도달하면 더 이상 추가 되지 않음 FirstViewController 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import UIKitclass FirstViewController: UIViewController &#123; // 전환 횟수 레이블, 변수 @IBOutlet weak var lblCnt: UILabel! var dogCnt = 0 var catCnt = 0 var birdCnt = 0 override func viewDidLoad() &#123; super.viewDidLoad() &#125; // 레이블 표기 시점 (viewWillAppear) override func viewWillAppear(_ animated: Bool) &#123; lblCnt.text = String(\"🐶 : \\(dogCnt) | 🐱 : \\(catCnt) | 🐧 : \\(birdCnt)\") &#125; // 세그로 값 넘기기 override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; super.prepare(for: segue, sender: sender) guard let SecondVC = segue.destination as? SecondViewController else &#123;return&#125; if segue.identifier == \"dog\" &#123; SecondVC.text = \"강아지\" SecondVC.imageURL = \"dog.jpg\" dogCnt += 1 &#125; else if segue.identifier == \"cat\" &#123; SecondVC.text = \"고양이\" SecondVC.imageURL = \"cat.jpg\" catCnt += 1 &#125; else &#123; SecondVC.text = \"새\" SecondVC.imageURL = \"bird.jpg\" birdCnt += 1 &#125; &#125; // 화면 전환 횟수 제약 걸기 override func shouldPerformSegue(withIdentifier identifier: String, sender: Any?) -&gt; Bool &#123; if identifier == \"dog\" &amp;&amp; dogCnt &gt;= 3 &#123; return false &#125; else if identifier == \"cat\" &amp;&amp; catCnt &gt;= 5 &#123; return false &#125; else if identifier == \"bird\" &amp;&amp; birdCnt &gt;= 7 &#123; return false &#125; else &#123; return true &#125; &#125; @IBAction func unwindToFirtVC(_ unwindSegue: UIStoryboardSegue) &#123; &#125; &#125; SecondVIewController 123456789101112131415161718192021import UIKitclass SecondViewController: UIViewController &#123; @IBOutlet weak var lblAnimal: UILabel! @IBOutlet weak var image: UIImageView! var text = \"\" var imageURL = \"\" override func viewDidLoad() &#123; super.viewDidLoad() lblAnimal.text = text image.image = UIImage(named: imageURL) &#125; @IBAction func plusCnts(_ sender: UIButton) &#123; guard let vc = presentingViewController as? FirstViewController else &#123;return&#125; vc.dogCnt &lt; 3 ? vc.dogCnt += 1 : () vc.catCnt &lt; 5 ? vc.catCnt += 1 : () vc.birdCnt &lt; 7 ? vc.birdCnt += 1 : () &#125; StoryBoard","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"iOS,","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"StoryBoard","slug":"3","date":"2019-12-03T04:06:05.000Z","updated":"2019-12-04T06:52:57.460Z","comments":true,"path":"2019/12/3/","link":"","permalink":"http://yoursite.com/2019/12/3/","excerpt":"StoryBoard Segueway 뷰 컨트롤러 하나 더 생성, ctrl 누른채로 새로 만든 뷰 컨트롤러로 드래그! 세그웨이 오늘은 present Modally 선택 (세그웨이 선 선택하고 어트리뷰트 인스펙터)스토리보드 세그, kind 에서 액션을 변경할 수 있다 다시 돌아갈 땐? dismiss 버튼 선택하고 똑같이 ctrl로 이전 뷰 드래그?? 이러면 dismiss가 아니라 present 일단 ViewController를 First로 바꾸고, 새로 SecondViewController를 만들자!","text":"StoryBoard Segueway 뷰 컨트롤러 하나 더 생성, ctrl 누른채로 새로 만든 뷰 컨트롤러로 드래그! 세그웨이 오늘은 present Modally 선택 (세그웨이 선 선택하고 어트리뷰트 인스펙터)스토리보드 세그, kind 에서 액션을 변경할 수 있다 다시 돌아갈 땐? dismiss 버튼 선택하고 똑같이 ctrl로 이전 뷰 드래그?? 이러면 dismiss가 아니라 present 일단 ViewController를 First로 바꾸고, 새로 SecondViewController를 만들자! 연결까지 다 되었으면, FirstVC에 unwind 메소드! 1234@IBAction func unwindToFirstVC(_ unwindSegue: UIStoryboardSegue) &#123; let sourceViewController = unwindSegue.source // Use data from the view controller which initiated the unwind segue &#125; 스토리보드로 가서 dismiss 버튼 ctrl 누르고 위에 exit로 드래그! 하면 뭔가 말풍선이 생김! (unwind) 선택하면 끝 각자 실습 뷰컨트롤러 하나 더 만들고 A,B,C 왔다갔다 하는거 해보셈 First -&gt; Second (present) First -&gt; Third (present) Second -&gt; First (dismiss) Second -&gt; Third (present) Third -&gt; First (dismiss) Third -&gt; Second (Second에서 Third 로 넘어온 경우만 dismiss로 가능) 곧바로 First에서 Third로 넘어온 경우는 Second 못감 뷰끼리 데이터 전송하기 B로 넘어가는 세그웨이를 하나 더 만들고 fullscreen 말고 card 로 내비두자 (구분하기 위함) 각 세그웨이의 idetifier를 지정해줌 fullscreen, card 세그웨이 별로! B화면에 각 세그웨이별로 접근 했을 때 변경값을 전달해줄 레이블 생성하고 outlet 생성 card 세그로 오면 레이블이 card 로 변하고, fullscreen으로 오면 레이블이 FullScreen으로 변할것 헷갈리니 ThirdViewController 일단 지우자 Practice 각각 +1 버튼, +10 버튼을 만들고 버튼을 누르면 레이블에 해당 값 만큼 더해지 되, 40이 넘으면 다음 화면이 출력 되지 않게끔 해보자 Manual segway 일단 +5 버튼을 하나 만든다. 이번에는 버튼에서 다음 뷰로 드래그가 아니라, 뷰의 맨 위에 세 가지 버튼 중에서 첫 번째 버튼으로 드래그 하면 요렇게 manual segue 버튼이 생김 이담에 segue의 identifier를 설정해줌 (plusFive) segue 끝! 이번엔 버튼의 action을 설정해 주자 123@IBAction func didTapFiveBtn(_ sender: UIButton) &#123; performSegue(withIdentifier: \"plusFive\", sender: sender) &#125; 내부에 performSegue에서 identifier 설정을 해주면 버튼에 segue 할당 끝! 이제 +5 버튼을 누르면 이동한다!","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"Q&A","slug":"Q&A","date":"2019-12-02T11:47:33.951Z","updated":"2020-01-25T11:59:15.556Z","comments":true,"path":"2019/12/Q&A/","link":"","permalink":"http://yoursite.com/2019/12/Q&A/","excerpt":"기수강생 Q&amp;A 코딩 테스트 중요한가요? 수준 높은 기업을 생각한게 아니면, 크게 걱정 할 필요는 없지만. 수준 있는 기업을 가고 싶다면 준비해야 한다.알고리즘 연습 사이트에서 2단계 내지 3단계 풀 수 있으면 왠만한 코테는 걱정할 필요는 없을 것이다.대기업 위주로 있고, 스타트업은 면접 위주, 기본적인 것들 사전에 알려주고 만들어보라고 하는 경우도 있긴 함","text":"기수강생 Q&amp;A 코딩 테스트 중요한가요? 수준 높은 기업을 생각한게 아니면, 크게 걱정 할 필요는 없지만. 수준 있는 기업을 가고 싶다면 준비해야 한다.알고리즘 연습 사이트에서 2단계 내지 3단계 풀 수 있으면 왠만한 코테는 걱정할 필요는 없을 것이다.대기업 위주로 있고, 스타트업은 면접 위주, 기본적인 것들 사전에 알려주고 만들어보라고 하는 경우도 있긴 함 학원에서 배운 내용을 실무에서도 많이 쓰나요? 여기서 배운거 많이 쓴다 오늘도 계속 쓰고 왔다. 문법이 많이 중요하다 실무에 들어가서 어떤 일을 하시나요? 취직하자마자 바로 프로젝트 투입되어서, 처음부터 새로 만드는 중이다. 여기서 본 시험이 중요한가요? 시험 공부 많이 하는게 좋다. 시험을 보면서 복습을 하게 되고, 다 실무에서도 필요한 내용이다. 평소에 준비 열심히 하고 시험을 잘 보자 회사에 사수가 있으신가요? 옆에 남자친구가 내 사수다. 내가 먼저 회사 들어갔는데, 쓸만한 사람 아는 사람있냐해서 남자친구 소개해서 같이 정직원으로 일하고 있다. 남자친구가 수료 때도 잘했다. 지금은 내 사수다. Cs(Computer Science) 지식? 얼마나 쌓는게 좋은지? iOS 플랫폼에 대한 이해가 먼저다. swift가 먼저고, cs(Computer Science)는 필요하긴 하지만 swift 문법보다는 안중요한거 같다. 여기서 공부 잘 하고 있는지 셀프체크 할 수 있는 방법이 있다면 알려주세요 시험을 잘 보세요.. 결과가 말해줍니다. 혼자 프로젝트 계속 만들었었다 (남자친구 사수분) 알고리즘 공부 했었다. (약간 동문서답) 30대 중반인 경우 패널티가 있는 분위기? 실력만 있으면 채용하는 분위기 인가요? (c++이었나 아무튼 다른 언어 경력이 7년이라 신입도, 경력도 아닌 애매한 상황으로 면접을 보셨다함. 이분 나이 34세) 40곳 이력서 넣고, 20곳 면접보고, 7곳 붙었다. 나이 크게 중요하지 않다. (스타트업 창업 경험있다고 한 분) 개인적으로는 다른 직업을 하다가 온 사람의 스토리가 더 좋았다 실제로 그런 사람을 채용한 경험도 있다. 이력서 자소서 중요한가요? (자소서 쓰기 싫어서 물어보는듯..) 개발자로서 가장 중요한 거는 git hub과 포폴이 가장 중요한 것 같다. 자소서보단 포폴이 훨씬 중요한 거 같다 칸을 채우는 용도, 면접 시 대화 소스 정도? 포폴 예쁘게 꾸미자 깃헙을 어느 시점부터 관리가 되어야 할 까요? contribute는 항상 있어야함 매일 readme를 잘 만들어 주는게 좋지 포폴을 예쁘고 깔끔하게 잘 만드는게 좋다. 학원 신입들 어차피 포폴 다 똑같으니깐 이쁘고 눈에 띄는 포폴이 더 잘 뽑힌다. 라는 이야기가 개발자들 단톡방에서도 심심찮게 나온다 잔디를 심는 것에만 집중하지 말고 스스로 하는 공부에 초점을 맞춰라 회사 취직하고도 평일에 공부 하시나요? 평일엔 잘 못함, 아직은 일하는게 공부다. 알고리즘 중요한가요? 면접 본 20곳 중에 10곳은 손코딩 시켰는데, 어떤 문제는 풀지도 못했는데 합격했다.(어려웠음 재귀 함수 쓰는거였다함) 로켓 펀치에 포폴 올렸더니 제안이 많이 왔다. (이 분은 포폴을 엄청 잘만드셨다함. 다른 분들도 참고했다고.. ) 따로 구직 활동을 하진 않았고 바로 제안이 오길래 그 회사로 갔다 (한 달도 안되서 취직) 복지 좋고 만족한다. 원티드에 이력서 넣을 때, 경력 필요한 곳도 다 넣으셨나요? 네 다 넣었습니다. 만약 그런 곳에서 면접을 보게 되면 준비를 잘해야한다. 경력 3년차인 분들과 경쟁하려면 준비는 필수다 면접에서 커트당하는 경우는 많다. 일단 넣어라! 블로그, 포폴 진짜 중요하다 (취직할 때) 본인은 패캠 이력서특강 듣고 그대로 하고, 자소서도 넣고, 포폴도 넣었는데 다 떨어졌다. 그래서 (아까 그 포폴 예쁘게 잘 꾸미신분) 한테 검사받고 다시 올렸더니 연락이 많이 왔다. 문법을 진짜 열심히 잘 봐야된다. 문법이 엄청 중요함, 지금도 문법 몰라서 책을 끼고 산다. 문법을 모르면 애초에 손을 못댄다 문법 꼼꼼하게 공부해라 블로그 관리, 깃헙 관리 이런거 중요하니깐 강사님과도 자주 이야기해서 컨펌받거나 예쁘게 잘한 사람꺼 참고해라 본인은 치위생사였다. 안그래도 업쓰(이유업 매니저)한테 여기도 한 분 있다고 들었다. (거의 매일 10시 퇴근하고 집에 가서 또 새벽까지 공부하고 잘 정도로 열심히 했다함…) 발표하는 사람들 비전공자인 분들 다들 본인도 아무것도 모르고 왔다고, 여러분도 할 수 있다고 얘기하지만 (취직 잘하고, 창업준비하고 계심) 근데 얘기 들어보면 무조건 10시까지 남아서 다 하고, 주말에도 맨날 오고 3개월은 친구도 안만났다는 등 미친 듯이 했다고 함 계속 강조한 내용은 수업 잘 따라가고 시험준비 열심히, 복습, 예습, 깃헙, 블로그, 포폴 관리","categories":[],"tags":[]},{"title":"1차 Test Review","slug":"2","date":"2019-12-02T09:43:03.000Z","updated":"2019-12-24T03:09:13.219Z","comments":true,"path":"2019/12/2/","link":"","permalink":"http://yoursite.com/2019/12/2/","excerpt":"이론1. Array, Set, Dictionary의 차이점에 대해 설명하고, 예시 코드 작성 *array *: index를 기반으로, 값이 저장 된 순서가 있음. (0부터 시작), 중복 값 허용 됨, 하나의 타입 Set: 순서가 정렬되지 않음, 하나의 타입, 중복 비허용(고유 값) Dictionary: 키와 값의 쌍으로 이뤄져있음, key는 고유 값, value는 중복 허용, 순서 정렬되지 않음","text":"이론1. Array, Set, Dictionary의 차이점에 대해 설명하고, 예시 코드 작성 *array *: index를 기반으로, 값이 저장 된 순서가 있음. (0부터 시작), 중복 값 허용 됨, 하나의 타입 Set: 순서가 정렬되지 않음, 하나의 타입, 중복 비허용(고유 값) Dictionary: 키와 값의 쌍으로 이뤄져있음, key는 고유 값, value는 중복 허용, 순서 정렬되지 않음 2.Value Type, Reference Type의 차이점? value type Struct, enum, tuple에 사용 각 객체는 각자 고유한 사본을 가지고 있음 메모리의 stack 영역에 데이터 저장 123456Struct S&#123;var num = 10&#125;var a = S()var b = aa.num = 20 print(\"\\(a.num), \\(b.num)\") // 20, 10 -&gt; 각자 고유한 사본을 가지고 있어서 값이 똑같이 공유되지 않음 Reference type class 객체들이 하나의 사본을 공유함 메모리의 stack 영역에는 pointer가 저장되고, heap 영역에 실제 데이터 저장 123456Class C&#123;var num = 10&#125;var a = C()var b = aa.num = 20 print(\"\\(a.num), \\(b.num)\") // 20, 20 -&gt; 하나의 사본을 객체끼리 공유하기 때문에 값이 똑같음 3. Application의 Life Cycle의 각 상태에 대해 설명하라 Not running : 아직 실행하지 않은 상태, 시스템 혹은 유저에 의해 앱이 종료 된 상태 Inactive : 포그라운드에서 앱이 실행중이지만 앱 상태 전환 등의 이유로 이벤트를 일시적으로 받지 못하는 상태, Active 상태로 전환되기 전 잠시 거치는 단계 Active : 포그라운드에서 앱이 실행 중이며 이벤트를 정상적으로 수신받을 수 있는 상태 Background : 백그라운드에서 앱이 실행 중인 상태 또는 Suspended 상태로 넘어가기 직전 잠시 머무는 단 Suspended : 앱이 백그라운드에 있으며 메모리에는 남아있지만 어떤 코드도 수행하지 않고 있는 상태, 메모리가 부족해지면 시스템에 의해 강제 종료될 수 있음 4. View Life Cycle의 각 상태에 대해 설명 viewDidLoad - view에 대한 로드가 완료된 시점(메모리상에 저장됨)에 호출 viewWillAppear - view를 화면에 나타내기 직전 호출 viewDidAppear - view를 화면에 나타낸 직후 호출 viewWillDisappear - view가 화면에서 사라지기 직전 호출 viewDidDisappear - view가 화면에서 사라진 직후 호출 5. 다음 4개의 키워드가 쓰이는 위치, 역할 설명 continue 반복문 내에서 사용 현재 수행하던 작업을 중단하고 반복문의 다음 반복자를 수행 break 반복문 또는 switch문 내에서 사용 현재 반복문 또는 switch문에서 수행하던 작업을 중단하고 즉시 해당 제어문에서 빠져나옴 return 함수 내에서 사용 해당 함수의 작업을 즉각 중단하며 동시에 그 함수의 return type에 맞는 값을 반환 함수가 실행되었을 때 기대되는 어떤 결과값(Output)을 함수를 호출한 곳으로 반환해주는 역할 fallthrough switch문 내에서 사용 switch문 내에서 첫 번째로 매칭된 케이스가 수행된 후 바로 종료하는 대신 그 다음의 케이스까지 수행하게 하는 역할 6. Init 메서드가 필요한 경우와 그렇지 않은 경우 차이?모든 저장 프로퍼티에 초기화가 되어 있으면 필요없지만, 하나라도 초기화가 되어있지 않으면 필요함 7. Access Level 을 각 단계별로 나열하고 그 차이점에 대해 설명 open : 외부 모듈에서도 접근 가능하며, 오버라이드 가능 Public : 외부 모듈에서도 접근 가능하되, 오버라이드 불가 Internal : 해당 모듈 내에서만 접근 가능하도록 제안 filePrivate : 해당 파일 내에서만 접근 가능하도록 제한 private : 해당 스코프 내에서만 접근 가능하도록 제한 8. OOP 4대 특성? 추상화 캡슐화 상속성 다형성 9. Frame과 Bounds가 무엇이고, 둘의 차이점? Frame superview의 좌표계를 기반으로 해당 view에 대한 위치(좌표)와 사이즈를 나타내는 사각형 원점(0, 0)은 부모뷰(superview)의 시작 지점이며, 원점을 변경하면 자신의 위치가 이동하고 이에 따라 자신의 하위 뷰도 함께 움직임 Bounds 자기 자신의 좌표계를 기반으로 그 뷰의 위치와 사이즈를 표현하는 사각형 원점(0, 0)은 자체 뷰의 시작 지점이며, 원점을 변경하면 자신의 하위 뷰에만 영향을 줌","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"Codding","slug":"Codding","permalink":"http://yoursite.com/tags/Codding/"}]},{"title":"Calculator","slug":"27","date":"2019-11-27T08:04:35.000Z","updated":"2019-11-27T09:03:31.507Z","comments":true,"path":"2019/11/27/","link":"","permalink":"http://yoursite.com/2019/11/27/","excerpt":"MVCModel : BrainOfCalculatorView: Main.storyboardController: ViewControllerViewController1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import UIKitclass ViewController: UIViewController &#123; @IBOutlet private weak var display: UILabel! // private var UserIsInTheMiddleOfTyping = false // 숫자버튼에 연결되어 있는 액션 @IBAction private func touchDigit(_ sender: UIButton) &#123; // 버튼의 title을 입력 값으로 설정 let digit = sender.currentTitle! // 유저가 타이핑 중이 아니면 display(레이블)에 digit이 덧붙여지고, 타이핑 중이면 display는 대체 됨 if UserIsInTheMiddleOfTyping &#123; let textCurrentlyInDisplay = display.text display.text = textCurrentlyInDisplay! + digit &#125; else &#123; display.text = digit &#125; UserIsInTheMiddleOfTyping = true &#125; // 데이터 입력 시에는 문자, 리턴할 때는 double (계산을 해야 하니깐) // 매번 타입을 변환하지 않도록 해줌. 가져갈때는 double로, 입력할 때는 String으로! private var displayValue: Double &#123; get &#123; return Double(display.text!)! &#125; set &#123; display.text = String(newValue) &#125; &#125; // brain에서 참고! var savedProgram: BrainOfCalculator.PropertyList? @IBAction func save() &#123; savedProgram = brain.program &#125; @IBAction func restore() &#123; if savedProgram != nil &#123; brain.program = savedProgram! displayValue = brain.result &#125; &#125; // 계산 수행, Model 호출 var brain = BrainOfCalculator() // 연산자 버튼을 누르면 계산 작업 수행 @IBAction private func performOperation(_ sender: UIButton) &#123; // 피연산자 입력받기t if UserIsInTheMiddleOfTyping &#123; brain.setOperand(operand: displayValue) UserIsInTheMiddleOfTyping = false &#125; // 연산자 입력받기 if let mathemeticalSymbol = sender.currentTitle &#123; brain.performOperation(symbol: mathemeticalSymbol) &#125; displayValue = brain.result &#125; &#125;","text":"MVCModel : BrainOfCalculatorView: Main.storyboardController: ViewControllerViewController1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import UIKitclass ViewController: UIViewController &#123; @IBOutlet private weak var display: UILabel! // private var UserIsInTheMiddleOfTyping = false // 숫자버튼에 연결되어 있는 액션 @IBAction private func touchDigit(_ sender: UIButton) &#123; // 버튼의 title을 입력 값으로 설정 let digit = sender.currentTitle! // 유저가 타이핑 중이 아니면 display(레이블)에 digit이 덧붙여지고, 타이핑 중이면 display는 대체 됨 if UserIsInTheMiddleOfTyping &#123; let textCurrentlyInDisplay = display.text display.text = textCurrentlyInDisplay! + digit &#125; else &#123; display.text = digit &#125; UserIsInTheMiddleOfTyping = true &#125; // 데이터 입력 시에는 문자, 리턴할 때는 double (계산을 해야 하니깐) // 매번 타입을 변환하지 않도록 해줌. 가져갈때는 double로, 입력할 때는 String으로! private var displayValue: Double &#123; get &#123; return Double(display.text!)! &#125; set &#123; display.text = String(newValue) &#125; &#125; // brain에서 참고! var savedProgram: BrainOfCalculator.PropertyList? @IBAction func save() &#123; savedProgram = brain.program &#125; @IBAction func restore() &#123; if savedProgram != nil &#123; brain.program = savedProgram! displayValue = brain.result &#125; &#125; // 계산 수행, Model 호출 var brain = BrainOfCalculator() // 연산자 버튼을 누르면 계산 작업 수행 @IBAction private func performOperation(_ sender: UIButton) &#123; // 피연산자 입력받기t if UserIsInTheMiddleOfTyping &#123; brain.setOperand(operand: displayValue) UserIsInTheMiddleOfTyping = false &#125; // 연산자 입력받기 if let mathemeticalSymbol = sender.currentTitle &#123; brain.performOperation(symbol: mathemeticalSymbol) &#125; displayValue = brain.result &#125; &#125; BrainOfCalculator123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//// ViewController.swift// Hangling_Caculator//// Created by MyMac on 2019/11/26.// Copyright © 2019 sandMan. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet private weak var display: UILabel! private var UserIsInTheMiddleOfTyping = false @IBAction private func touchDigit(_ sender: UIButton) &#123; // 버튼에서 title 보내기 let digit = sender.currentTitle! // 유저가 타이핑 중이 아니면 display(레이블)에 digit이 덧붙여지고, 타이핑 중이면 display는 대체 됨 if UserIsInTheMiddleOfTyping &#123; let textCurrentlyInDisplay = display.text display.text = textCurrentlyInDisplay! + digit &#125; else &#123; display.text = digit &#125; UserIsInTheMiddleOfTyping = true &#125; // 데이터 입력 시에는 문자, 리턴할 때는 double (계산을 해야 하니깐) // 매번 타입을 변환하지 않도록 해줌. 가져갈때는 double로, 입력할 때는 String으로! private var displayValue: Double &#123; get &#123; return Double(display.text!)! &#125; set &#123; display.text = String(newValue) &#125; &#125; var savedProgram: BrainOfCalculator.PropertyList? @IBAction func save() &#123; savedProgram = brain.program &#125; @IBAction func restore() &#123; if savedProgram != nil &#123; brain.program = savedProgram! displayValue = brain.result &#125; &#125; // 계산 수행, Model 호출 var brain = BrainOfCalculator() @IBAction private func performOperation(_ sender: UIButton) &#123; // 피연산자 입력받기 if UserIsInTheMiddleOfTyping &#123; brain.setOperand(operand: displayValue) UserIsInTheMiddleOfTyping = false &#125; // 연산자 입력받기 if let mathemeticalSymbol = sender.currentTitle &#123; brain.performOperation(symbol: mathemeticalSymbol) &#125; displayValue = brain.result &#125; &#125; Main.storyboard","categories":[{"name":"따라해봄","slug":"따라해봄","permalink":"http://yoursite.com/categories/%EB%94%B0%EB%9D%BC%ED%95%B4%EB%B4%84/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"},{"name":"한글링","slug":"한글링","permalink":"http://yoursite.com/tags/%ED%95%9C%EA%B8%80%EB%A7%81/"},{"name":"Stanford_iOS","slug":"Stanford-iOS","permalink":"http://yoursite.com/tags/Stanford-iOS/"}]},{"title":"UI Text Field Example & Alert Controller","slug":"26","date":"2019-11-26T03:40:57.000Z","updated":"2019-11-26T10:20:21.026Z","comments":true,"path":"2019/11/26/","link":"","permalink":"http://yoursite.com/2019/11/26/","excerpt":"UI Text Field Example &amp; Alert Controller 스토리보드에서 text필드 추가 가상키보드는 상단의 hardware -&gt; keyboard attribute insfector에서 폰트, 텍스트 스타일 등등 바꿀 수 있음~ environment Overrides 에서 폰트크기나 다크모드 등을 실시간으로 확인 가능 단, 폰트가 시스템 폰트이면 안됨 Boarder Style을 조정가능 Clear button : 텍스트필드 오른쪽에 텍스트 한번에 지우는 x 버튼 생길지 여부 min font size : 텍스트 필드에 텍스트가 많아져서 길어질 때 크기가 줄어듦, 이 때 어느정도까지 작아지는지 한도 정하는거","text":"UI Text Field Example &amp; Alert Controller 스토리보드에서 text필드 추가 가상키보드는 상단의 hardware -&gt; keyboard attribute insfector에서 폰트, 텍스트 스타일 등등 바꿀 수 있음~ environment Overrides 에서 폰트크기나 다크모드 등을 실시간으로 확인 가능 단, 폰트가 시스템 폰트이면 안됨 Boarder Style을 조정가능 Clear button : 텍스트필드 오른쪽에 텍스트 한번에 지우는 x 버튼 생길지 여부 min font size : 텍스트 필드에 텍스트가 많아져서 길어질 때 크기가 줄어듦, 이 때 어느정도까지 작아지는지 한도 정하는거 Text Field TextField 객체 생성 1let textField = UITextField() TextField 및 keyBoard 속성 정의 12345678910// 텍스트필드 및 키보드 속성 정의func setTextField() &#123; textField.frame.size = CGSize(width: 200, height: 50) textField.center = view.center textField.borderStyle = .roundedRect textField.placeholder = \"put in text\" textField.keyboardType = .default textField.keyboardAppearance = .default self.view.addSubview(textField) &#125; viewDidLoad에서 실행 12345// 텍스트 필드 객체 로드override func viewDidLoad() &#123; super.viewDidLoad() setTextField() &#125; 결과 Text Field Interface Builder 속성 text color font alignment PlaceHolder Background Disabled Border Style Clear button min font size 키보드 관련 속성도 있으니 개발문서 참고 Text Field 이벤트 DidEndOnExit : 입력을 끝내고 return 키 누르면 호출 Editing Changed : 입력 하는 중에 계속 호출 EditingDidBegin : 텍스트필드를 선택하는 순간 호출 EditingDidEnd: 텍스트필드 포커싱이 끝나면 호출 primaryAction : return 키를 누르면 호출 Q. 텍스트 필드가 두 개이고, 하나는 이벤트 연결 안했을 때? 텍스트 필드 선택 -&gt; DidBegin 텍스트 필드 수정 (Editing) -&gt; editing changed return 키 안누르고 다른 텍스트 필드로 이동 : DidEnd return 키 누르고 editing 종료: DidEnd, PrimaryActionTrigger, endOnExit Q. TextField가 여러 개인데, 하나의 IBAction에 연결 할 수 있나요? 가능 그런데 각 TF를 구분해주어야 한다. 이 때 구분하는 방법은 IBOutlet을 만들어주거나, 각 객체에 tag를 지정 if 문을 사용해서 해당 액션을 수행할 TF객체만 액션을 수행하도록 지정 Tag는 (Attribute Insfector의 View칸에서 지정 가능 Q. sender 파라미터는 뭐하는 녀석인가요? 내가 지금 ‘이벤트를 발생시킨 객체’를 가리킨다. 버튼을 눌렀으면 sender는 내가 누른 버튼 Font 지정 하기12345678// 텍스트필드 폰트idTextField.font = UIFont.systemFont(ofSize: 20) idTextField.font = UIFont.systemFont(ofSize: 20, weight: .heavy)idTextField.font = UIFont.boldSystemFont(ofSize: 30)idTextField.textAlignment = .center// 레이블 폰트lblText.font = lblText.font.withSize(20) Alert Controller 뷰가 아니기 때문에 Present 메소드로 띄운다. controller임 addSubview는 view를 띄우는 메소드 alert 객체 생성 과정 AlertController 객체 생성 1234let alert = UIAlertController( title: \"title\", // 타이틀 지정 message: \"insert massage\", // 메세지 지정 preferredStyle: .alert) // alert or actionSheet 둘 중 하나 선택 alert의 버튼 객체 생성 123456let ok = UIAlertAction( title: \"OK\", // 버튼 위 텍스트 style: .default) &#123; // 버튼 스타일 default, cancle, destructive 셋 중 하나 선택 (action) in // 해당 버튼을 누르면 수행할 액션 정의 print(\"OK버튼\")&#125; cancle &amp; destructive 스타일 버튼 생성 12345678910111213let cancle = UIAlertAction( title: \"Cancle\", style: .cancel) &#123; (action) in print(\"Cancle 버튼\")&#125; let destructive = UIAlertAction( title: \"Delete\", style: .destructive) &#123; (action) in print(\"destructive 버튼\")&#125; 생성한 alert 버튼 객체 alert에 추가 123alert.addAction(ok)alert.addAction(cancle)alert.addAction(destructive) 버튼 객체까지 추가 완료한 후, alert 객체 띄우기 1present(alert, animated: true) 결과 왼쪽이 actionSheet / 오른쪽이 alert Alert 객체는 스토리보드에서 추가할 수 없음 cancle 액션은 추가 된 순서에 관계 없이 별도의 위치에 생긴다. 두개 일 땐 왼쪽, 세 개 이상일 땐 아래쪽 alert 말고, actionSheet에서도 마찬가지로 별도로 구분이 된다. destructive 액션을 하면 빨간색으로 표기가 됨 자동으로! 경고성의 느낌 뭔가 파괴적인 액션일때 경고를 주기 위함 destructive는 alert에서는 candle 처럼 별도의 위치에 추가 되지는 않음 TIP! Cmd + ctrl + E : 변수 한 개 이름 바꿀 때 일일이 안바꾸고 한번에 바꿀 수 있음","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS, Swift, Xcode","slug":"iOS-Swift-Xcode","permalink":"http://yoursite.com/tags/iOS-Swift-Xcode/"}]},{"title":"Markdown Grammar Summary","slug":"markdown","date":"2019-11-26T01:24:57.000Z","updated":"2019-11-26T01:27:11.388Z","comments":true,"path":"2019/11/markdown/","link":"","permalink":"http://yoursite.com/2019/11/markdown/","excerpt":"FastCampus Prelearning 깃헙, Stack Overflow 같은 곳에서 사용한다. 마크다운 파일의 확장자는 .md 혹은 .markdown 이다. 1. 헤더123456# h1## h2### h3#### h4##### h5###### h6h1h2h3h4h5h6","text":"FastCampus Prelearning 깃헙, Stack Overflow 같은 곳에서 사용한다. 마크다운 파일의 확장자는 .md 혹은 .markdown 이다. 1. 헤더123456# h1## h2### h3#### h4##### h5###### h6h1h2h3h4h5h6 2. 인용문123&gt; first blockquote&gt;&gt; second blockquote&gt;&gt;&gt; third blockquote first blockquote. second blockquote. third blockquote. 3. 목록3.1 순서가 있는 목록1231. 1st2. 2nd3. 3rd 1st 2nd 3rd 3.2 순서가 없는 목록1234567891011* 빨강* 파랑* 노랑+ 빨강+ 파랑+ 노랑- 빨강- 파랑- 노랑 빨강 파랑 노랑 123* 1단계+ 2단계- 3단계 1단계 2단계 3단계 4. 코드12this is a normal paragragh​```this is a code block 1234this is a normal paragragh```this is a code block 5. 수평선123*** =&gt; &apos;*&apos; 기호 세개--- =&gt; &apos;-&apos; 기호 세개___ =&gt; &apos;_&apos; 기호 세개 6. 링크1[구글로 이동하기](https://www.google.com) 구글로 이동하기 7. 강조123456789*italic*_italic_**bold**__bold__~~cancleline~~ italic italic bold bold cancleline 8. 이미지123![markdown](https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Markdown-mark.svg/220px-Markdown-mark.svg.png)![텍스트](이미지 경로) 9. 테이블12345|header 1|header 2|header 3||:---:|:---:|:---:||cell 1|cell 2|cell 3||cell 4|cell 5|cell 6||cell 7|cell 8|cell 9| header 1 header 2 header 3 cell 1 cell 2 cell 3 cell 4 cell 5 cell 6 cell 7 cell 8 cell 9","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"study, gitHub, markdown,","slug":"study-gitHub-markdown","permalink":"http://yoursite.com/tags/study-gitHub-markdown/"}]},{"title":"Git Study","slug":"gitStudy","date":"2019-11-25T12:25:28.000Z","updated":"2019-11-25T12:27:16.421Z","comments":true,"path":"2019/11/gitStudy/","link":"","permalink":"http://yoursite.com/2019/11/gitStudy/","excerpt":"PM : 먼저 repo를 만들어야 함 git-hub 웹사이트 1) repositary 생성 : Repositary name : , read-me 체크, Add.gitignore: swift, Add a license: MIT License -&gt; create2) Clone with HTTPS 복사하기","text":"PM : 먼저 repo를 만들어야 함 git-hub 웹사이트 1) repositary 생성 : Repositary name : , read-me 체크, Add.gitignore: swift, Add a license: MIT License -&gt; create2) Clone with HTTPS 복사하기 터미널에서 1) $ cd Documents/dev // 작업할 곳으로 이동 2) $ git clone [htts://github.com/PM-github-ID/repo-name.git] 3) $ ls // repositary가 복사되었는 지 확인하기 4) $ cd repo-name/ // 해당 폴더로 이동 5) $ ls // LICENSE, README.md 파일이 생성되었나 확인 6) $ git flow init 7) $ git branch // * master 선택되어 있음 8) $ git branch develop // ‘develop’ branch 생성 9) $ git branch // develop, *master 10) $ git checkout develop // ‘develop’ branch 선택 11) $ touch [파일명] // 파일 생성 12) $ vi [파일명] // 파일 편집 후 저장 13) $ git status // 현재 상태 확인해보기 14) $ git add [파일명] 15) $ git commit -m “[메세지 입력]” 16) $ git push -u origin develop ​ : github의 username, password 입력 github 웹사이트 1) repositary로 가서 Branch: master -&gt; Branch: develop으로 변경 \\2. 팀원(개발자) github 웹사이트 1) PM의 repositary로 가서 새로운 issue 생성 2) 우측 상단에 위치한 Fork 클릭 3) 내 소유가 된 repositary 에서 Clone with HTTPS 복사하기 터미널 1) $ cd Documents/dev // 작업할 폴더으로 이동 2) $ git clone [htts://github.com/developer(my)/repo-name.git] 3) $ ls // repositary가 복사되었는 지 확인하기 4) $ cd practice-github/ // 해당 폴더로 이동 5) $ ls // LICENSE, README.md 파일이 생성되었나 확인 6) $ git branch // * master 선택 확인 7) $ git branch develop 8) $ git checkout develop 9) $ git branch // * develop, master 확인 10) $ git flow init 11) $ git pull origin develop 12) $ cat [파일] // PM의 파일이 복사되어 온 것을 확인 13) $ git flow feature start {date-username} 14) $ vi [파일명] // 파일 수정 15) $ git status 16) $ git add [파일명] 17) $ git commit -m “[메세지 입력]” 18) $ git flow feature finish {date-username} 19) $ git push -u origin develop github 웹페이지 1) pull request 클릭 2) base repository: 팀장 develop &lt;- head repository: 팀원 develop 3) 제목, 내용 쓰고 create pull request 클릭 \\3. PM github 웹페이지 1) pull request와 issues에 새로운 글이 올라와있는 것 확인 2) pull request - conversation 에서 의견 작성 : 거부시 해당 의견 작성 후 comment 클릭 \\4. 팀원(개발자) 터미널 $ git branch feature/fb-again // 새로운 branch 생성 $ vi {파일명} // 수정진행 $ git status cat {파일명} $ git add [파일명] $ git commit -m “[메세지 입력]” $ git push -u origin feature/fb-again $ git checkout develop // ‘develop’ branch 생성 $ git merge feature/fb-again // branch 합치기 10) $ git push origin develop 11) $ git branch -D feature/fb-again github 웹사이트 pull request - commits에서 수정된 사항 확인 Conversation에 수정 완료 메세지 작성 후 Comment 클릭 \\5. PM github 웹사이트 pull request - Conversation 에서 merge pull request 클릭 후 merge confirm 클릭 issues에서 해당 내용 확인 후 Close issue 클릭 * 만약 PM의 repositary가 최근에 업데이트되어 팀원이 PM의 repo를 다시 pull할 필요가 있는 경우, PM : 파일 수정 터미널 $ cat {파일명} // 현재 파일 내용 확인 $ git checkout develop $ git pull origin develop $ cat {파일명} // 업데이트 된 파일 내용 확인 $ vi {파일명} // 수정 진행 $ git status $ git add {} $ git commit -m “” git push origin develop GitHub 웹사이트 Code - Branch: Develop 으로 변경 // 방금 수정or추가 파일 확인 \\2. 팀원(개발자) GitHub 웹사이트 PM의 repository 주소 복사하기 https://github.com/PM-github-ID/repo-name.git 터미널 1)$ git remote add pmorigin https://github.com/PM-github-ID/repo-name.git $ git remote // origin, pmorigin(생성) 확인 $ git remote get-url origin ​ // https://github.com/developer(my)/repo-name.git $ git remote get-url pmorigin ​ // https://github.com/PM-github-ID/repo-name.git $ git pull pmorigin develop $ vi {파일명} // 팀장이 수정한 파일이 복사되어진 것을 확인 작업 진행","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"git, github","slug":"git-github","permalink":"http://yoursite.com/tags/git-github/"}]},{"title":"ViewController Life Cycle","slug":"25","date":"2019-11-25T04:08:41.000Z","updated":"2019-11-25T08:00:12.346Z","comments":true,"path":"2019/11/25/","link":"","permalink":"http://yoursite.com/2019/11/25/","excerpt":"ViewControllerExample 프로젝트 생성 iOS 12 시뮬레이터 다운로드 오늘은 스토리보드 사용 안할 거임 아래의 코드를 씬델리데이트에 적어줘야한다. (iOS 13) 123456guard let windowScene = (scene as? UIWindowScene) else &#123; return &#125; window = UIWindow(windowScene: windowScene) window?.backgroundColor = .systemBackground window?.rootViewController = ViewController() window?.makeKeyAndVisible()","text":"ViewControllerExample 프로젝트 생성 iOS 12 시뮬레이터 다운로드 오늘은 스토리보드 사용 안할 거임 아래의 코드를 씬델리데이트에 적어줘야한다. (iOS 13) 123456guard let windowScene = (scene as? UIWindowScene) else &#123; return &#125; window = UIWindow(windowScene: windowScene) window?.backgroundColor = .systemBackground window?.rootViewController = ViewController() window?.makeKeyAndVisible() iOS 12를 타겟으로 할 때는 씬델리게이트를 지우던지 아래의 코드를 적어준다. 12// 아래 코드들은 iOS 13에서부터 사용한다! 라고 적어줌. 씬델리게이트를 지우지 않을 때 이 코드를 적는다.@available(iOS 13, *) 그리고 12 때는 앱델리게이트만 있었는데 지금은 아래 코드가 씬델리데이트에 나옴, 이걸 앱델리게이트에 적어줘야됨 12345678910111213141516171819import UIKit@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate &#123; // 이 부분 추가 var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; // 이 부분 추가 window = UIWindow(frame: UIScreen.main.bounds) window?.backgroundColor = .white window?.rootViewController = ViewController() window?.makeKeyAndVisible() return true &#125;&#125; 12는 앱델리게이트, 13부터는 씬델리게이트 이렇게 하면 12에선 문제가 안됨. 그런데 13에서 문제가 생김 12든 13이든 앱델리게이트가 먼저 실행이 되는데, 13에서는 앱델리게이트를 실행한 후 씬델리게이트로 넘어가서 비슷한 코드가 또 실행됨 그래서 다음과 같이 if 문으로 처리해 준다. 12345678910111213141516171819202122import UIKit@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate &#123; var window: UIWindow? func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool &#123; if #available(iOS 13.0, *) &#123; &#125; else &#123; window = UIWindow(frame: UIScreen.main.bounds) window?.backgroundColor = .white window?.rootViewController = ViewController() window?.makeKeyAndVisible() &#125; return true &#125;&#125; 다음은 뷰 컨트롤러로 넘어가서 뷰 컨트롤러의 생명주기를 콘솔에 찍어보자! 1234567891011121314151617181920212223242526import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() print(\"viewDidLoad\") &#125; override func viewWillAppear(_ animated: Bool) &#123; print(\"viewWillAppear\") &#125; override func viewDidAppear(_ animated: Bool) &#123; print(\"viewDidAppear\") &#125; override func viewWillDisappear(_ animated: Bool) &#123; print(\"viewWillDisAppear\") &#125; override func viewDidDisappear(_ animated: Bool) &#123; print(\"viewDidDisAppear\") &#125;&#125; ios 13과 12가 다른 점이 버튼으로 다음 페이지를 넘어갈 때, 13은 다음 창이 밑에서 올라오는데 꽉 안차고 전 화면이 아래에 깔려있는것이 눈에 보임 (card style modal presentation) 그리고 13은 새로운 화면을 밑으로 내려 버리는 액션으로 전 화면으로 돌아갈 수 있음 12 때는 그게 안됐었다! 풀스크린으로 설정하면 12처럼 꽉 차는 화면으로 되긴 함 12까지는 이게 기본이었던 거임 13부터는 선택사항 Full Screen Presentation Style nextVC 생성 VC 복붙! 버튼 생성 nextVC에도 버튼 뒤로가는 버튼 생성 뒤로가기 두가지 방법 뷰컨트롤러 다시 띄우는 방법 Dismiss 로 뒤로 돌리는 방법 라이프사이클 확인! 켜는 순간 viewDidLoad viewWillAppear viewDidAppear 이 상태에서 버튼 눌러서 nVC 호출! next viewDidLoad viewWillDisAppear next viewWillAppear next viewDidAppear viewDidDisAppear 다시 VC로 복귀 next viewWillDisAppear viewWillAppear viewDidAppear next viewDidDisAppear deinit ViewController 코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import UIKitclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() print(\"viewDidLoad\") setUI() &#125; func setUI() &#123; if #available(iOS 13.0, *) &#123; view.backgroundColor = .systemBackground &#125; else &#123; view.backgroundColor = .white &#125; let button = UIButton(type: .system) button.frame = CGRect(x: 50, y: 100, width: 100, height: 50) button.center = view.center button.setTitle(\"Btn\", for: .normal) button.addTarget(self, action: #selector(didTapButton(_:)), for: .touchUpInside) view.addSubview(button) &#125; @objc private func didTapButton(_ sender: UIButton) &#123; // let nextVC = nextViewController() // 기본은 모달임, 풀스크린으로 변경! nextVC.modalPresentationStyle = .fullScreen present(nextVC, animated: true) &#125; override func viewWillAppear(_ animated: Bool) &#123; print(\"viewWillAppear\") &#125; override func viewDidAppear(_ animated: Bool) &#123; print(\"viewDidAppear\") &#125; override func viewWillDisappear(_ animated: Bool) &#123; print(\"viewWillDisAppear\") &#125; override func viewDidDisappear(_ animated: Bool) &#123; print(\"viewDidDisAppear\") &#125;&#125; NextViewController 코드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import UIKitclass nextViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() print(\"next viewDidLoad\") setUpBtn() &#125; func setUpBtn() &#123; // 버튼 객체 생성 let button = UIButton(type: .system) // 사이즈 정의 button.frame.size = CGSize(width: 100, height: 50) // 위치 정의 button.center = view.center // 타이틀 정의 button.setTitle(\"Btn\", for: .normal) // 액션 추가 button.addTarget(self, action: #selector(didTapButton(_:)), for: .touchUpInside) // 뷰에 추가 view.addSubview(button) &#125; // 액션 정의, dismiss는 뷰를 위에 덧씌우는것이 아니라 메모리에서 해제하는 거 @objc private func didTapButton(_ sender: UIButton) &#123; dismiss(animated: true) &#125; override func viewWillAppear(_ animated: Bool) &#123; print(\"next viewWillAppear\") &#125; override func viewDidAppear(_ animated: Bool) &#123; print(\"next viewDidAppear\") &#125; override func viewWillDisappear(_ animated: Bool) &#123; print(\"next viewWillDisAppear\") &#125; override func viewDidDisappear(_ animated: Bool) &#123; print(\"next viewDidDisAppear\") &#125; // 얘가 호출이 되면 메모리에서 잘 사라진 것! deinit &#123; print(\"deinit\") &#125;&#125; Q. 어떻게 해야 dismiss 시에 VC의 배경색을 바꿀 수 있을까? nextViewController로 이동 presentedViewController =&gt; nil (내가 띄운 뷰 컨트롤러) presentingViewController =&gt; VC (나를 띄운 뷰 컨트롤러) presentingViewController?.presentedViewController =&gt; nVC (나를 띄우고 있는 뷰컨이 띄운 뷰컨) 그래서 애초에 VC로 가서 찍어보면 그냥 다 nil nil nil 내가 띄운 놈도 없고, 나를 띄운 놈도 없으니.. 그렇지만 띄우고 나서 찍어보면 다 찍힌다. Q. 일단 뷰 컨트롤러에서 버튼 객체 생성 부분을 메소드 바깥으로 뺀 뒤, 아까처럼 nVC에서 다시 돌아갈 때, 버튼의 타이틀을 바꿔보자! 아까처럼 presenting으로 하면 자동완성에 버튼 객체가 안뜬다 왜 안뜰까? 타입이 다름. presentingViewController의 타입은 UIViewController고, VC는 ViewController 타입임 그래서 타입 캐스팅을 통해 접근해야 한다. 1234guard let vc = presentingViewController as? ViewController else &#123; return &#125; vc.button.setTitle(\"클릭\", for: .normal) Q. 만약 VC가 first, second, third 이렇게 세 개 있으면 어떻게 third에서 first 로 한번에 접근 할 수 있을까? =&gt; dismiss 한다고 가정. 1presentingViewController?presentingViewController?.dismiss Card-Style Modal Presentation 풀스크린과는 life Cycle에 차이가 있음 dismiss 외에 isModalInPresentation 이라는 속성이 따로 있음 특정 조건을 만족해야 모달을 끌 수 있음 dismiss 제스쳐 사용가능 드래그 제스쳐와 관련된 코드가 있음 (선택사항) disAppear가 호출이 안됨","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"UI Guide","slug":"22","date":"2019-11-22T01:30:21.000Z","updated":"2019-11-25T11:19:24.783Z","comments":true,"path":"2019/11/22/","link":"","permalink":"http://yoursite.com/2019/11/22/","excerpt":"UI Guide 포인트: 픽셀 : 디스플레이가 좋아질 수록, 1 포인트안에 픽셀이 들어가는 갯수가 점점 커짐물리적인 크기는 동일하더라도 픽셀의 화소수가 달라짐그래서 개발시 사용하는 좌표가 달라짐Ex)오리지널 아이폰 1 point = 1 pixel아이폰5 1 point = 4 pixel","text":"UI Guide 포인트: 픽셀 : 디스플레이가 좋아질 수록, 1 포인트안에 픽셀이 들어가는 갯수가 점점 커짐물리적인 크기는 동일하더라도 픽셀의 화소수가 달라짐그래서 개발시 사용하는 좌표가 달라짐Ex)오리지널 아이폰 1 point = 1 pixel아이폰5 1 point = 4 pixel View Frameview frame의 좌표는 상위뷰를 기준으로 결정 버튼 ui의 좌표 역시 기준을 어떤 뷰로 잡느냐에 따라 같은 위치여도 좌표값은 달라진다. 1234567891011121314151617181920212223242526272829303132333435import UIKitimport PlaygroundSupportclass MyViewController : UIViewController &#123; override func loadView() &#123; let view = UIView() view.backgroundColor = .white self.view = view &#125; override func viewDidLoad() &#123; let greenView = setUpSuperView() let redView = setUpSubview(superVIew: greenView) &#125; func setUpSuperView() -&gt; UIView &#123; let greenView = UIView() // 흰색 바탕뷰로부터 50,50 떨어진 위치 greenView.frame = CGRect(x: 50, y: 50, width: 200, height: 200) greenView.backgroundColor = .green view.addSubview(greenView) return greenView &#125; func setUpSubview(superVIew: UIView) -&gt; UIView &#123; let redVIew = UIView() // 슈퍼뷰가 그린뷰니깐 그린뷰를 기준으로 100, 100 만큼 떨어진 위치 redVIew.frame = CGRect(x: 100, y: 100, width: 80, height: 80) redVIew.backgroundColor = .red superVIew.addSubview(redVIew) return redVIew &#125;&#125;PlaygroundPage.current.liveView = MyViewController() greenView.frame.origin = CGPoint(x: 0, y: 0) //좌표를 바꿔주는 속성 Bounds프레임 : 내가 추가할 서브뷰의 상위 뷰를 기준으로 좌표가 결정됨 바운드 : 객체 자신을 기준으로 0,0 의 좌표가 나타남 1연습 Content Mode scaleToFill : 늘림 scaleAspectFit : 늘리는 대신 비율도 유지 -&gt; 모자란 부분이 생김, 꽉 차진 않음 scaleAspectFill: 늘리는 대신 비율도 유지 -&gt; 모자란 부분 없이 꽉 참, 대신 화면 밖으로 넘어갈 정도로 커질 수 있음 이미지 뷰에서만 사용 된다고 보면 된다","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS, Swift","slug":"iOS-Swift","permalink":"http://yoursite.com/tags/iOS-Swift/"}]},{"title":"App Life Cycle","slug":"21","date":"2019-11-21T04:06:35.000Z","updated":"2019-11-25T12:19:53.590Z","comments":true,"path":"2019/11/21/","link":"","permalink":"http://yoursite.com/2019/11/21/","excerpt":"Xcode 프로젝트 생성 include Unit test : 테스트 코드를 짜서 미리 앱이 돌아가기전에 체크 등등은 아직 신경 안써도 됨 check 풀고 시작 통합 개발환경! IDE = editor, compiler, debugger여러가지 많지만 xcode는 macOS에서만 실행 가능","text":"Xcode 프로젝트 생성 include Unit test : 테스트 코드를 짜서 미리 앱이 돌아가기전에 체크 등등은 아직 신경 안써도 됨 check 풀고 시작 통합 개발환경! IDE = editor, compiler, debugger여러가지 많지만 xcode는 macOS에서만 실행 가능 툴바, 네비게이터, 에디터, 유틸리티, 디버그 영역 으로 창이 나뉜다. 프로젝트 전반에 대한 설명은 네비게이터 맨 윗 파일 (파란색) 유틸리티 옆의 미니맵을 통해 원하는 코드줄로 이동 가능 그 옆의 버튼은 에디터 창을 여러개 띄우는 버튼 Option 키 누른 상태로 띄우면 에디터가 아래로 뜬다. Show or hide code review 버튼은 깃을 사용 할 때 코드의 수정 전과 후를 비교할 수 있도록 도와주는 버튼 점프바를 통해 파일 간 이동이 가능하다. 파일 내부에서 원하는 메소드 줄로도 이동 가능 The App Life Cycle 앱은 기본적으로 UIApplication 이 존재한다. 기본 시스템을 제공하는 클래스! 생명주기! 앱의 생명주기, 컨트롤러의 생명주기 등등 시작부터 끝까지 각 단계에 대한 처리가 잘 알아두어야 앱 개발시 이해하고, 다룰 수 있다. 앱의 실행 과정 User taps app icon main() 함수 실행 Swift는 JAVA나 C와는 달리 어노테이션으로 main 함수를 대체한다. 1@UIApplicationMain main함수가 UIApplicationMain() 함수 호출 -&gt; UIApplication 객체 생성 UIApplicationMain 함수는 코코아 터치 프레임워크에서 앱의 라이프 사이클을 시작하는 함수 UIApplication 객체의 인스턴스를 만들고, 해당 객체의 앱으로서 기능하기 위한 기반을 마련하는데, 이 과정을 앱 로딩 프로세스라 한다. Load main UI File First initialization Restore UI State Final initialization Q. 메인함수는 왜 필요한가요? 앱의 시작점이라고 생각하면 된다. 메인함수로부터 모든게 다 시작된다. 시스템이 앱을 구동하게 만드는 함수 이 앱이 시작되고 나면 이벤트 루프가 돌게 된다. 앱의 구조 MVC 패턴 (Model / View / Controller) 데이터 / 화면 구성에 사용되는 오브젝트 / View 와 Model 사이에서 중개 해주는 역할 상태 변화 Not Running : 실행되지 않았거나, 시스템에 의해 종료된 상태 Fore ground : 앱이 화면에 띄워진 상태 (Inactive 상태로 잠깐 돌입 -&gt; Active) Inactive : 실행중이지만 이벤트를 받고 있지 않은 상태. 예를 들면 앱 실행중 미리알림이나, 통화중일 때 해당 화면이 덮여서 앱이 실질적으로 이벤트를 받지 못하는 상태를 뜻함 Active : 앱이 화면에서 실질적으로 점유하고 있는 상황 다른 앱으로 전환하거나, home 버튼을 눌러서 바탕화면으로 가면 또 잠깐의 inactive로 간담에, back ground 상태로 이동 Back ground : 백그라운드 상태에서도 동작을 하고 있는 상태. 음악앱 같은 경우! 화면을 점유하고 있지는 않지만 여전히 동작중인 상태 Suspended : 백그라운드 상태에서 멈춘 상태, 빠른 재 실행을 위하여 메모리에는 남아있지만, 동작은 하지 않는 단계 메모리가 부족하면 완전히 종료된다. not running 상태 보통 현재 버전보다 -3 까지 지원을 하고, 좀 더 넓게 지원하면 -4 버전까지도 지원한다. 좁게는 -2 Background Modes for apps 백그라운드에서 발생할 수 있는 이벤트들은 제한되어 있다. pt 참조 Audio &amp; Air Play, Location Updates, Voice over IP…. etc… https://www.raywenderlich.com/5817-background-modes-tutorial-getting-started top level 에서는 print 메소드 사용 불가 왜? ob-c 에서는 메인 함수를 미리 작성을 해두어야 했는데 swift에서는 @UIApplicationMain 이라는 코드로 대체 자바에서 메인 함수에 해당하는 부분이라고 보면 된다. Scene delegate [ SceneDelegate 사용할 때 ] iOS 13 미만일 때 (현업이나 개인앱 낼 때)1) available 명시, AppDelegate에 window 프로퍼티 추가 iOS 13 이상 + SceneDelegate 사용 기준 (공부할 때) 1) AppDelegate랑 SceneDelegate 무시// [ SceneDelegate 사용하지 않을 때 [AppDelegate만 사용할 때 ] SceneDele gate 파일 삭제 AppDelegate에서 Scene관련 메서드 삭제 Info.plist에서 Application Scene Manifest 키 삭제// Xcode 10까지는 AppDelegate.swift가 기본값 Xcode 11부터 SceneDelegate.swift가 기본값 UI 구성 스토리 보드를 사용하는 방법 Cmd + shift + l 로 뷰 컨트롤러 추가 코드로 ui를 배치하는 방법 둘다 장단점이 있고, 재사용성이 더 좋은듯. 코드로 짜는 것을 더 선호하는 편이다. 팀프로젝트할 때는 어떤 방식으로 하자고 미리 협의 후 시작! 시스템 오렌지, 시스템 블루 컬러.. 왜 이름 이렇게 붙였으까? 다크모드와 연관이 있다. 시스템 컬러로 지정해버리면 다크모드 일 때와 라이트 모드일 때 컬러가 달라짐 Alpha 값은 투명도 조절 0이면 안보이고 1이면 원색으로! 시스템 컬러는 hig 에서 다크와 라이트가 어떻게 다른지 볼 수 있음! Story Board! is initialview : 화살표로 이동 코드로 시작 뷰를 지정하면 스토리 뷰의 화살표 지정은 무시 된다. AppDelegate.swift123window = UIWindow(frame: UIScreen.main.bounds)window?.rootViewController = ViewController()window?.makeKeyAndVisible() SceneDelegate1234guard let windowScene = (scene as? UIWindowScene) else &#123; return &#125; window = UIWindow(windowScene: windowScene) window?.rootViewController = ViewController() window?.makeKeyAndVisible() (edited) 얘네를 남겨두고 스토리보드에 작업해봤자 소용없음! 주의!! IBOutlet과 IBAction의 차이점? Action : 버튼의 동작을 정의 Outlet : 버튼의 속성을 정의 오늘 결과물","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"OOP & Access Control","slug":"19","date":"2019-11-19T01:48:05.000Z","updated":"2019-11-20T07:17:10.160Z","comments":true,"path":"2019/11/19/","link":"","permalink":"http://yoursite.com/2019/11/19/","excerpt":"Access Control &amp; OOP 다른 모듈의 코드 또는 다른 소스 파일 등으로부터 접근을 제한하는 것 세부 구현 내용을 숨기고 접근할 수 있는 인터페이스 지정 가능 Access levels open : class에만 붙일 수 있음 struct와 enum은 public 부터 가능 public : internal : 정의 모듈의 모든 소스 파일 내에서 사용되지만, 해당 모듈 외부의 소스파일에서는 사용되지 않도록 합니다. fileprivate : 같은 클래스 파일 내에서만! private : 클래스 내에서만 사용하기 위해 범위를 제한!","text":"Access Control &amp; OOP 다른 모듈의 코드 또는 다른 소스 파일 등으로부터 접근을 제한하는 것 세부 구현 내용을 숨기고 접근할 수 있는 인터페이스 지정 가능 Access levels open : class에만 붙일 수 있음 struct와 enum은 public 부터 가능 public : internal : 정의 모듈의 모든 소스 파일 내에서 사용되지만, 해당 모듈 외부의 소스파일에서는 사용되지 않도록 합니다. fileprivate : 같은 클래스 파일 내에서만! private : 클래스 내에서만 사용하기 위해 범위를 제한! Nested types 프로퍼티 각각에 명시해 주는 것과, 클래스 앞에 명시해 주는 것 접근을 제한하는 범위에 차이가 있다. open 클래스여도 멤버들의 제한 레벨은 기본값이 따로 정해져있다. 클래스의 제한 수준을 따르는 것은 아님 1234567891011클래스의 제한 수준 -&gt; 멤버의 제한 수준(기본 값)Private -&gt; Fileprivate Fileprivate -&gt; Fileprivate 같은 파일 내에서만 접근 가능Internal -&gt; InternalPublic -&gt; InternalOpen -&gt; Internal private 클래스는 어차피 클래스 자체에 접근이 안되기 때문에 멤버에 제한 수준을 붙여봐야 의미없다 그런데 아예 private 클래스를 아무도 접근을 못한다면 만드는 의미가 없기 때문에 filePrivate와 비슷한 수준의 의미를 가지게 된다. 보통은 한 파일에 한 클래스를 사용하기 때문에 filePrivate 는 잘 안쓴다 Getters &amp; Setters Getter 읽어오는 애 Setter 입력하는 애 값이 변경 될 때마다, numberOfEdits가 1씩 올라감 123456789101112131415161718192021222324252627class TrackedString &#123;// var numberOfEdits = 0// private var numberOfEdits = 0 private(set) var numberOfEdits = 0 var value: String = &quot;&quot; &#123; didSet &#123; numberOfEdits += 1 &#125; &#125;&#125;let trackedString = TrackedString()trackedString.numberOfEditstrackedString.value = &quot;This string will be tracked.&quot;trackedString.numberOfEditstrackedString.value += &quot; This edit will increment numberOfEdits.&quot;trackedString.numberOfEditstrackedString.value = &quot;value changed&quot;trackedString.numberOfEdits//trackedString.numberOfEdits = 0//trackedString.numberOfEdits 예를 들면 책이 한번 개정 될때마다 개정판 번호를 올리는 그런식 접근이 안되서 함부로 수정은 안되는데, 접근 조차도 안되는 것이 문제다! 그래서 setter만 private를 걸면 직접 수정은 못한다. Getter, setter 분리하여 제한 수준 설정 가능 Enumertaion Types 다음과 같이 각 case 별로 개별적인 접근 수준 설정 불가 enum 방위2 { // fileprivate case 동 // fileprivate case 서 // fileprivate case 남 // fileprivate case 북 //} &lt;!--￼2--&gt; 코숏은 캣을 상속만 받고 아무것도 정의 하지 않음. 그래도 캣의 멤버들을 사용할 수 있음 상속 받았으니깐 Final 더 이상 상속 받을 수 없도록 하는 키워드 final class 는 상속받을 수 없음 다형성 다양한 형태로 나타날 수 있는 능력! 동일한 요청에 각기 다른 방식으로 응답할 수 있도록 만드는 것 overriding : 상위 클래스에서 상속 받은 메서드를 하위 클래스에서 필요에 따라 재정의 하는 것 overloading : 동일한 이름의 메서드가 매개 변수의 이름, 타입, 개수 등의차이에 따라 다르게 동작하는 것 Overloading 다른 파라미터 이름 다른 파라미터 타입 다른 파라미터 개수 1234567891011121314151617181920func printParameter() &#123; print(\"No param\")&#125;//func printParameter() -&gt; String &#123; // Error// print(\"No param\")//&#125;func printParameter(param: Int) &#123; print(\"Input :\", param)&#125;func printParameter(_ param: Int) &#123; print(\"Input :\", param)&#125;print(\"=====\")printParameter() // 이름이 같은 메서드가 두개라서 뭘 호출해야 할지 모르겠는 상태! 에러남printParameter(param: 1)printParameter(1) 단, 인자레이블과, 인자의 타입을 다르게 붙여주면 구분해서 사용할 수 있음 주의할 점은 a는 매개변수명이 param이고, b는 인자레이블이 param이면 에러남 구분이 안되니깐! 구분만 명확하게 되면 된다! Overriding 상속과 관련이 있다. 상속받은 메서드를 변경해서 사용하는 것 final을 클래스 앞 뿐만 아니라 클래스의 멤버 앞에 붙일수 있다. 멩버 앞의 final이 붙으면 overriding 불가능 저장 프로퍼티의 형태로는 override 사용 불가능 계산 프로퍼티는 가능 123456789101112// 저장 프로퍼티 X // override var color: UIColor = .green // 계산 프로퍼티 O override var color: UIColor &#123; get &#123; return super.color &#125; set &#123; super.color = newValue &#125; &#125; 자식 클래스에서 부모클래스의 프로퍼티를 초기화 할 수 있다. 123456class Triangle: Shape &#123; override func draw() &#123; super.draw() // 부모의 draw메서드를 실행한뒤 아래의 print 메서드 실행 print(\"draw triangle\") &#125;&#125; Q. 아래 문제를 상속을 적용해 해결해보기 12345678910111213141516171819202122232425262728293031323334// bark() 메서드를 가진 Dog 클래스를 상속받아 Poodle, Husky, Bulldog 이 서로 다르게 짖도록 구현class Dog &#123; func bark() &#123; print(\"멍멍\") &#125;&#125;class Poodle: Dog &#123; override func bark() &#123; print(\"왈왈\") &#125;&#125;class Husky: Dog &#123; override func bark() &#123; print(\"컹컹\") &#125;&#125;class Bulldog: Dog &#123; override func bark() &#123; super.bark() print(\"야옹\") &#125;&#125;let p = Poodle()let h = Husky()let b = Bulldog()p.bark()h.bark()b.bark()","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"OOP","slug":"18","date":"2019-11-18T01:51:01.000Z","updated":"2019-11-18T06:29:23.316Z","comments":true,"path":"2019/11/18/","link":"","permalink":"http://yoursite.com/2019/11/18/","excerpt":"OOP value 타입 -&gt; stack 에 저장 reference 타입 -&gt; heap 에 저장 (대표적으로 class) 포인터가 저장됨, 실제 값은 heap안에!heap 은 동적 할당.stack은 처음부터 만들어질 시점이나, 크기 같은 것들이 처음부터 지정된 상태…","text":"OOP value 타입 -&gt; stack 에 저장 reference 타입 -&gt; heap 에 저장 (대표적으로 class) 포인터가 저장됨, 실제 값은 heap안에!heap 은 동적 할당.stack은 처음부터 만들어질 시점이나, 크기 같은 것들이 처음부터 지정된 상태… Q. 자동차 클래스를 정의 하고, 객체 생성 할 것 123456789101112131415161718192021222324252627282930313233343536373839class Car &#123; var model = \"ionic\" var modelYear = 2019 var color = \"black\" var startUp = false var spd = 0 func drive() &#123; startUp = true print(\"부르릉~\") &#125; func park() &#123; if spd == 0 &#123; startUp = false &#125; else &#123; startUp = true print(\"차가 완전히 멈추면 끄세요!!\") &#125; &#125; func spdUp() &#123; spd += 5 &#125; func reverse() &#123; spd -= 1 &#125;&#125;let myCar = Car()myCar.drive()myCar.spdUp()myCar.reverse()myCar.reverse()myCar.reverse()myCar.reverse()myCar.reverse()print(myCar.spd) Class initialize 초기화(init)가 불필요한 경우 : 모든 저장 프로퍼티에 초기값이 설정되어 있음 123456789101112class Dog1 &#123; let name = \"Tory\" let color = \"Brown\" func bowwow() &#123; print(\"Dog1 Bowwow!\") &#125;&#125;let tory = Dog1()// let tory = Dog1.init()tory.bowwow() 초기화(init)가 필요한 경우 : 저장 프로퍼티 중 하나 이상이 초기값 미설정됨 1234567891011121314151617181920// 클래스 내부에서 init 메서드를 이용하여, 초기화class Dog2 &#123; let name: String let color: String init() &#123; name = \"Tory\" color = \"Brown\" &#125; func bowwow() &#123; print(\"Dog2 Bowwow!\") &#125;&#125;let tory2 = Dog2()tory2.bowwow()// 근데 이렇게 하면 Dog2 클래스의 속성을 변경할 수가 없음 123456789101112131415161718192021// 파라미터를 통해 초기화 하는 경우!class Dog3 &#123; let name: String let color: String init(name: String) &#123; self.name = name color = \"Brown\" &#125; init(name: String, color: String) &#123; self.name = name self.color = color &#125; func bowwow() &#123; print(\"Dog3 Bowwow!\") &#125;&#125;var tory3 = Dog3(name: \"Tory\")var tory4 = Dog3(name: \"Tory\", color: \"White\") Q. 전 단계에서 만든 자동차 클래스의 초기값을 제거하고 Init 메서드를 이용해 생성하기 123456789101112131415161718class Car &#123; var model : String var modelYear : Int var color : String var startUp : Bool var spd : Int init(model: String, modelYear: Int, color: String) &#123; self.model = model self.modelYear = modelYear self.color = color &#125; // 중략 // . // . // . // . let myCar = Car(model: \"ionic\", modelYear: 2019, color: \"white\") Lazy Stored Property 초기값이 인스턴스의 생성이 완료 될 때 까지도 알 수 없는 외부 요인에 의존할 때 초기값이 복잡하거나 계산 비용이 많이 드는 설정을 필요로 할 때 필요한 경우가 제한적일 때 Class ⭕️ Structure ⭕️ Enumeration ❌ 외부 요인이나 다른 설정에 기반 123456789101112// area 변수는 width와 height에 의존적임. 그렇기 때문에 처음부터 초기화 해줄 수가 없음class BasicStoredProperty &#123; var width = 10.0 var height = 20.0 // var area = 200.0// var area = self.width * self.height lazy var area = self.width * self.height&#125;// 처음부터 self로 초기화도 못해줌. self는 객체가 생성된 시점에 사용할 수 있음 이럴때 lazy를 사용한다. 계산 비용이 많이 드는 상황 예를 들면 당장 앱을 실행하자마자 필요한 부분이 아닌데 lazy 없이 그냥 선언 되어 있으면 앱이 그 오래걸리는 부분까지 다 처리하고 실행되느라 늦게 켜질 수 있음. 이럴때도 사용한다. 필요한 경우가 제한적인 상황 area가 필요한 경우가 비율로 따지면 약 10%정도 되고, 나머지 90%의 상황에서는 필요하지 않다면 지연하여 생성하는 것이 좋다. Computed Property 자료를 저장하지 않고 매번 호출할 때마다 새로 계산 Class ⭕️ Structure ⭕️ Enumeration ⭕️ 123456789101112131415161718192021222324252627282930313233343536373839class ComputedProperty &#123; var width = 5.0 var height = 5.0 // 계산을 하긴 하지만, 초기화 할 때만 한번 하고, 변경 해주기 전까지는 저장 됨 lazy var lazyArea = width * height // 매번 호출 할 때마다 새로 계산함 var area: Double &#123; return width * height &#125; // Stored + Computed get(read), set(write) private var _koreanWon = 0.0 var wonToDollar: Double &#123; get &#123; return _koreanWon / 1136.5 &#125; set &#123; _koreanWon = newValue &#125; &#125;&#125;var computed = ComputedProperty()computed.areacomputed.lazyAreacomputed.width = 10computed.areacomputed.lazyAreacomputed.lazyArea = 50.0computed.lazyAreacomputed.width = 20computed.height = 20computed.areacomputed.lazyArea Property Observer Class ⭕️ Structure ⭕️ Enumeration ❌ willSet은 값이 변경되기 직전 호출 didSet은 값이 변경된 후 호출 12345678910111213class PropertyObserver &#123; var height = 0.0 var width = 0.0 &#123; willSet &#123; print(\"willSet :\", width, \"-&gt;\", newValue) &#125; didSet &#123; print(\"didSet :\", oldValue, \"-&gt;\", width) height = width / 2 &#125; &#125;&#125; Type Property Shared Lazily Initialized Class ⭕️ Structure ⭕️ Enumeration ⭕️ Override 불가 클래스에서만 사용가능, computed property 형태로 사용, 서브클래스에서 override 가능 모든 객체의 프로퍼티를 공유해야 할 때 사용한다. 편하기도 함. 타입에 직접 접근이 가능하니깐 12345678910111213141516171819class TypeProperty &#123; static var unit: String = \"cm\" var width = 5.0&#125;let square = TypeProperty()square.widthlet square1 = TypeProperty()square1.width = 10.0square1.widthTypeProperty.unitprint(\"\\(square.width) \\(TypeProperty.unit)\")print(\"\\(square1.width) \\(TypeProperty.unit)\")TypeProperty.unit = \"m\"print(\"\\(square.width) \\(TypeProperty.unit)\")print(\"\\(square1.width) \\(TypeProperty.unit)\") Equatable, Identical12345678910111213141516// 동등 연산자1 == 12 == 1\"ABC\" == \"ABC\"class Person &#123; let name = \"이순신\" let age = 30&#125;let person1 = Person()let person2 = Person()//person1 == \"이순신\" // 에러//person1 == person2 // 에러 Q. 왜 비교 연산자를 사용할 수 없을까요? 둘다 에러가 나는디…? 왜 못쓰는 걸까 같은 타입이지만 각 person이 가지고 있는 속성중, 무엇을 비교할 것인지 명확하지 않기 때문에 에러가 난다. Equatable Protocol123456789101112class User: Equatable &#123; var name = \"이순신\" let age = 30 static func ==(lhs: User, rhs: User) -&gt; Bool &#123; return lhs.name == rhs.name &#125;&#125;let user1 = User()var user2 = User()user1 == user2 이번에는 무엇을 비교할지 프로토콜로 정의를 했기 때문에 비교 연산자를 사용할 수 있다. Identical1234user1.nameuser2.nameuser1 == user2user1 === user2 // false 뭔가 다른게 눈에 띈다. 비교연산자가 세개 붙었음 이건 왜 false 일까? === : 두 상수 또는 변수가 동일한 인스턴스를 가르키는 경우 true 반환","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift, OOP, iOS","slug":"Swift-OOP-iOS","permalink":"http://yoursite.com/tags/Swift-OOP-iOS/"}]},{"title":"객체지향프로그래밍 (Object Oriented programming)","slug":"OOP","date":"2019-11-15T06:34:26.000Z","updated":"2019-11-15T08:21:02.050Z","comments":true,"path":"2019/11/OOP/","link":"","permalink":"http://yoursite.com/2019/11/OOP/","excerpt":"참고 : https://jeong-pro.tistory.com/95객체지향 프로그래밍(OOP)프로그래밍에서 필요한 데이터를 추상화하여, 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법장점 코드 재사용의 용이함 : 남이 만든 클래스를 가져와서 이용할 수 있고, 상속을 통해 해당 클래스를 확장하여 사용할 수 있음 유지보수가 쉬움 : 절차지향 프로그래밍과 비교하면, 코드를 수정해야할 때 일일이 찾아서 수정해야 하지만, 객체지향프로그래밍은 수정해야 할 부분이 *클래스 내부에 있기 때문에 해당 부분만 수정하면 된다.","text":"참고 : https://jeong-pro.tistory.com/95객체지향 프로그래밍(OOP)프로그래밍에서 필요한 데이터를 추상화하여, 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법장점 코드 재사용의 용이함 : 남이 만든 클래스를 가져와서 이용할 수 있고, 상속을 통해 해당 클래스를 확장하여 사용할 수 있음 유지보수가 쉬움 : 절차지향 프로그래밍과 비교하면, 코드를 수정해야할 때 일일이 찾아서 수정해야 하지만, 객체지향프로그래밍은 수정해야 할 부분이 *클래스 내부에 있기 때문에 해당 부분만 수정하면 된다. 클래스 내부 : [멤버 변수(상태를 정의한 것) 혹은 메서드(행위를 정의한 것)] 대형 프로젝트에 적합함 : 클래스 단위로 *모듈화하여 개발이 가능하므로, 업무 분담이 비교적 쉽다. 모듈? : 규모가 큰 것을 여러 개로 나눈 조각 정도로 이해하자 그렇지만 모듈이 되려면 다음의 특징들을 만족해야 하나의 모듈이라 할 수 있다. 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위(unit)이다. 유일한 이름을 가져야 한다. 독립적으로 컴파일이 가능하다. 모듈에서 또 다른 모듈을 호출할 수 있다. 다른 프로그램에서도 모듈을 호출할 수 있다. 모듈은 완전한 독립 프로그램이고, 다양한 크기의 집합에 대해서 모듈이라고 부를 수 있다. 참고 : [네이버 지식백과] 모듈화 (쉽게 배우는 소프트웨어 공학, 2015. 11. 30., 김치수) 단점 처리 속도가 상대적으로 느림 객체가 많으면 용량이 커질 수 있음 설계 단계에서 많은 시간과 노력이 필요함 OOP의 특징1. 클래스 + 인스턴스 (객체) 클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기 위하여 추상화를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의 한 것 설계도에 비유하기도 한다. 속성은 변수, 행위는 메서드로 정의한다. 인스턴스 : 클래스에서 정의 한 것을 토대로 실제 메모리상에 할당된 것. 실제 프로그램에서 사용되는 데이터 2. 추상화 공통의 속성이나 행위를 묶어 이름을 붙이는 것을 말한다. 객체지향적 관점에서는 클래스를 정의하는 것을 바로 추상화라고 할 수 있다. 예를 들어. 사자, 코끼리, 강아지, 고양이, 비둘기, 토끼 라는 객체가 존재한다고 하면,이들의 공통 된 속성이나 행위를 묶어보면 ‘동물’ 혹은 ‘생물’이라는 이름을 붙일 수 있다. 3. 캡슐화 사전에 동물 클래스를 정의했다면, 나중에 동물 클래스를 구현해야 할 때 재사용이 가능하다. 객체 지향 프로그래밍에서는 기능(행위), 특성(속성)을 클래스에 정의한다. 동물 객체가 맡은 역할을 수행하기 위한 하나의 목적을 한 곳에 정의한다고 생각하자. 그런데 동물 클래스를 사용하는 입장에서는 동물 클래스로 무엇을 할 수 있는지에대해서만 알면 그 의미는 충분하다. 굳이 동물 클래스가 어떻게 작동하는지 알 필요도 없거니와, 알기도 힘들것이다. 자동차를 운전하는 사람은 ‘운전을 한다’ 라는 목적 하나만 놓고 보면 운전 방법만 알면 된다.자동차가 어떤 방식으로 작동하여 운행이 가능해 지는 것인지는 몰라도 ‘운전을 한다’ 라는 목표는 충족 할 수 있는 것이다. 그리고 개인이 마음대로 자동차를 튜닝하여 사용하는 것은 불법이다. 안전상의 문제가 발생할 수 있기 때문이다. 자동차의 외관이나 내부 역시, 가려져 있기 때문에 겉으로 보기만 해서는 어느 부분이 어떻게 움직이는지, 볼 수 없다. 정비소나 차고에서 일부러 뜯어보기 전까지는 내부를 볼 수도 없고, 마음대로 튜닝 할 수도 없다. 이러한 개념은 ‘정보의 은닉’이라는 개념에 적용할 수 있다. 캡슐화의 목적 중 하나는 함부로 내부에 접근하지 못하게 하는 것이다. 이유는 상기와 같다. 4. 상속 이미 ‘동물’ 클래스와 ‘강아지’ 클래스가 있는 상황이라고 가정하자 나는 ‘비글’ 클래스를 만들어야 한다. ‘비글’이 가지고 있는 속성과 행위를 처음부터 정의하는 것은 비효율적인 행동이다. 이미 ‘비글’이라면 가지고 있는 속성과 행위가 정의되어 있는 ‘동물’과 ‘강아지’ 클래스가존재하고 있고, 나는 그것의 존재를 알고 있기 때문이다. 그래서 ‘강아지’ 클래스를 가져다가 나의 목적에 맞게 조금만 고쳐서 ‘비글’을 만들고자 한다. 비글 이라면 가지고 있는 속성은 귀가 두 개, 포유류 식육목의 개과에 속한다는 것, 다리가 네 개 등등 있지만 상기한 속성들은 ‘강아지’가 가지고 있는 속성과 동일하다. 그래서 강아지 클래스를 가져다가 쓸 것이다. 그런데 비글 = 강아지 라는 공식은 성립하지만, 강아지 = 비글 이라는 공식은 맞지 않다. 포메라니안도 강아지고, 푸들도 강아지이기 때문이다. 위 공식이 성립하지 않는 이유는 비글이 강아지와 공통 된 속성을 가지고 있긴 하지만 비글은 비글만의 특징이 있다. 프로그래밍에서 ‘비글’을 만들 때 ‘강아지’의 속성과 행위를 가져다가 쓰는 것을 상속 이라고 한다. 이러한 과정의 방향성을 살펴 보면 강아지 -&gt; 비글 이다. 강아지의 속성을 비글에게 물려’주었고’, 비글은 강아지의 속성을 물려’받았다’ 그래서 강아지는 이 상황에서 ‘부모 클래스’, 비글은 ‘자식 클래스’이다. 사실 강아지 역시 ‘동물’의 자식 클래스이다. 4. 다형성 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석 될 수 있는 것이다. 오버라이딩, 오버로딩 오버라이딩은 부모 클래스의 메서드(행위)를 상속 받아 다른 기능을 정의 하는 것을 말한다. 이를 이용하면, 하나의 부모 클래스를 상속 받는 여러 자식 클래스들이 같은 이름에 다른 기능을 하는 메소드를 정의하고 사용할 수 있다. 오버로딩은 하나의 클래스에서 같은 이름의 메소드들을 여러 개 가질 수 있게 한다. 단, 인자 값은 달라야 한다. 인자들의 타입이나 갯수가 다르면 메소드 이름이 같더라도 어떤 메소드를 호출 할지 컴파일러가 알 수 있기 때문이다. 유사한 일을 수행하면서 인자만 다른 메소드들을 각자 다른 이름을 붙이면 사용하기가 매우 불편할 것이다.","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift, iOs, develop, OOP, coding","slug":"Swift-iOs-develop-OOP-coding","permalink":"http://yoursite.com/tags/Swift-iOs-develop-OOP-coding/"}]},{"title":"Closure / Code Snippets","slug":"15","date":"2019-11-15T01:39:33.000Z","updated":"2019-11-15T05:28:04.495Z","comments":true,"path":"2019/11/15/","link":"","permalink":"http://yoursite.com/2019/11/15/","excerpt":"Code Snippets 코딩 할 때 자주 쓰는 구문들을 편하게 쓸수 있도록 지원하는 기능. 개인설정도 가능하고, 이미 정해져있는 snippets도 있다 editor -&gt; create code snippet 코드를 적고, 드래그 한 뒤 지정하면 됨 만들때 Completion은 코드를 사용할 때 자동완성 목록에 뜨는 코드 Availability는 코드의 범위(?), 성격(?)","text":"Code Snippets 코딩 할 때 자주 쓰는 구문들을 편하게 쓸수 있도록 지원하는 기능. 개인설정도 가능하고, 이미 정해져있는 snippets도 있다 editor -&gt; create code snippet 코드를 적고, 드래그 한 뒤 지정하면 됨 만들때 Completion은 코드를 사용할 때 자동완성 목록에 뜨는 코드 Availability는 코드의 범위(?), 성격(?) closure 일회용 함수를 작성할 수 있는 구문 일회용 함수란? 한번만 사용할 구문들의 집합이면서, 그 형식은 함수로 작성해야 하는 제약이 있을 때 사용할 수 있는 함수 그렇기 때문에 이름을 생략할 수 있어서 익명(Anonymous) 함수라고도 한다. 스위프트에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나에 해당한다. 전역 함수 : 이름이 있으며, 주변 환경에서 캡처할 어떤 값도 없는 클로저 중첩 함수 : 이름이 있으며, 자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저 클로저 표현식 : 이름이 없으며 주변 환경으로부터 값을 캡처할 수 있는 경량 문법으로 작성된 클로저 클로저 표현식 클로저는 일반 함수의 선언식에서 함수명, func 키워드를 뺀 나머지 부분만 작성하는 경량 문법을 사용한다. 123&#123; (매개변수) -&gt; 반환타입 in 실행구문&#125; 일반적인 함수의 실행부는 중괄호 { 부터 시작하지만 클로저는 시작부터 이미 있으므로 in 키워드 다음부터 클로저 표현식의 실행 블록이 작성된다. 실행 블록의 작성이 끝나면 다시 중괄호 } 로 닫는다. 이는 클로저 표현식 전체의 완성을 의미한다. 123&#123; () -&gt; () in print(\"클로저가 실행됩니다\")&#125; 위의 예제는 입력 값과 반환 값이 없는 함수이다. 일반 함수와 달리 반환 값이 없으면 생략 하는 것이 아니라 빈 괄호로 표기해준다. 위의 예시 코드들과는 달리 한 줄로 작성해도 무방하다. 클로저 표현식은 대부분 파라미터로 함수를 넘겨주어야 할 때 사용하지만, 직접 실행해 볼 수도 있다. 실행하는 방법은 두가지가 있다. 1. 상수나 변수에 클로저를 할당한 다음 실행하는 방법 12345let f = &#123; () -&gt; Void in print(\"클로저가 실행됩니다\")&#125;f() 상수에 클로저를 할당하고, 이 상수에 함수호출 연산자 ( )를 추가하여 실행하는 방법이다. 2. 클로저 표현식을 할당받는 상수 f 마저 생략하고 실행하는 방법 123(&#123;() -&gt; Void in print(\"클로저가 실행됩니다\") &#125;)() 클로저 표현식 전체를 소괄호로 감싸고, 맨뒤에 함수 호출 연산자 ( )를 붙이면 완성 클로저 전체를 괄호로 감싸지 않으면 컴파일러에서는 이 구문을 클로저 표현식의 정의가 아니라 그 실행값을 변수나 상수에 할당하려는 의도로 해석하여 오류를 발생시키므로 주의! 12345let c = &#123; (s1: Int, s2: String) -&gt; Void in print(\"s1: \\(s1), s2:(s2)\")&#125;c(1, \"closure\") // s1:1, s2:closure 상수 c 에 Int형 매개변수 s1과 String형 매개변수 s2를 할당받아 출력하는 클로저 아래와 같이 간소화 할 수 있다. 123(&#123; (s1: Int, s2: String) -&gt; Void in print(\"s1: \\(s1), s2:(s2)\")&#125;) (1, \"closure\") // s1:1, s2:closure Closure Syntax 배열은 정렬 함수인 sort(by:) 를 이용하여, 큰 순서나, 작은 순서. 혹은 임의대로 정렬 할 수 있다. 정렬 기준을 잡기 위해서는 특정 형식을 따르는 함수를 정의하여 인자 값으로 넣어주어야 함 두 개의 인자값을 입력받고, 크기를 비교하여 Bool 타입으로 반환하는 형식! (의 함수) 배열을 정렬하는 메소드로 클로저를 이해해보자. 첫 번째 인자값이 두 번째 인자값보다 앞쪽에 와야한다고 판단되면 true를, 아니면 false 이 과정을 함수로 작성하면 12345678910111213// 정렬할 배열var value = [1, 9, 5, 7, 3, 2]// s1이 크면 true, 아니면 flasefunc order(s1: Int, s2: Int) -&gt; Bool &#123; if s1 &gt; s2 &#123; return true &#125; else &#123; return false &#125;&#125; value.sort(by: order) // 9, 7, 5, 3, 2, 1 sort 메소드는 true가 반환되면, 두 인자값의 위치를 변경하지 않고, false면 변경함 이 기준에 따라 정렬이 실행된 결과 9가 가장 앞으로 오게 됨 이걸 클로져로 작성하면.. 12345678value.sort(by: &#123; (s1: Int, s2: Int) -&gt; Bool in if s1 &gt; s2 &#123; return true &#125; else &#123; return false &#125;&#125;) 더 요약하면.. 123&#123; (s1: Int, s2: Int) -&gt; Bool in return s1 &gt; s2&#125; if 구문이 생략 되고 바로 return 이것을 한줄로 표현하면.. 1value.sort(by: &#123;(s1: Int, s2: Int) -&gt; Bool in return s1 &gt; s2&#125;) 그런데 여기서 더 줄일 수 있다. return 타입을 생략 할 수 있다. return 타입을 생략하면, 컴파일러는 클로저 구문을 해석하여 return 값을 찾고 이 return 값의 타입을 추론하여 클로저의 반환 타입을 알아서 정의한다. 1value.sort(by: &#123;(s1: Int, s2: Int) in return s1 &gt; s2&#125;) ‘-&gt; Bool’ 이 생략된 구문임 위의 실행식은 s1 &gt; s2 인데, 이는 비교구문이기 때문에 반환값은 true 아니면 false임 이 과정을 거쳐 컴파일러가 반환 값의 타입을 추론할 수 있음 그런데 반환 값의 타입 추론이 가능하다면, 매개변수의 타입도 추론 가능할 것 같다! 생략 된 매개변수의 타입은 대입 되는 값에 따라 컴파일러가 알아서 추론해낼것이다. 1value.sort(by:&#123;s1, s2 in return s1 &gt; s2&#125;) 그런데! 이번에는 매개변수마저 생략해 버릴 수 있다. 매개변수가 생략되면 $0, ,1 , 2…와 같은 이름으로 할당 된 내부 상수를 이용할 수 있다. 남은 건 실행구문인 in 인데 이녀석도 생략 할 수 있다 이미 실행 구문과 선언부를 분리할 필요가 없어졌기 때문이다. 1value.sort(by:&#123;return $0 &gt; $1&#125;) 사실 클로져보다 더 간결하게 줄일 수 있다. 이것을 연산자 함수라고 부른다 연산자 만을 이용하여 의미하는 바를 정확히 나타낼 수 있을 때 사용된다. 이를 이용하여 최종적으로 sort 메소드를 정리해보면 1value.sort(by: &gt; ) 부등 비교 연산자는 본래 두 가지 인자가 필요하고, 이를 첫 번째 인자와, 두 번째 인자로 해석하면 위와 같은 표현이 가능한 것이다. Q.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift, iOS","slug":"Swift-iOS","permalink":"http://yoursite.com/tags/Swift-iOS/"}]},{"title":"Optional / Enumeration","slug":"14","date":"2019-11-14T01:33:27.000Z","updated":"2019-11-14T07:29:53.064Z","comments":true,"path":"2019/11/14/","link":"","permalink":"http://yoursite.com/2019/11/14/","excerpt":"Optional Optional은 값이 없을 수 있는 상황에 사용 옵셔널 타입은 2가지 가능성을 지닌다 값을 전혀 가지고 있지 않음 nil 값이 있으며, 그 값에 접근하기 위해 옵셔널을 벗겨 낼 수 있음 값이 없는 것과 0인 것의 차이? 0 은 0이라는 값이 엄연히 존재하는 것임. nil은 진짜 값이 ‘없는’ 것","text":"Optional Optional은 값이 없을 수 있는 상황에 사용 옵셔널 타입은 2가지 가능성을 지닌다 값을 전혀 가지고 있지 않음 nil 값이 있으며, 그 값에 접근하기 위해 옵셔널을 벗겨 낼 수 있음 값이 없는 것과 0인 것의 차이? 0 은 0이라는 값이 엄연히 존재하는 것임. nil은 진짜 값이 ‘없는’ 것 숫자로 바꾸니까 int형으로 바뀌는 이유는? 123 이라는 문자열은 정수형으로 바꿀 수 있지만, 다른 문자열은 숫자로 못바꿀 수도 있는 ‘가능성’이 있기 때문에 형변환을 하면 옵셔널이 된다. 그런데 Double 타입은 비록 소수부는 사라질 지언정 int로 바꾸면 무조건 int로 바뀔 수 있기 때문에 옵셔널이 아님 123456let possibleNumber = \"123\"var convertedNumber = Int(possibleNumber)type(of: convertedNumber)type(of: Int(3.14))// Optional&lt;Int&gt;.type 선언 방법 12var optionalType1: String?var optionalType2: Optional&lt;Int&gt; 옵셔널 Int와 Int는 엄연히 다른 타입이다. 1234var nonOptionalInt = 10var optionalInt : Int? = 100nonOptionalInt + optionalInt // 에러 그렇기 때문에 연산도 할수없고, unoptional 타입의 변수에는 nil값을 할당할 수도 없다. 옵셔널 변수의 초기화는 옵셔널이 아닌 변수와 똑같다. Optional Binding and Forced UnwrappingOptional Binding 조건문을 이용하여 래핑을 벗겨내는 방식이다. 12345678let nilValue: String? = nillet someValue = \"100\"if let number = Int(someValue) &#123; print(\"\\\"\\(someValue)\\\" has an integer value of \\(number)\")&#125; else &#123; print(\"Could not be converted to an integer\")&#125; nil이면 아래의 구문을 출력하고, 값이 있으면 위의 구문을 출력한다. 옵셔널 바인딩을 사용 할 때도 변수, 상수의 법칙은 지켜진다. 123456789101112131415var optionalStr: String? = &quot;Hello, Optional&quot;// letif let optionalStr = optionalStr &#123;// optionalStr += &quot;😍&quot; optionalStr&#125; else &#123; &quot;valueless string&quot;&#125;// varif var str = optionalStr &#123; str += &quot;😍&quot; str&#125; Let 이기 때문에 optionalStr 의 값을 변경할 수 없다. 아래의 // var 부분은 변경 가능 Forced Unwrapping 끝에 !를 붙임으로서 강제로 언래핑하는 방식! 1234567891011121314if convertedNumber != nil &#123;// print(&quot;convertedNumber has an integer value of \\(convertedNumber).&quot;) print(&quot;convertedNumber has an integer value of \\(convertedNumber!).&quot;)&#125;print(convertedNumber)print(convertedNumber!)// Forced unwrap of nil valueconvertedNumber = nilconvertedNumber//convertedNumber! Q. 이렇게 하면 간단한데 왜 바인딩 같은 복잡한 방식을 사용할까? nil 값을 가지고 있는 옵셔널을 강제로 언래핑한다면 오류가 발생하니깐! 그렇기 때문에 반드시 nil 값이 들어가지 않을것이다! 라고 확신이 가능 할 때만 사용하는것이 좋다. 바인딩을 이용하여 안전하게 벗겨내는 것을 권장한다. IUO (Implicitly Unwrapped Optionals) 위에서는 뒤에 ! 를 붙여서 언래핑하였지만, 이번엔 미리 변수의 선언부에 붙여서 사용한다! ? 대신 !를 붙여서 선언하는 것인데, 옵셔널 타입이지만 일반 타입의 변수에 할당이 가능하다. 1234567var assumedString: String! = \"An implicitly unwrapped optional string.\"let implicitString: String = assumedStringlet stillOptionalString = assumedStringtype(of: assumedString) // 옵셔널이지만 일반 String 변수에 할당 가능type(of: implicitString)type(of: stillOptionalString) 옵셔널 타입을 사용해야 하지만 반드시 nil이 아니라는 보장이 있을 때 사용한다. Nil value를 체크 해야 할 일이 생길 경우에는 그냥 일반적인 옵셔널을 사용한다. 프로퍼티 지연 초기화에 많이 사용한다. (뭔진 모르겠지만) Nil-coalescing Operator123456789optionalStr = nil// nil이 아니라는 걸 확인한 후 변수에 할당!var result = \"\"if optionalStr != nil &#123; result = optionalStr!&#125; else &#123; result = \"This is a nil value\"&#125; 옵셔널 바인딩 방식인데 코드가 꽤 귀찮게 생겼다. 아래와 같이 간단하게 써보자 123let anotherExpression = optionalStr ?? \"This is a nil value\"print(optionalStr)print(anotherExpression) ?? 연산자를 사용하여 언래핑을 할 수 있다. 삼항 연산자 ? 와 헷갈릴 수 있지만, 엄연히 다른 연산자이다. 그렇지만 비슷하게 사용할 수 있다. 어떤 경우에 사용할까? let defaultColorName = &quot;red&quot; var userDefinedColorName: String? var colorNameToUse = userDefinedColorName ?? defaultColorName print(colorNameToUse) userDefinedColorName = &quot;green&quot; colorNameToUse = userDefinedColorName ?? defaultColorName print(colorNameToUse) 12345678910111213- 값이 nil 일때 할당할 값을 미리 따로 지정해 놓고 사용한다!### optionalStr ?? &quot;This is a nil value&quot; 를 3항 연산자로 바꿔보기```swiftlet answer = optionalStr != nil ? optionalStr! : &quot;This is a nil value&quot; Optional Chaining 하위 property에 옵셔널 값이 있는지 연속적으로 확인하면서, 중간에 하나라도 nil이 발견된다면 nil이 반환되는 형식 123456789class Persion &#123;ver residence: Residence?&#125;class Residence &#123;var numberOfRooms = 1&#125;let sangmin = person() Q. 아래 두 옵셔널의 차이점? 12var optionalArr1: [Int]? = [1,2,3]var optionalArr2: [Int?] = [1,2,3] 위에는 옵셔널 array 이기 때문에 optionalArr1 = nil 이 가능하다. 배열 자체를 nil 할당 가능 아래는 배열 내부 요소의 값들의 타입이 옵셔널 int. 즉 nil 값을 append 해 줄 수 있음 Optional Function Types어렵,,, 123var aClosure: (() -&gt; Int?)? = &#123; return 10&#125; Q. 연습2개의 정수를 입력받아 Modulo 연산(%)의 결과를 반환하는 함수를 만들되, 2번째 파라미터와 결과값의 타입은 옵셔널로 정의, 두 번째 파라미터 입력값으로 nil 이나 0이 들어오면 결과로 nil을 반환하고, 그 외에는 계산 결과 반환123456789func moduloValue (a: Int, b: Int?) -&gt; Int? &#123; var result: Int? if b != nil &#123; result = a % b! &#125; else if b == 0 || b == nil &#123; result = nil &#125; return result&#125; Enumeration 연관 된 값의 그룹에 대해 공통 된 타입을 정의 한뒤, type-safe 하게 해당 값들을 사용 가능..? 123456enum CompassPoint &#123; case north case south case east case west&#125; 보통은 12let north = \"north\"let south = \"south\" 요렇게 쓰는데, 잘못 입력 할 수도 있고, 남들이 연관있는 값인지 모를 수도 있음 하지만 enum을 사용하면, 안전하게 사용할 수 있다. 어차피 네가지 밖에 없으니 서로 연관 값인것도 알 수 있고, 오타도 안날거임 12345678enum Planet &#123; case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune, pluto&#125;var directionToHead1 = CompassPoint.westdirectionToHead1 = .eastvar directionToHead2: CompassPoint = .north Matching Enumeration Values switch 와 같이 잘 쓰인다. 123456789101112let directionToHead = CompassPoint.southswitch directionToHead &#123;case .north: print(\"Lots of planets have a north\")case .south: print(\"Watch out for penguins\")case .east: print(\"Where the sun rises\")case .west: print(\"Where the skies are blue\")&#125; Associated ValuesQ. enum Month { case jan, feb } 정의하되 2월은 윤년인지 아닌지 정보를 저장할 수 있도록 구현123456789enum Month &#123; case jan, feb(Bool)&#125;let february = Month.feb(false)switch february &#123;case .jan: breakcase .feb(let isLeafYear): print(isLeafYear)&#125; Raw Value 해당 enum에서 반드시 고유한 값이어야 함 Strings, Characters, or any of the Integer or Floating-point number types 12345678910111213141516171819202122enum Weekday: Int &#123; case sunday, monday, tuesday, wednesday, thursday, friday, saturday&#125;Weekday.wednesdayWeekday.wednesday.rawValueenum WeekdayName: String &#123; case sunday, monday, tuesday, wednesday, thursday, friday, saturday&#125;WeekdayName.mondayWeekdayName.monday.rawValueenum Gender: String &#123; case male = \"남자\", female = \"여자\", other = \"기타\"&#125;Gender.maleGender.male.rawValue Q. 학점(A, B, C, D, F)을 enum 으로 표현하고 각 케이스에 알맞은 0.0 ~ 4.0 까지의 값 부여123456enum GradeScore: Double &#123; case A = 4.0, B = 3.0, C = 2.0, D = 1.0, F = 0.0&#125;GradeScore.AGradeScore.A.rawValue Implicitly Assigned Raw Values12345678num WeekdayAgain: Int &#123; case sunday = 5, monday, tuesday, wednesday, thursday, friday, saturday// case sunday, monday = 100, tuesday = 101, wednesday, thursday, friday, saturday// case sunday = 1, monday = 1, tuesday = 2, wednesday, thursday, friday, saturday&#125;WeekdayAgain.wednesdayWeekdayAgain.wednesday.rawValue 처음 sunday에 rawvalue를 5를 할당했기 때문에 순서대로 가서 8을 반환한다. Initializing from a Raw Value Raw vlaue를 이용하여 초기화 가능! 123456789enum PlanetIntRaw: Int &#123; case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune, pluto&#125;PlanetIntRaw(rawValue: 5)PlanetIntRaw(rawValue: 7)PlanetIntRaw(rawValue: 0) // nilPlanetIntRaw(rawValue: 15) // nil 여기서 enum이 옵셔널의 속성을 가지고 있음을 알 수 있다. nil을 반환하니깐. 옵셔널 바인딩을 통해 ㅅㅏ용한다. 12345678910if let somePlanet = PlanetIntRaw(rawValue: positionToFind) &#123; switch somePlanet &#123; case .earth: print(\"Mostly harmless\") default: print(\"Not a safe place for humans\") &#125;&#125; else &#123; print(\"There isn't a planet at position \\(positionToFind)\")&#125; Nested 내부에 함수를 설정하여 사용도 할 수 있다. 1234567891011121314151617enum Device: String &#123; case iPhone, iPad, tv, watch func printType() &#123; switch self &#123; case .iPad, .iPhone, .tv: print(\"device :\", self) case .watch: print(\"apple Watch\") &#125; &#125;&#125;let iPhone = Device.tviPhone.printType()// tv 출력 enum 안에 enum 중첩 사용 123456789101112131415161718192021222324252627enum Wearable &#123; enum Weight: Int &#123; case light = 1 case heavy = 2 &#125; enum Armor: Int &#123; case light = 2 case heavy = 4 &#125; case helmet(weight: Weight, armor: Armor) case boots func info() -&gt; (weight: Int, armor: Int) &#123; switch self &#123; case .helmet(let weight, let armor): return (weight: weight.rawValue * 2, armor: armor.rawValue * 5) case .boots: return (3, 3) &#125; &#125;&#125;Wearable.bootsvar woodenHelmet = Wearable.helmet(weight: .light, armor: .heavy)woodenHelmet.info() Mutating enum 타입 내부 함수에서 자기 자신의 값을 변경해야 할 경우 mutating 키워드가 필요하다. Q. on 과 off 값을 가진 enum 타입 RemoteControl 을 정의하고, 그 내부에 호출 시마다 on, off 값을 바꿔주는 함수 구현1234567891011121314151617enum RemmoteControl &#123; case on, off mutating func switching() &#123; switch self &#123; case .on: self = .off case .off: self = .on &#125; &#125;&#125;var remocon = RemmoteControl.onremocon.switching()remocon.switching()","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"swift, iOS","slug":"swift-iOS","permalink":"http://yoursite.com/tags/swift-iOS/"}]},{"title":"배열 / 집합 / 딕셔너리","slug":"13","date":"2019-11-13T01:43:31.000Z","updated":"2019-11-13T10:40:22.642Z","comments":true,"path":"2019/11/13/","link":"","permalink":"http://yoursite.com/2019/11/13/","excerpt":"Collection array - 순서가 있는 값들의 모음 set - 순서가 없는, 정렬 되지 않은 특정 값 (unique values) dictionary - 키와 값의 쌍으로 정렬되지 않은 값들의 모음 배열 (Array) Zero-based integer Index 인덱스가 0부터 시작 대부분의 프로그래밍 언어들은 0부터 시작한다. 상수나 변수처럼 배열에 저장된 타입으로 타입추론이 된다.","text":"Collection array - 순서가 있는 값들의 모음 set - 순서가 없는, 정렬 되지 않은 특정 값 (unique values) dictionary - 키와 값의 쌍으로 정렬되지 않은 값들의 모음 배열 (Array) Zero-based integer Index 인덱스가 0부터 시작 대부분의 프로그래밍 언어들은 0부터 시작한다. 상수나 변수처럼 배열에 저장된 타입으로 타입추론이 된다. 초기화1234567891011// Type Annotationlet strArray1: Array&lt;String&gt; = [\"apple\", \"orange\", \"melon\"]let strArray2: [String] = [\"apple\", \"orange\", \"melon\"]// Type Inferencelet strArray3 = [\"apple\", \"orange\", \"melon\"]let strArray4 = Array&lt;String&gt;(repeating: \"iOS\", count: 5)// [ios, ios, ios, ios, ios] 와 같은 뜻// Error//let strArray5 = [\"apple\", 3.14, 1] // 같은 타입의 값이 아니기 때문에 에러 Q. String 타입과 Int 타입으로 각각 자료가 없는 상태인 빈 배열을 만들어보세요.12var strEmpty: [String] = []var intEmpty: [Int] = [] Q. Double 타입은 Type Annotation, Bool 타입은 Type Inference 방식으로 각각 임의의 값을 넣어 배열을 만들어보세요.12var dou: [Double] = [1.2, 3.4, 5.6]var boo = [true, false, false, true] Number of Elements123456789let fruits = [\"Apple\", \"Orange\", \"Banana\"]let countOfFruits = fruits.count // 요소의 갯수를 출력// fruits가 비어있지 않으면, 몇 개의 요소가 있는지 출력, 비어있으면 empty array 출력if !fruits.isEmpty &#123; print(\"\\(countOfFruits) element(s)\")&#125; else &#123; print(\"empty array\")&#125; Retrieve an Element1234567891011121314151617// 0 1 2 endIndexfruits = [\"Apple\", \"Orange\", \"Banana\"]fruits[0]fruits[2]//fruits[123] =&gt; 값의 범위를 벗어난 위치를 참조하려 했기 때문에 오류fruits.startIndex // 0fruits.endIndex // 마지막 요소의 바로 다음 위치를 가리킨다. 여기서는 3이 나온다fruits[fruits.startIndex] // Apple 참조fruits[fruits.endIndex - 1] // Banana 참조fruits.startIndex == 0fruits.endIndex - 1 == 2 Searching12345678910111213141516171819202122232425262728let alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\"]// A 가 있는지 검색if alphabet.contains(\"A\") &#123; print(\"contains A\")&#125;// 클로저 사용. 뭔 소린지는 아직 모르겠음if alphabet.contains(where: &#123; str -&gt; Bool in // code... return str == \"A\"&#125;) &#123; print(\"contains A\")&#125;// 특정 값의 위치를 알 고 싶을 때if let index = alphabet.firstIndex(of: \"D\") &#123; print(\"index of D: \\(index)\")&#125;// 이런 경우에는 옵셔널이라는 개념이 사용된다.// 왜 옵셔널이라는 값이 사용될까? if로 감싼것 빼고는 차이가 없는데//let idx1 = alphabet.firstIndex(of: \"D\")//print(idx1)// 값이 아예 존재하지 않을 때는 nil을 반환한다.//let idx2 = alphabet.firstIndex(of: \"Q\")//print(idx2) Add a new Element append 12345678910111213var alphabetArray = [\"A\"]alphabetArray.append(\"B\")alphabetArray += [\"C\"]// [\"A\", \"B\", \"C\"]var alphabetArray2 = [\"Q\", \"W\", \"E\"]// [\"A\", \"B\", \"C\", \"Q\", \"W\", \"E\"]alphabetArray + alphabetArray2// 오류가 발생한다! 타입이 다르니까 //alphabetArray.append(5.0)//alphabetArray + 1 insert 1234// 0번째 위치에 S 삽입alphabetArray.insert(\"S\", at: 0)alphabetArray.insert(\"F\", at: 3)alphabetArray Change an Existing Element12345678910alphabetArray = [\"A\", \"B\", \"C\"]alphabetArray[0] = \"Z\"alphabetArray // A 가 Z로 바뀜alphabetArray = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]alphabetArray[2...] = [\"Q\", \"W\", \"E\", \"R\"]alphabetArray // [\"A\", \"B\", \"Q\", \"W\", \"E\", \"R\"]lphabetArray[2...] = [\"Q\", \"W\"]alphabetArray // [\"A\", \"B\", \"Q\", \"W\"] 2번째 위치부터 뒤의 전부를 대체하는 뜻이기 때문에 맨뒤 e, r은 없어짐 Remove an Element1234567891011121314151617alphabetArray = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]let removed = alphabetArray.remove(at: 0)alphabetArray // A 사라짐alphabetArray.removeAll() // 다 없어짐// index 찾아 지우기alphabetArray = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]// C의 위치를 찾아서 반환한 뒤, remove로 지움, 리터럴이 중복되면, 앞선 위치의 값을 지운다.if let indexC = alphabetArray.firstIndex(of: &quot;C&quot;) &#123; alphabetArray.remove(at: indexC)&#125;alphabetArray Sorting123456789101112131415161718192021222324252627282930alphabetArray = [\"A\", \"B\", \"C\", \"D\", \"E\"]alphabetArray.shuffle() // 순서를 섞음alphabetArray.sort() // 정렬alphabetArray// shuffle vs shuffledprint(alphabetArray.shuffle()) // 자기 자신, 즉 배열 자체가 변함, 반환 값이 없음print(alphabetArray.shuffled()) // 자기 자신은 변하지 않고, 바꾼 결과를 반환// sorted vs sortprint(alphabetArray.sort()) // 반환 값 없음print(alphabetArray.sorted()) // 정렬 된 상태로 반환함//func sorted() -&gt; [Element]//mutating func sort()alphabetArray.shuffle()alphabetArray.shuffledvar sortedArray = alphabetArray.sorted()sortedArrayalphabetArray// sort by closure syntax// 클로저 배울 때 다시 배울 거지만 이런 형태로도 사용 가능하다.// 원하는 형태로 정렬할 수 있음sortedArray = alphabetArray.sorted &#123; $0 &gt; $1 &#125;alphabetArray.sorted(by: &gt;= )sortedArray Enumerating an Array1234567891011121314151617181920212223242526272829303132// 배열의 인덱스와 내용을 함께 알고 싶을 때let array = [\"Apple\", \"Orange\", \"Melon\"]for value in array &#123; if let index = array.firstIndex(of: value) &#123; print(\"\\(index) - \\(value)\") &#125;&#125;// 0 - Apple// 1 - Orange// 2 - Melon//위와 같은 기능for tuple in array.enumerated() &#123; print(\"\\(tuple.0) - \\(tuple.1)\")// print(\"\\(tuple.offset) - \\(tuple.element)\")&#125;// 바로 위의 코드를 아래와 같이 사용할 수 있다.for (index, element) in array.enumerated() &#123; print(\"\\(index) - \\(element)\")&#125;// element를 거꾸로 출력한다. for (index, element) in array.reversed().enumerated() &#123; print(\"\\(index) - \\(element)\")&#125;// 0 - Melon// 1 - Orange// 2 - Apple Q.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;] 라는 배열에서 마지막 &quot;p&quot; 문자 하나만 삭제하기 */var puppy = [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;]if let lastIndexOfP = puppy.lastIndex(of: &quot;p&quot;) &#123; puppy.remove(at: lastIndexOfP)&#125;puppy/* 정수 타입의 배열을 2개 선언하고 두 배열의 값 중 겹치는 숫자들로만 이루어진 배열 만들기 ex) [1, 2, 4, 8, 9, 12, 13] , [2, 5, 6, 9, 13] --&gt; [2, 9, 13] */let firstArray = [1, 2, 4, 8, 9, 12, 13]let secondArray = [2, 5, 6, 9, 13]var result: [Int] = []for i in firstArray &#123; for j in secondArray &#123; if i == j &#123; result.append(j) &#125; &#125;&#125;result/* 정수 타입의 배열을 선언하고 해당 배열 요소 중 가장 큰 값을 반환하는 함수 만들기 ex) [50, 23, 29, 1, 45, 39, 59, 19, 15] -&gt; 59 */// 1) Swift 에서 제공하는 기본 함수인 max() 를 이용하는 방법let arr = [50, 23, 29, 1, 45, 39, 59, 19, 15]arr.max()// 2) 두 수 중 높은 값을 반환하는 max 를 이용하거나, 3항 연산자를 이용하는 방법func maximumValue(in list: [Int]) -&gt; Int &#123; var maxValue = Int.min for number in list &#123; maxValue = max(maxValue, number) // 위 함수는 다음의 3항 연산자와 동일 // maxValue = maxValue &lt; number ? number : maxValue &#125; return maxValue&#125;maximumValue(in: [50, 23, 29, 1, 45, 39, 59, 19, 15])maximumValue(in: [10, 20, 30, 80, 50, 40])maximumValue(in: [-6, -5, -4, -3, -2, -1]) Dictionary Element = Unique Key + Value Unordered Collection 12345678910// value는 같아도 상관없지만, key는 중복되면 안됨var dictFromLiteral = [\"key 1\": \"value 1\", \"key 2\": \"value 2\"]// key의 타입과 value의 타입이 같을 필요는 없다var dictFromLiteral = [1: \"value 1\", 2: \"value 2\"]var dictFromLiteral = [\"1\": 1, \"2\": 2]dictFromLiteral = [:]// 오류//var dictFromLiteral = [:] Q. 키가 String이고, Int 타입인, 자료가 없는 상태의 빈 딕셔너리를 만드세요1var emptyDic : [String:Int] = [:] Type Annotation 과 Type Inference 방식을 모두 이용해 여러 가지 데이터를 넣어 딕셔너리를 만들어보세요.1var variousDic = [1 : \"커피\", 2 : \"고기\"] Number of ElementsCount 속성으로 키와 값 쌍의 갯수를 반환할 수 있다 12345678var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]let countOfWords = words.countif !words.isEmpty &#123; print(\"\\(countOfWords) element(s)\")&#125; else &#123; print(\"empty dictionary\")&#125; Retrieve(회수하다) an Element키를 이용하여 값을 조회할 수 있다. 12345678910111213141516var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]words[\"A\"]words[\"Q\"]if let aValue = words[\"A\"] &#123; print(aValue)&#125; else &#123; print(\"Not found\")&#125;if let zValue = words[\"Z\"] &#123; print(zValue)&#125; else &#123; print(\"Not found\")&#125; 키만 출력하는 것도 가능, 조회한 키들을 배열에 담는 것도 가능 12345print(words.keys)print(words.values)let keys = Array(words.keys)let values = Array(words.values) Enumerating(나열하기) an DictionaryFor 문을 이용하여 키와 값을 순회탐색 할 수 있다 123456789101112131415161718192021222324252627282930313233let dict = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]//키 &amp; 값 조회for (key, value) in dict &#123; print(\"\\(key): \\(value)\")&#125;//A: Apple//C: City//B: Banana// 키만 조회for (key, _) in dict &#123; print(\"Key :\", key)&#125;//Key : A//Key : C//Key : B// 값만 조회for (_, value) in dict &#123; print(\"Value :\", value)&#125;//Value : Apple//Value : City//Value : Banana// values 속성을 이용하여 값만 조회for value in dict.values &#123; print(\"Value :\", value)&#125;//Value : Apple//Value : City//Value : Banana Searching키 값 검색 1234567891011121314151617var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]for (key, _) in words &#123; if key == \"A\" &#123; print(\"contains A key.\") &#125;&#125;// contains A key.if words.contains(where: &#123; (key, value) -&gt; Bool in return key == \"A\" &#125;) &#123; print(\"contains A key.\")&#125;// contains A key. 추가 / 변경 12345678910111213141516words = [\"A\": \"A\"]words// 키 A의 값 A로 변경words[\"A\"] // Key -&gt; Unique// 키 A의 값 Apple 로 변경words[\"A\"] = \"Apple\"wordswords[\"B\"] = \"Banana\"words// 값을 변경한다.words[\"B\"] = \"Blue\"words// 키 B의 값 Banana로 변경 Change an Existing Element기존의 딕셔너리에 키가 이미 존재하면 value를 업데이트 한 후 기존 값을 반환한다. 12345678words[\"A\"] = \"App\"if let oldValue = words.updateValue(\"Apple\", forKey: \"A\") &#123; print(\"\\(oldValue) =&gt; \\(words[\"A\"]!)\")&#125; else &#123; print(\"Insert \\(words[\"A\"]!)\")&#125;words// App =&gt; Apple 출력 기존의 딕셔너리에 키가 없으면 value를 추가한 후 nil을 반환한다. 12345678if let oldValue = words.updateValue(\"Steve Jobs\", forKey: \"S\") &#123; print(\"\\(oldValue) =&gt; \\(words[\"S\"]!)\")&#125; else &#123; print(\"Add S Key with \\(words[\"S\"]!)\")&#125;words// S는 추가 되었지만// Add S Key with Steve Jobs 가 출력된다 Remove an Element삭제하기! 12345words = [\"A\": \"Apple\", \"I\": \"IPhone\", \"S\": \"Steve Jobs\", \"T\": \"Timothy Cook\"]words[\"S\"] = nilwords[\"Z\"] = nilwords// S와 Z의 키와 값이 모두 사라짐 지우려는 키가 존재하면 데이터를 지운 후 지운 데이터 반환, 없으면 nil 반환 1234567if let removedValue = words.removeValue(forKey: \"T\") &#123; print(\"\\(removedValue) removed!\")&#125;words// Timothy Cook removed! 반환words.removeAll() // 모두 제거 Nested딕셔너리 내부에 딕셔너리, 그 딕셔너리 내부에 딕셔너리 12345678910111213141516var dict1 = [String: [String]]()//dict1[\"arr\"] = \"A\"dict1[\"arr1\"] = [\"A\", \"B\", \"C\"]dict1[\"arr2\"] = [\"D\", \"E\", \"F\"]print(dict1)//[\"arr1\": [\"A\", \"B\", \"C\"], \"arr2\": [\"D\", \"E\", \"F\"]]var dict2 = [String: [String: String]]()dict2[\"user\"] = [ \"name\": \"나개발\", \"job\": \"iOS 개발자\", \"hobby\": \"코딩\",]print(dict2)//[\"user\": [\"name\": \"나개발\", \"job\": \"iOS 개발자\", \"hobby\": \"코딩\"]] 값의 타입이 다양한 딕셔너리도 가능하다 1234567891011121314151617[ \"name\": \"나개발\", // String : String \"job\": \"iOS 개발자\", \"age\": 20, // String : Int \"hobby\": \"코딩\", \"apps\": [ // String : Array \"이런 앱\", \"저런 앱\", \"잘된 앱\", \"망한 앱\", ], \"teamMember\": [ // String : Dictionary \"designer\": \"김철수\", \"marketer\": \"홍길동\" ]] as [String: Any]// 이 전체가 하나의 딕셔너리! Q. Dictionary 로 저장되어 있는 시험 성적의 평균 점수 구하기12345678let scores = [\"kor\": 92,\"eng\": 88, \"math\": 96, \"science\": 89]var sum = 0for score in scores.values &#123; sum += score&#125;var average = Double(sum) / Double(scores.values.count)print(average) Q. Dictionary로 저장된 scores 데이터를 튜플 타입을 지닌 배열로 변환하여 저장하기123456789101112131415let scores = [\"kor\": 92,\"eng\": 88, \"math\": 96, \"science\": 89]var scoreArr: [(String, Int)] = []// case 1for (key, value) in scores &#123; scoreArr.append((key, value))&#125;// case 2for dict in scores &#123; scoreArr.append(dict)&#125;// case 3scoreArr = Array(scores) Q. 주어진 자료를 보고 Dictionary 자료형에 맞게 데이터를 변수에 저장하기12345678910111213/* 패스트캠퍼스 - 스쿨 * iOS 스쿨 * 백엔드 스쿨 * 프론트엔드 스쿨 - 캠프 * A 강의 * B 강의 - 온라인 * C 강의 * D 강의 */ 1234567let fastcampus = [ \"패스트캠퍼스\": [ \"스쿨\": [\"iOS 스쿨\", \"백엔드 스쿨\", \"프론트엔드 스쿨\"], \"캠프\": [\"A 강의\", \"B 강의\"], \"온라인\": [\"C 강의\", \"D 강의\"], ]] Q. 위 문제에서 정의한 변수의 데이터 중 스쿨 배열에 저장된 첫번째 데이터를 꺼내어 출력하기 (자세한 내용은 Optional 시간에!)1234567891011121314if let 패캠 = fastcampus[\"패스트캠퍼스\"] &#123; if let 스쿨 = 패캠[\"스쿨\"] &#123; print(스쿨[0]) &#125;&#125;if let 패캠 = fastcampus[\"패스트캠퍼스\"], let 스쿨 = 패캠[\"스쿨\"], let iOS = 스쿨.first &#123; print(iOS)&#125;print(fastcampus[\"패스트캠퍼스\"]![\"스쿨\"]![0])// 결과는 모두 동일하다.// iOS 스쿨 Set 정렬 되지 않은 모음 unique value 전반적으로 배열과 유사함 Array와 Dictionary에 비하면 사용빈도가 낮다 선언 123let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]let numbers: Set = [1, 2, 3, 3, 3]let emptySet = Set&lt;String&gt;() Number of Elements데이터의 갯수 반환하기! 배열과 같음 count 속성을 이용한다. 12345678910let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]fruitsSet.countif !fruitsSet.isEmpty &#123; print(\"\\(fruitsSet.count) element(s)\")&#125; else &#123; print(\"empty set\")&#125;//3 element(s) 출력 Searching배열과는 달리 순서가 정렬되어 있는 것이 아니기 때문에 인덱스 주소로 검색할 수 없다. 123456789let x: Set = [1, 2, 3, 4, 5]let y: Set = [1, 2, 3, 4, 5]xy// 출력해 보면 같은 모양의 집합이지만 순서는 엉망진창이다. 완전 다름fruitsSet[0] // 오류!!!!!!x.first // 첫 번째 값만 반환한다 contains 속성을 이용하여 참조 가능하다 12345let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]if fruitsSet.contains(\"Apple\") &#123; print(\"Contains Apple\")&#125; Has prefix 속성을 이용하여 첫 번째 글자를 통해 참조도 가능하다 1234567891011let productSet: Set = [\"iPhone\", \"iPad\", \"Mac Pro\", \"iPad Pro\", \"Macbook Pro\"]for element in productSet &#123; if element.hasPrefix(\"i\") &#123; print(element) &#125;&#125;// iPad Pro// iPhone// iPad Add a New Element역시 배열과 달리 인덱싱을 통해 데이터를 추가하는 append 속성과 at 속성은 사용할 수 없다. 1234[1,2,3].append(1)[1,2,3].insert(2, at: 0)// 둘다 에러!!!!! Insert 속성을 통해 밀어넣는다 1234567891011var stringSet: Set&lt;String&gt; = []stringSet.insert(\"Apple\")stringSetstringSet.insert(\"Orange\")stringSetstringSet.insert(\"Orange\")stringSet// 물론 넣은 순서대로 정렬되지는 않는다. Remove an Element데이터를 지울 때 역시 인덱스를 통하지 않고 직접 remove 속성을 이용하여 지운다. 1234567891011stringSet = [\"Apple\", \"Orange\", \"Melon\"]stringSet.remove(\"Apple\")if let removed = stringSet.remove(\"Orange\") &#123; print(\"\\(removed) has been removed!\")&#125;stringSetstringSet.removeAll() Compare two sets비교 연산자를 사용하여 두 개의 집합을 비교할 수 있다. bool 타입을 반환한다. 123456789var favoriteFruits = Set([\"Apple\", \"Orange\", \"Melon\"])var tropicalFruits = Set([\"Banana\", \"Papaya\", \"Kiwi\", \"Pineapple\"])if favoriteFruits == tropicalFruits &#123; print(\"favoriteFruits == tropicalFruits\")&#125; else &#123; print(\"favoriteFruits != tropicalFruits\")&#125;// favoriteFruits != tropicalFruits 출력 그런데 elementsEqual 속성은 순서까지 같아야 한다. 12345var favoriteFruits1 = Set([\"Orange\", \"Melon\", \"Apple\"])var favoriteFruits2 = Set([\"Apple\", \"Melon\", \"Orange\"])favoriteFruits1 == favoriteFruits2 // true 반환favoriteFruits1.elementsEqual(favoriteFruits2) // false 반환 Fundamental Set Operations intersection - 교집합 symmetricDifference - 교집합의 여집합 union - 합집합 subtracting - 차집합 관련 업계 종사자가 아닌 이상 딱히 쓸 기능은 아니므로 이런게 있다고만 알고 넘어간다. Q&amp;AQ. 배열의 크기를 ‘굳이’ 상수에 할당하여 순회탐색을 하는 이유가 뭔가요?123456var cities = [\"Seoul\", \"Newyork\", \"LA\", \"Santiago\"]let length = cities.countfor i in 0..&lt;length &#123; print(\"\\(i)번째 배열 원소는 \\(cities[i]입니다)\")&#125; 이와 같이 상수 length에 담아서 탐색하지 않고, 123for i in 0..&lt;cities.count &#123;// ~~~&#125; 위와 같은 식으로 직접 배열의 크기를 계산하여 사용하면 코드가 더 간결해지지만, 잠재적으로 문제가 될 소지가 있는 구문이 된다. for~in 구문은 루프를 반복할 때마다 매번 조건식을 평가하기 때문에, 배열의 크기를 매번 다시 계산하게 된다. 배열의 크기가 작다면 크게 문제가 되진 않겠지만, 배열이 크다면 매번 배열의 크기를 계산하는 것은 전체적으로 실행 속도를 떨어뜨리는 원인이 된다. 무슨 차이인건가요?12345678// 특정 값의 위치를 알고 싶을 때if let index = alphabet.firstIndex(of: \"D\") &#123; print(\"index of D: \\(index)\")&#125;let idx1 = alphabet.firstIndex(of: \"D\")//print(idx1) 위 두 가지 코드는 if로 감싼 것 외에는 별 다른 차이가 없다. 설명하기 위해서는 Optional 이라는 개념을 이해해야 하니 내일로 넘어간다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"swift, iOS","slug":"swift-iOS","permalink":"http://yoursite.com/tags/swift-iOS/"}]},{"title":"hexo / github","slug":"12","date":"2019-11-12T08:25:51.000Z","updated":"2019-11-13T10:34:47.283Z","comments":true,"path":"2019/11/12/","link":"","permalink":"http://yoursite.com/2019/11/12/","excerpt":"hexo 블로그 테마 적용하기한국어 지원 안하는 테마들 지원해주는 경험도 좋음Ghblog 디렉토리에 클론 경로 주의!vi _config.yml켜서 theme 수정나와서hexo clean &amp;&amp; hexo generatehexo server 로 로컬 서버 돌리고","text":"hexo 블로그 테마 적용하기한국어 지원 안하는 테마들 지원해주는 경험도 좋음Ghblog 디렉토리에 클론 경로 주의!vi _config.yml켜서 theme 수정나와서hexo clean &amp;&amp; hexo generatehexo server 로 로컬 서버 돌리고 확인 성공! iTerm 이런저런 설정은 ulgoon.github.io 가서 확인! branch 어떤 시점에 분기점을 치는 행위 -&gt; 브랜치를 친다 분기점을 생성하고 독립적으로 코드를 변경할 수 있도록 도와주는 모델 일단 로컬 저장소로 이동! 1cd iOS-git-first 마블 멀티 유니버스의 개념이랑 유사함 스파이더맨이라는 캐릭터가 있는데 유니버스마다 스파이더맨의 성향이 다르게 설정할 수 있음 브랜치도 이와 유사함 1git branch 위 명령어를 치면 현재 브랜치 목록 출력 1git branch earth123 earth123 브랜치 생성 1git checkout earth123 Earth123 브랜치로 이동! readme.md 수정하고 저장 1git add README.md git status 를 찍어서 상황을 확인해보자 Commit.. 1git commit -m &quot;docs: remove contents from README.md&quot; branch test 작업한 내용이 마음에 안들면 브랜치 날려버리면 된다. Earth123 브랜치의 작업 내용이 맘에 안든다! 날려버리자 1git branch -D earth123 연습해보자 Edit-readme 브랜치 생성 checkout 하고 readme.md 수정 add, commit 확인 master 브랜치로 이동한 상태에서 git diff edit-readme 명령어를치면 차이점을 확인 할 수 있다 merge Edit-readme의 작업이 맘에 든다! Master 로 병합하자! 1git merge edit-readme 과제 Add-profile 브랜치 생성해서 readme.md 수정 하고 병합 마스터에 병합이 끝나면 해당 기능 개발에 대한 작업이 완료 된 것이기 때문에 이미 완료된 브랜치들이 남아있을 필요가 없음 완료된 브랜치들 날려버리자 123git branch -D add-profilegit branch -D edit-readmegit branch // 현재 브랜치 상태 확인 git flow strategy브랜치 목록 master develop feature : 기능 개발 브랜치 feature 기능 개발 브랜치 version naming 마스터 브랜치가 진행 될 수록 버전이 진행 되는 개념 매니저가 release 합시다! 하면 알아서 할것 우리가 건드릴 일은 별로 없음, 팀장급이 아니라면. Ex) v1.0.1 맨 앞에 최초 상용 버전이 되었을때 1이 됨 맨 앞 숫자는 메이저한 변화를 반영한다. 완전 새로운데 앱 이름만 바뀐 경우 등 뭔가 기능(feature)가 추가 되면 가운데 숫자 올라감 v1.2.1, v1.3.1 Develop 을 앞에서 배운 master 브랜치 느낌으로 이해하면 됨 git flow프로젝트를 시작할 때 1git flow init 으로 시작 후 엔터엔터엔터엔터… 1git flow feature start flow-init touch main.swift // 작업 끝 git gi 콜라보레이터 사용 잘 안함 팀장today lunch 레포를 생성하자 리드미파일 수정하는 식으로 해볼거임 클론 하자 Today-lunch 들어가서 git flow init git branch Readme.md 수정 날짜 적을 것 git status git add readme.md git commit -m “docs: add date for today” git push origin -u develop 팀원팀장 레포 들어가서 Fork : 남의 레포에 push를 하려면 접근이 안됨, 그래서 사본을 만드는 거임 fork를 뜨는거다! Fork를 하면 팀장꺼를 복사해서 팀원이 사용한다. 그리고 팀장레포에 가서 issue를 하나 만들면 된다. Issue 에서는 제안, 신고 등 의견을 내는 곳임 실습에서는 점심메뉴를 적는 것으로 업데이트 한다. 이슈넘버가 생성된다. 복사한 레포, git clone 그런데 팀장은 분명 branch를 쳤는데 반영이 안되어있다. Readme도 팀장이 수정한 내용이 없음 그랴서 팀장의 상태를 땡겨와야함! git flow init git pull origin develop 요렇게 해서 팀장의 레포와 상태를 똑같이 만들어 놓고 팀원 본인의 기능 개발을 시작한다. git flow feature start 1112-팀원명 이 실습은 readme.md 파일에 점심메뉴를 적는것으로 한다. git add README.md git commit -m “docs: blah blah” git flow feature finish git push origin develop 다 끝나면 팀장의 develop으로 pull 요청해야함. 접근권한이 없어서 사본을 떴으니깐. (master로 요청하면 안됨! 확인 주의) pull request solved #1 (이슈넘버) 팀장pull request를 확인한다 merge를 눌러주면 팀원의 작업 내용이 팀장의 레포에 반영이 됨","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo, github, blog","slug":"hexo-github-blog","permalink":"http://yoursite.com/tags/hexo-github-blog/"}]},{"title":"조건문 / 반복문","slug":"11","date":"2019-11-11T01:43:31.000Z","updated":"2019-11-13T10:33:52.697Z","comments":true,"path":"2019/11/11/","link":"","permalink":"http://yoursite.com/2019/11/11/","excerpt":"if statement조건문이 true이면 출력, else는 false일 때 출력, else if는 다른 조건이 true일 때 출력1234567891011// Logical And Operatorif (temperatureInFahrenheit &gt; 0) &amp;&amp; (temperatureInFahrenheit % 2 == 0) &#123;&#125;// Logical And Operatorif temperatureInFahrenheit &gt; 0, temperatureInFahrenheit % 2 == 0 &#123;&#125;// Logical Or Operatorif temperatureInFahrenheit &gt; 0 || temperatureInFahrenheit % 2 == 0 &#123;&#125;","text":"if statement조건문이 true이면 출력, else는 false일 때 출력, else if는 다른 조건이 true일 때 출력1234567891011// Logical And Operatorif (temperatureInFahrenheit &gt; 0) &amp;&amp; (temperatureInFahrenheit % 2 == 0) &#123;&#125;// Logical And Operatorif temperatureInFahrenheit &gt; 0, temperatureInFahrenheit % 2 == 0 &#123;&#125;// Logical Or Operatorif temperatureInFahrenheit &gt; 0 || temperatureInFahrenheit % 2 == 0 &#123;&#125; &amp;&amp; 연산자는 자주 사용하니 , 로 대체 가능하다 Q. if ~ else if / if 문을 2개 하는 것과 차이점?123456789var number = 9if number &lt; 10 &#123; print(\"10보다 작다\")&#125;if number &lt; 20 &#123; print(\"20보다 작다\")&#125;// if 문을 두번 사용 하면 위와 같은 경우 두 개 다 실행된다. if ~ else if 만 있을 때 else 없이 동일하게 처리하려면?12345678910var = 25if number &lt; 10 &#123; print(\"10보다 작다\")&#125; else if number &lt; 20 &#123; print(\"20보다 작다\")&#125; else if number &gt;= 20 &#123; print(\"20과 같거나 크다\")&#125;// else if에 해당하지 않는 모든 경우를 else가 들어갈 자리에 조건을 걸어줘야한다. Switch statement12345678910111213/* switch &lt;#value#&gt; &#123; case &lt;#value 1#&gt;: &lt;#respond to value 1#&gt; case &lt;#value 2#&gt;, &lt;#value 3#&gt;: &lt;#respond to value 2 or 3#&gt; default: &lt;#otherwise, do something else#&gt; &#125; - switch 문은 가능한 모든 사례를 반드시 다루어야 함 (Switch must be exhaustive) */ Q. 아래의 if - else if - else 문을 switch 문으로 바꿔보세요.1234567if temperatureInFahrenheit &lt;= 32 &#123; print(\"It's very cold. Consider wearing a scarf.\") &#125; else if temperatureInFahrenheit &gt;= 86 &#123; print(\"It's really warm. Don't forget to wear sunscreen.\") &#125; else &#123; print(\"It's not that cold. Wear a t-shirt.\") &#125; 12345678910var temp = 44switch temp &#123;case ...32 : print(\"It's very cold. Consider wearing a scarf.\")case 33...86 : print(\"It's really warm. Don't forget to wear sunscreen.\")default: print(\"It's not that cold. Wear a t-shirt.\")&#125; Compound case if문은 콤마(,)가 And(&amp;&amp;)연산인 것과 반대로 switch문은 콤마(,)가 Or(||) 연산 123456789let somePoint = (9, 0)switch somePoint &#123;case (let distance, 0), (0, let distance): print(\"On an axis, \\(distance) from the origin\")default: print(\"Not on an axis\")&#125;// x나 y 둘중 하나가 0이면 On an axis가 출력됨 where clause12345678910let anotherPoint = (1, -1)switch anotherPoint &#123;case let (x, y) where x == y: print(\"(\\(x), \\(y)) is on the line x == y\")case let (x, y) where x == -y: print(\"(\\(x), \\(y)) is on the line x == -y\")case let (x, y): print(\"(\\(x), \\(y)) is just some arbitrary point\")&#125; Q. 어떤 숫자가 주어졌을 때 짝수인지 홀수인지 출력 (switch의 where 절 이용)12345678var num = 89switch num &#123;case num where num % 2 == 0: print(\"짝수입니다.\")default: print(\"홀수입니다.\")&#125; Fallthrough 다른 언어들은 swith문이 계속 break를 써주어야 한다. 안쓰면 그 다음 구문도 실행됨 그런데 swift는 안넣어도 되는게 기본임 반대로 fallthrough를 넣어주어야 다음 구문도 실행 됨 1234567891011121314let integerToDescribe = 5var description = \"The number \\(integerToDescribe) is\"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += \" a prime number, and also\" fallthroughdefault: description += \" an integer.\"&#125;print(description)// 위 코드에서 fallthrough를 빼면 default 부분은 실행이 안됨 Guard statement 조건에 맞지 않으면 바로 종료 12345func update(age: Int) &#123; if 1...100 ~= age &#123; print(\"Update\") &#125;&#125; 1234func update(age: Int) &#123; guard 1...100 ~= age else &#123; return &#125; print(\"Update\")&#125; Tuple1234567891011121314let numbers = threeNumbersnumbersnumbers.0numbers.1// 위와 같이 매번 인덱스로 접근하고 싶지 않으면 아래와 같이 각각의 변수에 저장하는 것도 가능하다. let (first, second, third) = threeNumbersfirstsecond// wildcard patternlet (_, second1, third1) = threeNumberssecond1third1 Named Tuple1234567891011let iOS = (language: \"Swift\", version: \"4\")//let iOS: (language: String, version: String) = (language: \"Swift\", version: \"4\")//let iOS: (language: String, version: String) = (\"Swift\", \"4\")//let iOS = (language: \"Swift\", version: \"4\")iOS.0iOS.1iOS.languageiOS.version Comparison Operators Tuple 은 7개 미만 요소에 대한 비교 연산자가 포함되어 있음 7개 이상의 요소를 비교하기 위해서는 비교 연산자를 직접 구현해야 함 Q. 다음의 비교 결과는?123456789(1, \"zebra\") &lt; (2, \"apple\") // true(3, \"apple\") &gt; (3, \"bird\") // false(\"3.14\", 99) &gt; (\"1.99\", 1) // true(\"blue\", 1) &gt; (\"bluesky\", -1) // false(4, \"dog\") == (4, \"dog\") // true(\"일\", 1) &gt; (\"이\", 2.0)(1, \"zebra\") &lt; (\"2\", \"apple\") // 에러남 비교하는 값들의 타입이 다르기 때문(\"blue\", false) &lt; (\"purple\", true) // 에러남 불 값은 크기비교를 할 수 없어서 Loops for 문 while for문Q. for 문을 이용하여 3 의 10 제곱에 대한 결과값을 표현하는 코드 구현1234567let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print(answer) Q. for 문을 이용하여 10부터 1까지 내림차순으로 출력하는 코드 구현12 While 문 조건이 거짓이 될 때까지 일련의 명령문 수행 첫 번째 반복이 시작되기 전에 반복 횟수를 알지 못할 때 많이 사용 while / repeat-while Q. 자연수 하나를 입력받아 1부터 해당 숫자 사이의 모든 숫자의 합을 구해 그 합을 반환하는 함수1234567891011121314151617181920212223func sumNumbers(max: Int) -&gt; Int &#123; var num = 1 var sum = 0 repeat &#123; sum += num // num += 1 &#125; while num &lt;= max return sum&#125;func totalNum(max: Int) -&gt; Int &#123; var num = 1 var sum = 0 while num &lt;= max &#123; sum += num num += 1 &#125; return sum&#125;print(totalNum(max: 3))print(sumNumbers(max: 10)) Control Transfer Statement continue - 현재 반복문의 작업을 중단하고 다음 반복 아이템에 대한 작업 수행 break - break가 포함된 해당 제어문의 흐름을 즉각 중단 (반복문, switch 문) fallthrough - switch 문에서 매칭된 case 의 실행이 종료된 후 그 다음의 case 까지 실행 return - 함수를 즉시 종료하고, return type에 해당하는 자료를 반환 Practice123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// - 학점을 입력받아 각각의 등급을 반환해주는 함수 (4.5 = A+, 4.0 = A, 3.5 = B+ ...)func returnGrade (score : Float) -&gt; String &#123; if score &gt;= 4.5 &#123; return \"A+\" &#125; else if score &gt;= 4.0 &#123; return \"A\" &#125; else if score &gt;= 3.5 &#123; return \"B+\" &#125; else if score &gt;= 3.0 &#123; return \"B\" &#125; else if score &gt;= 2.5 &#123; return \"C+\" &#125; else if score &gt;= 2.0 &#123; return \"C\" &#125; else &#123; return \"F\" &#125;&#125;returnGrade(score: 4.3)// - 특정 달을 숫자로 입력 받아서 문자열로 반환하는 함수 (1 = \"Jan\" , 2 = \"Feb\", ...)func transMonth (month: Int) -&gt; String &#123; switch month &#123; case month where month == 1: return \"Jan\" case month where month == 2: return \"Feb\" case month where month == 3: return \"Mar\" case month where month == 4: return \"Apr\" case month where month == 5: return \"May\" case month where month == 6: return \"Jun\" case month where month == 7: return \"Jul\" case month where month == 8: return \"Aug\" case month where month == 9: return \"Sep\" case month where month == 10: return \"Oct\" case month where month == 11: return \"Nov\" case month where month == 12: return \"Dec\" default : return \"not month\" &#125;&#125;transMonth(month: 12)// - 세 수를 입력받아 세 수의 곱이 양수이면 true, 그렇지 않으면 false 를 반환하는 함수// (switch where clause 를 이용해 풀어볼 수 있으면 해보기)func num (a: Int, b: Int, c: Int) -&gt; Bool &#123; let mul = a * b * c switch mul &#123; case mul where mul &gt; 0: return true case mul where mul == 0: return false default : return false &#125;&#125;num(a: 2, b: 92, c: 0)/*: --- ## Loops --- */// 반복문(for , while , repeat - while)을 이용해 아래 문제들을 구현해보세요.// - 자연수 하나를 입력받아 그 수의 Factorial 을 구하는 함수// (Factorial 참고: 어떤 수가 주어졌을 때 그 수를 포함해 그 수보다 작은 모든 수를 곱한 것)// ex) 5! = 5 x 4 x 3 x 2 x 1 func factorial (a: Int) -&gt; Int &#123; var mul = 1 var num = 1 while num &lt;= a &#123; mul *= num num += 1 &#125; return mul &#125;factorial(a:10)// - 자연수 두 개를 입력받아 첫 번째 수를 두 번째 수만큼 제곱하여 반환하는 함수// (2, 5 를 입력한 경우 결과는 2의 5제곱)func squard (a: Int, b: Int) -&gt; Int &#123; var squ = 1 for _ in 0..&lt;b &#123; squ *= a &#125; return squ&#125;squard(a: 2, b: 3)// - 자연수 하나를 입력받아 각 자리수 숫자들의 합을 반환해주는 함수// (1234 인 경우 각 자리 숫자를 합치면 10)func sumSeat (a: Int) -&gt; Int &#123; let str = String(a) var sum: [Character] = [] var total = 0 for char in str &#123; sum.append(char) &#125; for i in 1...sum.count &#123; total += i &#125; return total&#125;print(sumSeat(a: 21347))/*: --- ## Control Transfer --- */// - 자연수 하나를 입력받아 1부터 해당 숫자 사이의 모든 숫자의 합을 구해 반환하는 함수를 만들되,// 그 합이 2000 을 넘는 순간 더하기를 멈추고 바로 반환하는 함수 func sum (a: Int) -&gt; Int &#123; var sum = 0 var num = 1 while num &lt;= a &#123; if sum &lt;= 2000 &#123; sum += num num += 1 &#125; else &#123; break &#125; &#125; return sum &#125;sum(a: 67)// - 1 ~ 50 사이의 숫자 중에서 20 ~ 30 사이의 숫자만 제외하고 그 나머지를 모두 더해 출력하는 함수func remainSum() -&gt; Int &#123; var sum = 0 for i in 1...50 &#123; if i &gt;= 20 &amp;&amp; i &lt;= 30 &#123; continue &#125; else &#123; sum += i &#125; &#125; return sum&#125;print(remainSum())","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"swift, iOS","slug":"swift-iOS","permalink":"http://yoursite.com/tags/swift-iOS/"}]}]}