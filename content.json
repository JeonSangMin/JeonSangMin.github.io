{"meta":{"title":"Let's Swift!","subtitle":"SangMin's study blog","description":"","author":"SangMin Jeon","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-11-12T10:28:48.000Z","updated":"2019-11-12T10:28:48.191Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-12T10:28:56.000Z","updated":"2019-11-12T10:28:56.814Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-11-12T10:29:11.000Z","updated":"2019-11-12T10:30:20.095Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"App Life Cycle","slug":"21","date":"2019-11-21T04:06:35.000Z","updated":"2019-11-21T10:50:32.601Z","comments":true,"path":"2019/11/21/","link":"","permalink":"http://yoursite.com/2019/11/21/","excerpt":"","text":"Xcode 프로젝트 생성 include Unit test : 테스트 코드를 짜서 미리 앱이 돌아가기전에 체크 등등은 아직 신경 안써도 됨 check 풀고 시작 통합 개발환경! IDE = editor, compiler, debugger 여러가지 많지만 xcode는 macOS에서만 실행 가능 툴바, 네비게이터, 에디터, 유틸리티, 디버그 영역 으로 창이 나뉜다. 프로젝트 전반에 대한 설명은 네비게이터 맨 윗 파일 (파란색) 유틸리티 옆의 미니맵을 통해 원하는 코드줄로 이동 가능 그 옆의 버튼은 에디터 창을 여러개 띄우는 버튼 Option 키 누른 상태로 띄우면 에디터가 아래로 뜬다. Show or hide code review 버튼은 깃을 사용 할 때 코드의 수정 전과 후를 비교할 수 있도록 도와주는 버튼 점프바를 통해 파일 간 이동이 가능하다. 파일 내부에서 원하는 메소드 줄로도 이동 가능 The App Life Cycle 앱은 기본적으로 UIApplication 이 존재한다. 기본 시스템을 제공하는 클래스! 생명주기! 앱의 생명주기, 컨트롤러의 생명주기 등등 시작부터 끝까지 각 단계에 대한 처리가 잘 알아두어야 앱 개발시 이해하고, 다룰 수 있다. 앱의 실행 과정 User taps app icon main() 함수 실행 Swift는 JAVA나 C와는 달리 어노테이션으로 main 함수를 대체한다. 1@UIApplicationMain main함수가 UIApplicationMain() 함수 호출 -&gt; UIApplication 객체 생성 UIApplicationMain 함수는 코코아 터치 프레임워크에서 앱의 라이프 사이클을 시작하는 함수 UIApplication 객체의 인스턴스를 만들고, 해당 객체의 앱으로서 기능하기 위한 기반을 마련하는데, 이 과정을 앱 로딩 프로세스라 한다. Load main UI File First initialization Restore UI State Final initialization Q. 메인함수는 왜 필요한가요? 앱의 시작점이라고 생각하면 된다. 메인함수로부터 모든게 다 시작된다. 시스템이 앱을 구동하게 만드는 함수 이 앱이 시작되고 나면 이벤트 루프가 돌게 된다. 앱의 구조 MVC 패턴 (Model / View / Controller) 데이터 / 화면 구성에 사용되는 오브젝트 / View 와 Model 사이에서 중개 해주는 역할 상태 변화 Not Running : 실행되지 않았거나, 시스템에 의해 종료된 상태 Fore ground : 앱이 화면에 띄워진 상태 (Inactive 상태로 잠깐 돌입 -&gt; Active) Inactive : 실행중이지만 이벤트를 받고 있지 않은 상태. 예를 들면 앱 실행중 미리알림이나, 통화중일 때 해당 화면이 덮여서 앱이 실질적으로 이벤트를 받지 못하는 상태를 뜻함 Active : 앱이 화면에서 실질적으로 점유하고 있는 상황 다른 앱으로 전환하거나, home 버튼을 눌러서 바탕화면으로 가면 또 잠깐의 inactive로 간담에, back ground 상태로 이동 Back ground : 백그라운드 상태에서도 동작을 하고 있는 상태. 음악앱 같은 경우! 화면을 점유하고 있지는 않지만 여전히 동작중인 상태 Suspended : 백그라운드 상태에서 멈춘 상태, 빠른 재 실행을 위하여 메모리에는 남아있지만, 동작은 하지 않는 단계 메모리가 부족하면 완전히 종료된다. not running 상태 보통 현재 버전보다 -3 까지 지원을 하고, 좀 더 넓게 지원하면 -4 버전까지도 지원한다. 좁게는 -2 Background Modes for apps 백그라운드에서 발생할 수 있는 이벤트들은 제한되어 있다. pt 참조 Audio &amp; Air Play, Location Updates, Voice over IP…. etc… https://www.raywenderlich.com/5817-background-modes-tutorial-getting-started top level 에서는 print 메소드 사용 불가 왜? ob-c 에서는 메인 함수를 미리 작성을 해두어야 했는데 swift에서는 @UIApplicationMain 이라는 코드로 대체 자바에서 메인 함수에 해당하는 부분이라고 보면 된다. Scene delegate [ SceneDelegate 사용할 때 ] iOS 13 미만일 때 (현업이나 개인앱 낼 때)1) available 명시, AppDelegate에 window 프로퍼티 추가 iOS 13 이상 + SceneDelegate 사용 기준 (공부할 때) 1) AppDelegate랑 SceneDelegate 무시// [ SceneDelegate 사용하지 않을 때 [AppDelegate만 사용할 때 ] SceneDele gate 파일 삭제 AppDelegate에서 Scene관련 메서드 삭제 Info.plist에서 Application Scene Manifest 키 삭제// Xcode 10까지는 AppDelegate.swift가 기본값 Xcode 11부터 SceneDelegate.swift가 기본값 UI 구성 스토리 보드를 사용하는 방법 Cmd + shift + l 로 뷰 컨트롤러 추가 코드로 ui를 배치하는 방법 둘다 장단점이 있고, 재사용성이 더 좋은듯. 코드로 짜는 것을 더 선호하는 편이다. 팀프로젝트할 때는 어떤 방식으로 하자고 미리 협의 후 시작! 시스템 오렌지, 시스템 블루 컬러.. 왜 이름 이렇게 붙였으까? 다크모드와 연관이 있다. 시스템 컬러로 지정해버리면 다크모드 일 때와 라이트 모드일 때 컬러가 달라짐 Alpha 값은 투명도 조절 0이면 안보이고 1이면 원색으로! 시스템 컬러는 hig 에서 다크와 라이트가 어떻게 다른지 볼 수 있음! Story Board! is initialview : 화살표로 이동 코드로 시작 뷰를 지정하면 스토리 뷰의 화살표 지정은 무시 된다. AppDelegate.swift123window = UIWindow(frame: UIScreen.main.bounds)window?.rootViewController = ViewController()window?.makeKeyAndVisible() SceneDelegate1234guard let windowScene = (scene as? UIWindowScene) else &#123; return &#125; window = UIWindow(windowScene: windowScene) window?.rootViewController = ViewController() window?.makeKeyAndVisible() (edited) 얘네를 남겨두고 스토리보드에 작업해봤자 소용없음! 주의!! IBOutlet과 IBAction의 차이점? Action : 버튼의 동작을 정의 Outlet : 버튼의 속성을 정의 오늘 결과물![결과물](/Users/home/Documents/dev/ghblog/source/images/스크린샷 2019-11-21 오후 7.48.57.png)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}]},{"title":"OOP & Access Control","slug":"19","date":"2019-11-19T01:48:05.000Z","updated":"2019-11-20T07:17:10.160Z","comments":true,"path":"2019/11/19/","link":"","permalink":"http://yoursite.com/2019/11/19/","excerpt":"","text":"Access Control &amp; OOP 다른 모듈의 코드 또는 다른 소스 파일 등으로부터 접근을 제한하는 것 세부 구현 내용을 숨기고 접근할 수 있는 인터페이스 지정 가능 Access levels open : class에만 붙일 수 있음 struct와 enum은 public 부터 가능 public : internal : 정의 모듈의 모든 소스 파일 내에서 사용되지만, 해당 모듈 외부의 소스파일에서는 사용되지 않도록 합니다. fileprivate : 같은 클래스 파일 내에서만! private : 클래스 내에서만 사용하기 위해 범위를 제한! Nested types 프로퍼티 각각에 명시해 주는 것과, 클래스 앞에 명시해 주는 것 접근을 제한하는 범위에 차이가 있다. open 클래스여도 멤버들의 제한 레벨은 기본값이 따로 정해져있다. 클래스의 제한 수준을 따르는 것은 아님 1234567891011클래스의 제한 수준 -&gt; 멤버의 제한 수준(기본 값)Private -&gt; Fileprivate Fileprivate -&gt; Fileprivate 같은 파일 내에서만 접근 가능Internal -&gt; InternalPublic -&gt; InternalOpen -&gt; Internal private 클래스는 어차피 클래스 자체에 접근이 안되기 때문에 멤버에 제한 수준을 붙여봐야 의미없다 그런데 아예 private 클래스를 아무도 접근을 못한다면 만드는 의미가 없기 때문에 filePrivate와 비슷한 수준의 의미를 가지게 된다. 보통은 한 파일에 한 클래스를 사용하기 때문에 filePrivate 는 잘 안쓴다 Getters &amp; Setters Getter 읽어오는 애 Setter 입력하는 애 값이 변경 될 때마다, numberOfEdits가 1씩 올라감 123456789101112131415161718192021222324252627class TrackedString &#123;// var numberOfEdits = 0// private var numberOfEdits = 0 private(set) var numberOfEdits = 0 var value: String = &quot;&quot; &#123; didSet &#123; numberOfEdits += 1 &#125; &#125;&#125;let trackedString = TrackedString()trackedString.numberOfEditstrackedString.value = &quot;This string will be tracked.&quot;trackedString.numberOfEditstrackedString.value += &quot; This edit will increment numberOfEdits.&quot;trackedString.numberOfEditstrackedString.value = &quot;value changed&quot;trackedString.numberOfEdits//trackedString.numberOfEdits = 0//trackedString.numberOfEdits 예를 들면 책이 한번 개정 될때마다 개정판 번호를 올리는 그런식 접근이 안되서 함부로 수정은 안되는데, 접근 조차도 안되는 것이 문제다! 그래서 setter만 private를 걸면 직접 수정은 못한다. Getter, setter 분리하여 제한 수준 설정 가능 Enumertaion Types 다음과 같이 각 case 별로 개별적인 접근 수준 설정 불가 enum 방위2 { // fileprivate case 동 // fileprivate case 서 // fileprivate case 남 // fileprivate case 북 //} &lt;!--￼2--&gt; 코숏은 캣을 상속만 받고 아무것도 정의 하지 않음. 그래도 캣의 멤버들을 사용할 수 있음 상속 받았으니깐 Final 더 이상 상속 받을 수 없도록 하는 키워드 final class 는 상속받을 수 없음 다형성 다양한 형태로 나타날 수 있는 능력! 동일한 요청에 각기 다른 방식으로 응답할 수 있도록 만드는 것 overriding : 상위 클래스에서 상속 받은 메서드를 하위 클래스에서 필요에 따라 재정의 하는 것 overloading : 동일한 이름의 메서드가 매개 변수의 이름, 타입, 개수 등의차이에 따라 다르게 동작하는 것 Overloading 다른 파라미터 이름 다른 파라미터 타입 다른 파라미터 개수 1234567891011121314151617181920func printParameter() &#123; print(\"No param\")&#125;//func printParameter() -&gt; String &#123; // Error// print(\"No param\")//&#125;func printParameter(param: Int) &#123; print(\"Input :\", param)&#125;func printParameter(_ param: Int) &#123; print(\"Input :\", param)&#125;print(\"=====\")printParameter() // 이름이 같은 메서드가 두개라서 뭘 호출해야 할지 모르겠는 상태! 에러남printParameter(param: 1)printParameter(1) 단, 인자레이블과, 인자의 타입을 다르게 붙여주면 구분해서 사용할 수 있음 주의할 점은 a는 매개변수명이 param이고, b는 인자레이블이 param이면 에러남 구분이 안되니깐! 구분만 명확하게 되면 된다! Overriding 상속과 관련이 있다. 상속받은 메서드를 변경해서 사용하는 것 final을 클래스 앞 뿐만 아니라 클래스의 멤버 앞에 붙일수 있다. 멩버 앞의 final이 붙으면 overriding 불가능 저장 프로퍼티의 형태로는 override 사용 불가능 계산 프로퍼티는 가능 123456789101112// 저장 프로퍼티 X // override var color: UIColor = .green // 계산 프로퍼티 O override var color: UIColor &#123; get &#123; return super.color &#125; set &#123; super.color = newValue &#125; &#125; 자식 클래스에서 부모클래스의 프로퍼티를 초기화 할 수 있다. 123456class Triangle: Shape &#123; override func draw() &#123; super.draw() // 부모의 draw메서드를 실행한뒤 아래의 print 메서드 실행 print(\"draw triangle\") &#125;&#125; Q. 아래 문제를 상속을 적용해 해결해보기 12345678910111213141516171819202122232425262728293031323334// bark() 메서드를 가진 Dog 클래스를 상속받아 Poodle, Husky, Bulldog 이 서로 다르게 짖도록 구현class Dog &#123; func bark() &#123; print(\"멍멍\") &#125;&#125;class Poodle: Dog &#123; override func bark() &#123; print(\"왈왈\") &#125;&#125;class Husky: Dog &#123; override func bark() &#123; print(\"컹컹\") &#125;&#125;class Bulldog: Dog &#123; override func bark() &#123; super.bark() print(\"야옹\") &#125;&#125;let p = Poodle()let h = Husky()let b = Bulldog()p.bark()h.bark()b.bark()","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"swift","slug":"swift","permalink":"http://yoursite.com/tags/swift/"}]},{"title":"OOP","slug":"18","date":"2019-11-18T01:51:01.000Z","updated":"2019-11-18T06:29:23.316Z","comments":true,"path":"2019/11/18/","link":"","permalink":"http://yoursite.com/2019/11/18/","excerpt":"","text":"OOP value 타입 -&gt; stack 에 저장 reference 타입 -&gt; heap 에 저장 (대표적으로 class) 포인터가 저장됨, 실제 값은 heap안에! heap 은 동적 할당. stack은 처음부터 만들어질 시점이나, 크기 같은 것들이 처음부터 지정된 상태… Q. 자동차 클래스를 정의 하고, 객체 생성 할 것 123456789101112131415161718192021222324252627282930313233343536373839class Car &#123; var model = \"ionic\" var modelYear = 2019 var color = \"black\" var startUp = false var spd = 0 func drive() &#123; startUp = true print(\"부르릉~\") &#125; func park() &#123; if spd == 0 &#123; startUp = false &#125; else &#123; startUp = true print(\"차가 완전히 멈추면 끄세요!!\") &#125; &#125; func spdUp() &#123; spd += 5 &#125; func reverse() &#123; spd -= 1 &#125;&#125;let myCar = Car()myCar.drive()myCar.spdUp()myCar.reverse()myCar.reverse()myCar.reverse()myCar.reverse()myCar.reverse()print(myCar.spd) Class initialize 초기화(init)가 불필요한 경우 : 모든 저장 프로퍼티에 초기값이 설정되어 있음 123456789101112class Dog1 &#123; let name = \"Tory\" let color = \"Brown\" func bowwow() &#123; print(\"Dog1 Bowwow!\") &#125;&#125;let tory = Dog1()// let tory = Dog1.init()tory.bowwow() 초기화(init)가 필요한 경우 : 저장 프로퍼티 중 하나 이상이 초기값 미설정됨 1234567891011121314151617181920// 클래스 내부에서 init 메서드를 이용하여, 초기화class Dog2 &#123; let name: String let color: String init() &#123; name = \"Tory\" color = \"Brown\" &#125; func bowwow() &#123; print(\"Dog2 Bowwow!\") &#125;&#125;let tory2 = Dog2()tory2.bowwow()// 근데 이렇게 하면 Dog2 클래스의 속성을 변경할 수가 없음 123456789101112131415161718192021// 파라미터를 통해 초기화 하는 경우!class Dog3 &#123; let name: String let color: String init(name: String) &#123; self.name = name color = \"Brown\" &#125; init(name: String, color: String) &#123; self.name = name self.color = color &#125; func bowwow() &#123; print(\"Dog3 Bowwow!\") &#125;&#125;var tory3 = Dog3(name: \"Tory\")var tory4 = Dog3(name: \"Tory\", color: \"White\") Q. 전 단계에서 만든 자동차 클래스의 초기값을 제거하고 Init 메서드를 이용해 생성하기 123456789101112131415161718class Car &#123; var model : String var modelYear : Int var color : String var startUp : Bool var spd : Int init(model: String, modelYear: Int, color: String) &#123; self.model = model self.modelYear = modelYear self.color = color &#125; // 중략 // . // . // . // . let myCar = Car(model: \"ionic\", modelYear: 2019, color: \"white\") Lazy Stored Property 초기값이 인스턴스의 생성이 완료 될 때 까지도 알 수 없는 외부 요인에 의존할 때 초기값이 복잡하거나 계산 비용이 많이 드는 설정을 필요로 할 때 필요한 경우가 제한적일 때 Class ⭕️ Structure ⭕️ Enumeration ❌ 외부 요인이나 다른 설정에 기반 123456789101112// area 변수는 width와 height에 의존적임. 그렇기 때문에 처음부터 초기화 해줄 수가 없음class BasicStoredProperty &#123; var width = 10.0 var height = 20.0 // var area = 200.0// var area = self.width * self.height lazy var area = self.width * self.height&#125;// 처음부터 self로 초기화도 못해줌. self는 객체가 생성된 시점에 사용할 수 있음 이럴때 lazy를 사용한다. 계산 비용이 많이 드는 상황 예를 들면 당장 앱을 실행하자마자 필요한 부분이 아닌데 lazy 없이 그냥 선언 되어 있으면 앱이 그 오래걸리는 부분까지 다 처리하고 실행되느라 늦게 켜질 수 있음. 이럴때도 사용한다. 필요한 경우가 제한적인 상황 area가 필요한 경우가 비율로 따지면 약 10%정도 되고, 나머지 90%의 상황에서는 필요하지 않다면 지연하여 생성하는 것이 좋다. Computed Property 자료를 저장하지 않고 매번 호출할 때마다 새로 계산 Class ⭕️ Structure ⭕️ Enumeration ⭕️ 123456789101112131415161718192021222324252627282930313233343536373839class ComputedProperty &#123; var width = 5.0 var height = 5.0 // 계산을 하긴 하지만, 초기화 할 때만 한번 하고, 변경 해주기 전까지는 저장 됨 lazy var lazyArea = width * height // 매번 호출 할 때마다 새로 계산함 var area: Double &#123; return width * height &#125; // Stored + Computed get(read), set(write) private var _koreanWon = 0.0 var wonToDollar: Double &#123; get &#123; return _koreanWon / 1136.5 &#125; set &#123; _koreanWon = newValue &#125; &#125;&#125;var computed = ComputedProperty()computed.areacomputed.lazyAreacomputed.width = 10computed.areacomputed.lazyAreacomputed.lazyArea = 50.0computed.lazyAreacomputed.width = 20computed.height = 20computed.areacomputed.lazyArea Property Observer Class ⭕️ Structure ⭕️ Enumeration ❌ willSet은 값이 변경되기 직전 호출 didSet은 값이 변경된 후 호출 12345678910111213class PropertyObserver &#123; var height = 0.0 var width = 0.0 &#123; willSet &#123; print(\"willSet :\", width, \"-&gt;\", newValue) &#125; didSet &#123; print(\"didSet :\", oldValue, \"-&gt;\", width) height = width / 2 &#125; &#125;&#125; Type Property Shared Lazily Initialized Class ⭕️ Structure ⭕️ Enumeration ⭕️ Override 불가 클래스에서만 사용가능, computed property 형태로 사용, 서브클래스에서 override 가능 모든 객체의 프로퍼티를 공유해야 할 때 사용한다. 편하기도 함. 타입에 직접 접근이 가능하니깐 12345678910111213141516171819class TypeProperty &#123; static var unit: String = \"cm\" var width = 5.0&#125;let square = TypeProperty()square.widthlet square1 = TypeProperty()square1.width = 10.0square1.widthTypeProperty.unitprint(\"\\(square.width) \\(TypeProperty.unit)\")print(\"\\(square1.width) \\(TypeProperty.unit)\")TypeProperty.unit = \"m\"print(\"\\(square.width) \\(TypeProperty.unit)\")print(\"\\(square1.width) \\(TypeProperty.unit)\") Equatable, Identical12345678910111213141516// 동등 연산자1 == 12 == 1\"ABC\" == \"ABC\"class Person &#123; let name = \"이순신\" let age = 30&#125;let person1 = Person()let person2 = Person()//person1 == \"이순신\" // 에러//person1 == person2 // 에러 Q. 왜 비교 연산자를 사용할 수 없을까요? 둘다 에러가 나는디…? 왜 못쓰는 걸까 같은 타입이지만 각 person이 가지고 있는 속성중, 무엇을 비교할 것인지 명확하지 않기 때문에 에러가 난다. Equatable Protocol123456789101112class User: Equatable &#123; var name = \"이순신\" let age = 30 static func ==(lhs: User, rhs: User) -&gt; Bool &#123; return lhs.name == rhs.name &#125;&#125;let user1 = User()var user2 = User()user1 == user2 이번에는 무엇을 비교할지 프로토콜로 정의를 했기 때문에 비교 연산자를 사용할 수 있다. Identical1234user1.nameuser2.nameuser1 == user2user1 === user2 // false 뭔가 다른게 눈에 띈다. 비교연산자가 세개 붙었음 이건 왜 false 일까? === : 두 상수 또는 변수가 동일한 인스턴스를 가르키는 경우 true 반환","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift, OOP, iOS","slug":"Swift-OOP-iOS","permalink":"http://yoursite.com/tags/Swift-OOP-iOS/"}]},{"title":"객체지향프로그래밍 (Object Oriented programming)","slug":"OOP","date":"2019-11-15T06:34:26.000Z","updated":"2019-11-15T08:21:02.050Z","comments":true,"path":"2019/11/OOP/","link":"","permalink":"http://yoursite.com/2019/11/OOP/","excerpt":"","text":"참고 : https://jeong-pro.tistory.com/95 객체지향 프로그래밍(OOP)프로그래밍에서 필요한 데이터를 추상화하여, 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법 장점 코드 재사용의 용이함 : 남이 만든 클래스를 가져와서 이용할 수 있고, 상속을 통해 해당 클래스를 확장하여 사용할 수 있음 유지보수가 쉬움 : 절차지향 프로그래밍과 비교하면, 코드를 수정해야할 때 일일이 찾아서 수정해야 하지만, 객체지향프로그래밍은 수정해야 할 부분이 *클래스 내부에 있기 때문에 해당 부분만 수정하면 된다. 클래스 내부 : [멤버 변수(상태를 정의한 것) 혹은 메서드(행위를 정의한 것)] 대형 프로젝트에 적합함 : 클래스 단위로 *모듈화하여 개발이 가능하므로, 업무 분담이 비교적 쉽다. 모듈? : 규모가 큰 것을 여러 개로 나눈 조각 정도로 이해하자 그렇지만 모듈이 되려면 다음의 특징들을 만족해야 하나의 모듈이라 할 수 있다. 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위(unit)이다. 유일한 이름을 가져야 한다. 독립적으로 컴파일이 가능하다. 모듈에서 또 다른 모듈을 호출할 수 있다. 다른 프로그램에서도 모듈을 호출할 수 있다. 모듈은 완전한 독립 프로그램이고, 다양한 크기의 집합에 대해서 모듈이라고 부를 수 있다. 참고 : [네이버 지식백과] 모듈화 (쉽게 배우는 소프트웨어 공학, 2015. 11. 30., 김치수) 단점 처리 속도가 상대적으로 느림 객체가 많으면 용량이 커질 수 있음 설계 단계에서 많은 시간과 노력이 필요함 OOP의 특징1. 클래스 + 인스턴스 (객체) 클래스 : 어떤 문제를 해결하기 위한 데이터를 만들기 위하여 추상화를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 메서드로 정의 한 것 설계도에 비유하기도 한다. 속성은 변수, 행위는 메서드로 정의한다. 인스턴스 : 클래스에서 정의 한 것을 토대로 실제 메모리상에 할당된 것. 실제 프로그램에서 사용되는 데이터 2. 추상화 공통의 속성이나 행위를 묶어 이름을 붙이는 것을 말한다. 객체지향적 관점에서는 클래스를 정의하는 것을 바로 추상화라고 할 수 있다. 예를 들어. 사자, 코끼리, 강아지, 고양이, 비둘기, 토끼 라는 객체가 존재한다고 하면,이들의 공통 된 속성이나 행위를 묶어보면 ‘동물’ 혹은 ‘생물’이라는 이름을 붙일 수 있다. 3. 캡슐화 사전에 동물 클래스를 정의했다면, 나중에 동물 클래스를 구현해야 할 때 재사용이 가능하다. 객체 지향 프로그래밍에서는 기능(행위), 특성(속성)을 클래스에 정의한다. 동물 객체가 맡은 역할을 수행하기 위한 하나의 목적을 한 곳에 정의한다고 생각하자. 그런데 동물 클래스를 사용하는 입장에서는 동물 클래스로 무엇을 할 수 있는지에대해서만 알면 그 의미는 충분하다. 굳이 동물 클래스가 어떻게 작동하는지 알 필요도 없거니와, 알기도 힘들것이다. 자동차를 운전하는 사람은 ‘운전을 한다’ 라는 목적 하나만 놓고 보면 운전 방법만 알면 된다.자동차가 어떤 방식으로 작동하여 운행이 가능해 지는 것인지는 몰라도 ‘운전을 한다’ 라는 목표는 충족 할 수 있는 것이다. 그리고 개인이 마음대로 자동차를 튜닝하여 사용하는 것은 불법이다. 안전상의 문제가 발생할 수 있기 때문이다. 자동차의 외관이나 내부 역시, 가려져 있기 때문에 겉으로 보기만 해서는 어느 부분이 어떻게 움직이는지, 볼 수 없다. 정비소나 차고에서 일부러 뜯어보기 전까지는 내부를 볼 수도 없고, 마음대로 튜닝 할 수도 없다. 이러한 개념은 ‘정보의 은닉’이라는 개념에 적용할 수 있다. 캡슐화의 목적 중 하나는 함부로 내부에 접근하지 못하게 하는 것이다. 이유는 상기와 같다. 4. 상속 이미 ‘동물’ 클래스와 ‘강아지’ 클래스가 있는 상황이라고 가정하자 나는 ‘비글’ 클래스를 만들어야 한다. ‘비글’이 가지고 있는 속성과 행위를 처음부터 정의하는 것은 비효율적인 행동이다. 이미 ‘비글’이라면 가지고 있는 속성과 행위가 정의되어 있는 ‘동물’과 ‘강아지’ 클래스가존재하고 있고, 나는 그것의 존재를 알고 있기 때문이다. 그래서 ‘강아지’ 클래스를 가져다가 나의 목적에 맞게 조금만 고쳐서 ‘비글’을 만들고자 한다. 비글 이라면 가지고 있는 속성은 귀가 두 개, 포유류 식육목의 개과에 속한다는 것, 다리가 네 개 등등 있지만 상기한 속성들은 ‘강아지’가 가지고 있는 속성과 동일하다. 그래서 강아지 클래스를 가져다가 쓸 것이다. 그런데 비글 = 강아지 라는 공식은 성립하지만, 강아지 = 비글 이라는 공식은 맞지 않다. 포메라니안도 강아지고, 푸들도 강아지이기 때문이다. 위 공식이 성립하지 않는 이유는 비글이 강아지와 공통 된 속성을 가지고 있긴 하지만 비글은 비글만의 특징이 있다. 프로그래밍에서 ‘비글’을 만들 때 ‘강아지’의 속성과 행위를 가져다가 쓰는 것을 상속 이라고 한다. 이러한 과정의 방향성을 살펴 보면 강아지 -&gt; 비글 이다. 강아지의 속성을 비글에게 물려’주었고’, 비글은 강아지의 속성을 물려’받았다’ 그래서 강아지는 이 상황에서 ‘부모 클래스’, 비글은 ‘자식 클래스’이다. 사실 강아지 역시 ‘동물’의 자식 클래스이다. 4. 다형성 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석 될 수 있는 것이다. 오버라이딩, 오버로딩 오버라이딩은 부모 클래스의 메서드(행위)를 상속 받아 다른 기능을 정의 하는 것을 말한다. 이를 이용하면, 하나의 부모 클래스를 상속 받는 여러 자식 클래스들이 같은 이름에 다른 기능을 하는 메소드를 정의하고 사용할 수 있다. 오버로딩은 하나의 클래스에서 같은 이름의 메소드들을 여러 개 가질 수 있게 한다. 단, 인자 값은 달라야 한다. 인자들의 타입이나 갯수가 다르면 메소드 이름이 같더라도 어떤 메소드를 호출 할지 컴파일러가 알 수 있기 때문이다. 유사한 일을 수행하면서 인자만 다른 메소드들을 각자 다른 이름을 붙이면 사용하기가 매우 불편할 것이다.","categories":[{"name":"Homework","slug":"Homework","permalink":"http://yoursite.com/categories/Homework/"}],"tags":[{"name":"Swift, iOs, develop, OOP, coding","slug":"Swift-iOs-develop-OOP-coding","permalink":"http://yoursite.com/tags/Swift-iOs-develop-OOP-coding/"}]},{"title":"Closure / Code Snippets","slug":"15","date":"2019-11-15T01:39:33.000Z","updated":"2019-11-15T05:28:04.495Z","comments":true,"path":"2019/11/15/","link":"","permalink":"http://yoursite.com/2019/11/15/","excerpt":"","text":"Code Snippets 코딩 할 때 자주 쓰는 구문들을 편하게 쓸수 있도록 지원하는 기능. 개인설정도 가능하고, 이미 정해져있는 snippets도 있다 editor -&gt; create code snippet 코드를 적고, 드래그 한 뒤 지정하면 됨 만들때 Completion은 코드를 사용할 때 자동완성 목록에 뜨는 코드 Availability는 코드의 범위(?), 성격(?) closure 일회용 함수를 작성할 수 있는 구문 일회용 함수란? 한번만 사용할 구문들의 집합이면서, 그 형식은 함수로 작성해야 하는 제약이 있을 때 사용할 수 있는 함수 그렇기 때문에 이름을 생략할 수 있어서 익명(Anonymous) 함수라고도 한다. 스위프트에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나에 해당한다. 전역 함수 : 이름이 있으며, 주변 환경에서 캡처할 어떤 값도 없는 클로저 중첩 함수 : 이름이 있으며, 자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저 클로저 표현식 : 이름이 없으며 주변 환경으로부터 값을 캡처할 수 있는 경량 문법으로 작성된 클로저 클로저 표현식 클로저는 일반 함수의 선언식에서 함수명, func 키워드를 뺀 나머지 부분만 작성하는 경량 문법을 사용한다. 123&#123; (매개변수) -&gt; 반환타입 in 실행구문&#125; 일반적인 함수의 실행부는 중괄호 { 부터 시작하지만 클로저는 시작부터 이미 있으므로 in 키워드 다음부터 클로저 표현식의 실행 블록이 작성된다. 실행 블록의 작성이 끝나면 다시 중괄호 } 로 닫는다. 이는 클로저 표현식 전체의 완성을 의미한다. 123&#123; () -&gt; () in print(\"클로저가 실행됩니다\")&#125; 위의 예제는 입력 값과 반환 값이 없는 함수이다. 일반 함수와 달리 반환 값이 없으면 생략 하는 것이 아니라 빈 괄호로 표기해준다. 위의 예시 코드들과는 달리 한 줄로 작성해도 무방하다. 클로저 표현식은 대부분 파라미터로 함수를 넘겨주어야 할 때 사용하지만, 직접 실행해 볼 수도 있다. 실행하는 방법은 두가지가 있다. 1. 상수나 변수에 클로저를 할당한 다음 실행하는 방법 12345let f = &#123; () -&gt; Void in print(\"클로저가 실행됩니다\")&#125;f() 상수에 클로저를 할당하고, 이 상수에 함수호출 연산자 ( )를 추가하여 실행하는 방법이다. 2. 클로저 표현식을 할당받는 상수 f 마저 생략하고 실행하는 방법 123(&#123;() -&gt; Void in print(\"클로저가 실행됩니다\") &#125;)() 클로저 표현식 전체를 소괄호로 감싸고, 맨뒤에 함수 호출 연산자 ( )를 붙이면 완성 클로저 전체를 괄호로 감싸지 않으면 컴파일러에서는 이 구문을 클로저 표현식의 정의가 아니라 그 실행값을 변수나 상수에 할당하려는 의도로 해석하여 오류를 발생시키므로 주의! 12345let c = &#123; (s1: Int, s2: String) -&gt; Void in print(\"s1: \\(s1), s2:(s2)\")&#125;c(1, \"closure\") // s1:1, s2:closure 상수 c 에 Int형 매개변수 s1과 String형 매개변수 s2를 할당받아 출력하는 클로저 아래와 같이 간소화 할 수 있다. 123(&#123; (s1: Int, s2: String) -&gt; Void in print(\"s1: \\(s1), s2:(s2)\")&#125;) (1, \"closure\") // s1:1, s2:closure Closure Syntax 배열은 정렬 함수인 sort(by:) 를 이용하여, 큰 순서나, 작은 순서. 혹은 임의대로 정렬 할 수 있다. 정렬 기준을 잡기 위해서는 특정 형식을 따르는 함수를 정의하여 인자 값으로 넣어주어야 함 두 개의 인자값을 입력받고, 크기를 비교하여 Bool 타입으로 반환하는 형식! (의 함수) 배열을 정렬하는 메소드로 클로저를 이해해보자. 첫 번째 인자값이 두 번째 인자값보다 앞쪽에 와야한다고 판단되면 true를, 아니면 false 이 과정을 함수로 작성하면 12345678910111213// 정렬할 배열var value = [1, 9, 5, 7, 3, 2]// s1이 크면 true, 아니면 flasefunc order(s1: Int, s2: Int) -&gt; Bool &#123; if s1 &gt; s2 &#123; return true &#125; else &#123; return false &#125;&#125; value.sort(by: order) // 9, 7, 5, 3, 2, 1 sort 메소드는 true가 반환되면, 두 인자값의 위치를 변경하지 않고, false면 변경함 이 기준에 따라 정렬이 실행된 결과 9가 가장 앞으로 오게 됨 이걸 클로져로 작성하면.. 12345678value.sort(by: &#123; (s1: Int, s2: Int) -&gt; Bool in if s1 &gt; s2 &#123; return true &#125; else &#123; return false &#125;&#125;) 더 요약하면.. 123&#123; (s1: Int, s2: Int) -&gt; Bool in return s1 &gt; s2&#125; if 구문이 생략 되고 바로 return 이것을 한줄로 표현하면.. 1value.sort(by: &#123;(s1: Int, s2: Int) -&gt; Bool in return s1 &gt; s2&#125;) 그런데 여기서 더 줄일 수 있다. return 타입을 생략 할 수 있다. return 타입을 생략하면, 컴파일러는 클로저 구문을 해석하여 return 값을 찾고 이 return 값의 타입을 추론하여 클로저의 반환 타입을 알아서 정의한다. 1value.sort(by: &#123;(s1: Int, s2: Int) in return s1 &gt; s2&#125;) ‘-&gt; Bool’ 이 생략된 구문임 위의 실행식은 s1 &gt; s2 인데, 이는 비교구문이기 때문에 반환값은 true 아니면 false임 이 과정을 거쳐 컴파일러가 반환 값의 타입을 추론할 수 있음 그런데 반환 값의 타입 추론이 가능하다면, 매개변수의 타입도 추론 가능할 것 같다! 생략 된 매개변수의 타입은 대입 되는 값에 따라 컴파일러가 알아서 추론해낼것이다. 1value.sort(by:&#123;s1, s2 in return s1 &gt; s2&#125;) 그런데! 이번에는 매개변수마저 생략해 버릴 수 있다. 매개변수가 생략되면 $0, ,1 , 2…와 같은 이름으로 할당 된 내부 상수를 이용할 수 있다. 남은 건 실행구문인 in 인데 이녀석도 생략 할 수 있다 이미 실행 구문과 선언부를 분리할 필요가 없어졌기 때문이다. 1value.sort(by:&#123;return $0 &gt; $1&#125;) 사실 클로져보다 더 간결하게 줄일 수 있다. 이것을 연산자 함수라고 부른다 연산자 만을 이용하여 의미하는 바를 정확히 나타낼 수 있을 때 사용된다. 이를 이용하여 최종적으로 sort 메소드를 정리해보면 1value.sort(by: &gt; ) 부등 비교 연산자는 본래 두 가지 인자가 필요하고, 이를 첫 번째 인자와, 두 번째 인자로 해석하면 위와 같은 표현이 가능한 것이다. Q.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"Swift, iOS","slug":"Swift-iOS","permalink":"http://yoursite.com/tags/Swift-iOS/"}]},{"title":"Optional / Enumeration","slug":"14","date":"2019-11-14T01:33:27.000Z","updated":"2019-11-14T07:29:53.064Z","comments":true,"path":"2019/11/14/","link":"","permalink":"http://yoursite.com/2019/11/14/","excerpt":"","text":"Optional Optional은 값이 없을 수 있는 상황에 사용 옵셔널 타입은 2가지 가능성을 지닌다 값을 전혀 가지고 있지 않음 nil 값이 있으며, 그 값에 접근하기 위해 옵셔널을 벗겨 낼 수 있음 값이 없는 것과 0인 것의 차이? 0 은 0이라는 값이 엄연히 존재하는 것임. nil은 진짜 값이 ‘없는’ 것 숫자로 바꾸니까 int형으로 바뀌는 이유는? 123 이라는 문자열은 정수형으로 바꿀 수 있지만, 다른 문자열은 숫자로 못바꿀 수도 있는 ‘가능성’이 있기 때문에 형변환을 하면 옵셔널이 된다. 그런데 Double 타입은 비록 소수부는 사라질 지언정 int로 바꾸면 무조건 int로 바뀔 수 있기 때문에 옵셔널이 아님 123456let possibleNumber = \"123\"var convertedNumber = Int(possibleNumber)type(of: convertedNumber)type(of: Int(3.14))// Optional&lt;Int&gt;.type 선언 방법 12var optionalType1: String?var optionalType2: Optional&lt;Int&gt; 옵셔널 Int와 Int는 엄연히 다른 타입이다. 1234var nonOptionalInt = 10var optionalInt : Int? = 100nonOptionalInt + optionalInt // 에러 그렇기 때문에 연산도 할수없고, unoptional 타입의 변수에는 nil값을 할당할 수도 없다. 옵셔널 변수의 초기화는 옵셔널이 아닌 변수와 똑같다. Optional Binding and Forced UnwrappingOptional Binding 조건문을 이용하여 래핑을 벗겨내는 방식이다. 12345678let nilValue: String? = nillet someValue = \"100\"if let number = Int(someValue) &#123; print(\"\\\"\\(someValue)\\\" has an integer value of \\(number)\")&#125; else &#123; print(\"Could not be converted to an integer\")&#125; nil이면 아래의 구문을 출력하고, 값이 있으면 위의 구문을 출력한다. 옵셔널 바인딩을 사용 할 때도 변수, 상수의 법칙은 지켜진다. 123456789101112131415var optionalStr: String? = &quot;Hello, Optional&quot;// letif let optionalStr = optionalStr &#123;// optionalStr += &quot;😍&quot; optionalStr&#125; else &#123; &quot;valueless string&quot;&#125;// varif var str = optionalStr &#123; str += &quot;😍&quot; str&#125; Let 이기 때문에 optionalStr 의 값을 변경할 수 없다. 아래의 // var 부분은 변경 가능 Forced Unwrapping 끝에 !를 붙임으로서 강제로 언래핑하는 방식! 1234567891011121314if convertedNumber != nil &#123;// print(&quot;convertedNumber has an integer value of \\(convertedNumber).&quot;) print(&quot;convertedNumber has an integer value of \\(convertedNumber!).&quot;)&#125;print(convertedNumber)print(convertedNumber!)// Forced unwrap of nil valueconvertedNumber = nilconvertedNumber//convertedNumber! Q. 이렇게 하면 간단한데 왜 바인딩 같은 복잡한 방식을 사용할까? nil 값을 가지고 있는 옵셔널을 강제로 언래핑한다면 오류가 발생하니깐! 그렇기 때문에 반드시 nil 값이 들어가지 않을것이다! 라고 확신이 가능 할 때만 사용하는것이 좋다. 바인딩을 이용하여 안전하게 벗겨내는 것을 권장한다. IUO (Implicitly Unwrapped Optionals) 위에서는 뒤에 ! 를 붙여서 언래핑하였지만, 이번엔 미리 변수의 선언부에 붙여서 사용한다! ? 대신 !를 붙여서 선언하는 것인데, 옵셔널 타입이지만 일반 타입의 변수에 할당이 가능하다. 1234567var assumedString: String! = \"An implicitly unwrapped optional string.\"let implicitString: String = assumedStringlet stillOptionalString = assumedStringtype(of: assumedString) // 옵셔널이지만 일반 String 변수에 할당 가능type(of: implicitString)type(of: stillOptionalString) 옵셔널 타입을 사용해야 하지만 반드시 nil이 아니라는 보장이 있을 때 사용한다. Nil value를 체크 해야 할 일이 생길 경우에는 그냥 일반적인 옵셔널을 사용한다. 프로퍼티 지연 초기화에 많이 사용한다. (뭔진 모르겠지만) Nil-coalescing Operator123456789optionalStr = nil// nil이 아니라는 걸 확인한 후 변수에 할당!var result = \"\"if optionalStr != nil &#123; result = optionalStr!&#125; else &#123; result = \"This is a nil value\"&#125; 옵셔널 바인딩 방식인데 코드가 꽤 귀찮게 생겼다. 아래와 같이 간단하게 써보자 123let anotherExpression = optionalStr ?? \"This is a nil value\"print(optionalStr)print(anotherExpression) ?? 연산자를 사용하여 언래핑을 할 수 있다. 삼항 연산자 ? 와 헷갈릴 수 있지만, 엄연히 다른 연산자이다. 그렇지만 비슷하게 사용할 수 있다. 어떤 경우에 사용할까? let defaultColorName = &quot;red&quot; var userDefinedColorName: String? var colorNameToUse = userDefinedColorName ?? defaultColorName print(colorNameToUse) userDefinedColorName = &quot;green&quot; colorNameToUse = userDefinedColorName ?? defaultColorName print(colorNameToUse) 12345678910111213- 값이 nil 일때 할당할 값을 미리 따로 지정해 놓고 사용한다!### optionalStr ?? &quot;This is a nil value&quot; 를 3항 연산자로 바꿔보기```swiftlet answer = optionalStr != nil ? optionalStr! : &quot;This is a nil value&quot; Optional Chaining 하위 property에 옵셔널 값이 있는지 연속적으로 확인하면서, 중간에 하나라도 nil이 발견된다면 nil이 반환되는 형식 123456789class Persion &#123;ver residence: Residence?&#125;class Residence &#123;var numberOfRooms = 1&#125;let sangmin = person() Q. 아래 두 옵셔널의 차이점? 12var optionalArr1: [Int]? = [1,2,3]var optionalArr2: [Int?] = [1,2,3] 위에는 옵셔널 array 이기 때문에 optionalArr1 = nil 이 가능하다. 배열 자체를 nil 할당 가능 아래는 배열 내부 요소의 값들의 타입이 옵셔널 int. 즉 nil 값을 append 해 줄 수 있음 Optional Function Types어렵,,, 123var aClosure: (() -&gt; Int?)? = &#123; return 10&#125; Q. 연습2개의 정수를 입력받아 Modulo 연산(%)의 결과를 반환하는 함수를 만들되, 2번째 파라미터와 결과값의 타입은 옵셔널로 정의, 두 번째 파라미터 입력값으로 nil 이나 0이 들어오면 결과로 nil을 반환하고, 그 외에는 계산 결과 반환123456789func moduloValue (a: Int, b: Int?) -&gt; Int? &#123; var result: Int? if b != nil &#123; result = a % b! &#125; else if b == 0 || b == nil &#123; result = nil &#125; return result&#125; Enumeration 연관 된 값의 그룹에 대해 공통 된 타입을 정의 한뒤, type-safe 하게 해당 값들을 사용 가능..? 123456enum CompassPoint &#123; case north case south case east case west&#125; 보통은 12let north = \"north\"let south = \"south\" 요렇게 쓰는데, 잘못 입력 할 수도 있고, 남들이 연관있는 값인지 모를 수도 있음 하지만 enum을 사용하면, 안전하게 사용할 수 있다. 어차피 네가지 밖에 없으니 서로 연관 값인것도 알 수 있고, 오타도 안날거임 12345678enum Planet &#123; case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune, pluto&#125;var directionToHead1 = CompassPoint.westdirectionToHead1 = .eastvar directionToHead2: CompassPoint = .north Matching Enumeration Values switch 와 같이 잘 쓰인다. 123456789101112let directionToHead = CompassPoint.southswitch directionToHead &#123;case .north: print(\"Lots of planets have a north\")case .south: print(\"Watch out for penguins\")case .east: print(\"Where the sun rises\")case .west: print(\"Where the skies are blue\")&#125; Associated ValuesQ. enum Month { case jan, feb } 정의하되 2월은 윤년인지 아닌지 정보를 저장할 수 있도록 구현123456789enum Month &#123; case jan, feb(Bool)&#125;let february = Month.feb(false)switch february &#123;case .jan: breakcase .feb(let isLeafYear): print(isLeafYear)&#125; Raw Value 해당 enum에서 반드시 고유한 값이어야 함 Strings, Characters, or any of the Integer or Floating-point number types 12345678910111213141516171819202122enum Weekday: Int &#123; case sunday, monday, tuesday, wednesday, thursday, friday, saturday&#125;Weekday.wednesdayWeekday.wednesday.rawValueenum WeekdayName: String &#123; case sunday, monday, tuesday, wednesday, thursday, friday, saturday&#125;WeekdayName.mondayWeekdayName.monday.rawValueenum Gender: String &#123; case male = \"남자\", female = \"여자\", other = \"기타\"&#125;Gender.maleGender.male.rawValue Q. 학점(A, B, C, D, F)을 enum 으로 표현하고 각 케이스에 알맞은 0.0 ~ 4.0 까지의 값 부여123456enum GradeScore: Double &#123; case A = 4.0, B = 3.0, C = 2.0, D = 1.0, F = 0.0&#125;GradeScore.AGradeScore.A.rawValue Implicitly Assigned Raw Values12345678num WeekdayAgain: Int &#123; case sunday = 5, monday, tuesday, wednesday, thursday, friday, saturday// case sunday, monday = 100, tuesday = 101, wednesday, thursday, friday, saturday// case sunday = 1, monday = 1, tuesday = 2, wednesday, thursday, friday, saturday&#125;WeekdayAgain.wednesdayWeekdayAgain.wednesday.rawValue 처음 sunday에 rawvalue를 5를 할당했기 때문에 순서대로 가서 8을 반환한다. Initializing from a Raw Value Raw vlaue를 이용하여 초기화 가능! 123456789enum PlanetIntRaw: Int &#123; case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune, pluto&#125;PlanetIntRaw(rawValue: 5)PlanetIntRaw(rawValue: 7)PlanetIntRaw(rawValue: 0) // nilPlanetIntRaw(rawValue: 15) // nil 여기서 enum이 옵셔널의 속성을 가지고 있음을 알 수 있다. nil을 반환하니깐. 옵셔널 바인딩을 통해 ㅅㅏ용한다. 12345678910if let somePlanet = PlanetIntRaw(rawValue: positionToFind) &#123; switch somePlanet &#123; case .earth: print(\"Mostly harmless\") default: print(\"Not a safe place for humans\") &#125;&#125; else &#123; print(\"There isn't a planet at position \\(positionToFind)\")&#125; Nested 내부에 함수를 설정하여 사용도 할 수 있다. 1234567891011121314151617enum Device: String &#123; case iPhone, iPad, tv, watch func printType() &#123; switch self &#123; case .iPad, .iPhone, .tv: print(\"device :\", self) case .watch: print(\"apple Watch\") &#125; &#125;&#125;let iPhone = Device.tviPhone.printType()// tv 출력 enum 안에 enum 중첩 사용 123456789101112131415161718192021222324252627enum Wearable &#123; enum Weight: Int &#123; case light = 1 case heavy = 2 &#125; enum Armor: Int &#123; case light = 2 case heavy = 4 &#125; case helmet(weight: Weight, armor: Armor) case boots func info() -&gt; (weight: Int, armor: Int) &#123; switch self &#123; case .helmet(let weight, let armor): return (weight: weight.rawValue * 2, armor: armor.rawValue * 5) case .boots: return (3, 3) &#125; &#125;&#125;Wearable.bootsvar woodenHelmet = Wearable.helmet(weight: .light, armor: .heavy)woodenHelmet.info() Mutating enum 타입 내부 함수에서 자기 자신의 값을 변경해야 할 경우 mutating 키워드가 필요하다. Q. on 과 off 값을 가진 enum 타입 RemoteControl 을 정의하고, 그 내부에 호출 시마다 on, off 값을 바꿔주는 함수 구현1234567891011121314151617enum RemmoteControl &#123; case on, off mutating func switching() &#123; switch self &#123; case .on: self = .off case .off: self = .on &#125; &#125;&#125;var remocon = RemmoteControl.onremocon.switching()remocon.switching()","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"swift, iOS","slug":"swift-iOS","permalink":"http://yoursite.com/tags/swift-iOS/"}]},{"title":"배열 / 집합 / 딕셔너리","slug":"13","date":"2019-11-13T01:43:31.000Z","updated":"2019-11-13T10:40:22.642Z","comments":true,"path":"2019/11/13/","link":"","permalink":"http://yoursite.com/2019/11/13/","excerpt":"","text":"Collection array - 순서가 있는 값들의 모음 set - 순서가 없는, 정렬 되지 않은 특정 값 (unique values) dictionary - 키와 값의 쌍으로 정렬되지 않은 값들의 모음 배열 (Array) Zero-based integer Index 인덱스가 0부터 시작 대부분의 프로그래밍 언어들은 0부터 시작한다. 상수나 변수처럼 배열에 저장된 타입으로 타입추론이 된다. 초기화1234567891011// Type Annotationlet strArray1: Array&lt;String&gt; = [\"apple\", \"orange\", \"melon\"]let strArray2: [String] = [\"apple\", \"orange\", \"melon\"]// Type Inferencelet strArray3 = [\"apple\", \"orange\", \"melon\"]let strArray4 = Array&lt;String&gt;(repeating: \"iOS\", count: 5)// [ios, ios, ios, ios, ios] 와 같은 뜻// Error//let strArray5 = [\"apple\", 3.14, 1] // 같은 타입의 값이 아니기 때문에 에러 Q. String 타입과 Int 타입으로 각각 자료가 없는 상태인 빈 배열을 만들어보세요.12var strEmpty: [String] = []var intEmpty: [Int] = [] Q. Double 타입은 Type Annotation, Bool 타입은 Type Inference 방식으로 각각 임의의 값을 넣어 배열을 만들어보세요.12var dou: [Double] = [1.2, 3.4, 5.6]var boo = [true, false, false, true] Number of Elements123456789let fruits = [\"Apple\", \"Orange\", \"Banana\"]let countOfFruits = fruits.count // 요소의 갯수를 출력// fruits가 비어있지 않으면, 몇 개의 요소가 있는지 출력, 비어있으면 empty array 출력if !fruits.isEmpty &#123; print(\"\\(countOfFruits) element(s)\")&#125; else &#123; print(\"empty array\")&#125; Retrieve an Element1234567891011121314151617// 0 1 2 endIndexfruits = [\"Apple\", \"Orange\", \"Banana\"]fruits[0]fruits[2]//fruits[123] =&gt; 값의 범위를 벗어난 위치를 참조하려 했기 때문에 오류fruits.startIndex // 0fruits.endIndex // 마지막 요소의 바로 다음 위치를 가리킨다. 여기서는 3이 나온다fruits[fruits.startIndex] // Apple 참조fruits[fruits.endIndex - 1] // Banana 참조fruits.startIndex == 0fruits.endIndex - 1 == 2 Searching12345678910111213141516171819202122232425262728let alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\"]// A 가 있는지 검색if alphabet.contains(\"A\") &#123; print(\"contains A\")&#125;// 클로저 사용. 뭔 소린지는 아직 모르겠음if alphabet.contains(where: &#123; str -&gt; Bool in // code... return str == \"A\"&#125;) &#123; print(\"contains A\")&#125;// 특정 값의 위치를 알 고 싶을 때if let index = alphabet.firstIndex(of: \"D\") &#123; print(\"index of D: \\(index)\")&#125;// 이런 경우에는 옵셔널이라는 개념이 사용된다.// 왜 옵셔널이라는 값이 사용될까? if로 감싼것 빼고는 차이가 없는데//let idx1 = alphabet.firstIndex(of: \"D\")//print(idx1)// 값이 아예 존재하지 않을 때는 nil을 반환한다.//let idx2 = alphabet.firstIndex(of: \"Q\")//print(idx2) Add a new Element append 12345678910111213var alphabetArray = [\"A\"]alphabetArray.append(\"B\")alphabetArray += [\"C\"]// [\"A\", \"B\", \"C\"]var alphabetArray2 = [\"Q\", \"W\", \"E\"]// [\"A\", \"B\", \"C\", \"Q\", \"W\", \"E\"]alphabetArray + alphabetArray2// 오류가 발생한다! 타입이 다르니까 //alphabetArray.append(5.0)//alphabetArray + 1 insert 1234// 0번째 위치에 S 삽입alphabetArray.insert(\"S\", at: 0)alphabetArray.insert(\"F\", at: 3)alphabetArray Change an Existing Element12345678910alphabetArray = [\"A\", \"B\", \"C\"]alphabetArray[0] = \"Z\"alphabetArray // A 가 Z로 바뀜alphabetArray = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]alphabetArray[2...] = [\"Q\", \"W\", \"E\", \"R\"]alphabetArray // [\"A\", \"B\", \"Q\", \"W\", \"E\", \"R\"]lphabetArray[2...] = [\"Q\", \"W\"]alphabetArray // [\"A\", \"B\", \"Q\", \"W\"] 2번째 위치부터 뒤의 전부를 대체하는 뜻이기 때문에 맨뒤 e, r은 없어짐 Remove an Element1234567891011121314151617alphabetArray = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]let removed = alphabetArray.remove(at: 0)alphabetArray // A 사라짐alphabetArray.removeAll() // 다 없어짐// index 찾아 지우기alphabetArray = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]// C의 위치를 찾아서 반환한 뒤, remove로 지움, 리터럴이 중복되면, 앞선 위치의 값을 지운다.if let indexC = alphabetArray.firstIndex(of: &quot;C&quot;) &#123; alphabetArray.remove(at: indexC)&#125;alphabetArray Sorting123456789101112131415161718192021222324252627282930alphabetArray = [\"A\", \"B\", \"C\", \"D\", \"E\"]alphabetArray.shuffle() // 순서를 섞음alphabetArray.sort() // 정렬alphabetArray// shuffle vs shuffledprint(alphabetArray.shuffle()) // 자기 자신, 즉 배열 자체가 변함, 반환 값이 없음print(alphabetArray.shuffled()) // 자기 자신은 변하지 않고, 바꾼 결과를 반환// sorted vs sortprint(alphabetArray.sort()) // 반환 값 없음print(alphabetArray.sorted()) // 정렬 된 상태로 반환함//func sorted() -&gt; [Element]//mutating func sort()alphabetArray.shuffle()alphabetArray.shuffledvar sortedArray = alphabetArray.sorted()sortedArrayalphabetArray// sort by closure syntax// 클로저 배울 때 다시 배울 거지만 이런 형태로도 사용 가능하다.// 원하는 형태로 정렬할 수 있음sortedArray = alphabetArray.sorted &#123; $0 &gt; $1 &#125;alphabetArray.sorted(by: &gt;= )sortedArray Enumerating an Array1234567891011121314151617181920212223242526272829303132// 배열의 인덱스와 내용을 함께 알고 싶을 때let array = [\"Apple\", \"Orange\", \"Melon\"]for value in array &#123; if let index = array.firstIndex(of: value) &#123; print(\"\\(index) - \\(value)\") &#125;&#125;// 0 - Apple// 1 - Orange// 2 - Melon//위와 같은 기능for tuple in array.enumerated() &#123; print(\"\\(tuple.0) - \\(tuple.1)\")// print(\"\\(tuple.offset) - \\(tuple.element)\")&#125;// 바로 위의 코드를 아래와 같이 사용할 수 있다.for (index, element) in array.enumerated() &#123; print(\"\\(index) - \\(element)\")&#125;// element를 거꾸로 출력한다. for (index, element) in array.reversed().enumerated() &#123; print(\"\\(index) - \\(element)\")&#125;// 0 - Melon// 1 - Orange// 2 - Apple Q.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;] 라는 배열에서 마지막 &quot;p&quot; 문자 하나만 삭제하기 */var puppy = [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;]if let lastIndexOfP = puppy.lastIndex(of: &quot;p&quot;) &#123; puppy.remove(at: lastIndexOfP)&#125;puppy/* 정수 타입의 배열을 2개 선언하고 두 배열의 값 중 겹치는 숫자들로만 이루어진 배열 만들기 ex) [1, 2, 4, 8, 9, 12, 13] , [2, 5, 6, 9, 13] --&gt; [2, 9, 13] */let firstArray = [1, 2, 4, 8, 9, 12, 13]let secondArray = [2, 5, 6, 9, 13]var result: [Int] = []for i in firstArray &#123; for j in secondArray &#123; if i == j &#123; result.append(j) &#125; &#125;&#125;result/* 정수 타입의 배열을 선언하고 해당 배열 요소 중 가장 큰 값을 반환하는 함수 만들기 ex) [50, 23, 29, 1, 45, 39, 59, 19, 15] -&gt; 59 */// 1) Swift 에서 제공하는 기본 함수인 max() 를 이용하는 방법let arr = [50, 23, 29, 1, 45, 39, 59, 19, 15]arr.max()// 2) 두 수 중 높은 값을 반환하는 max 를 이용하거나, 3항 연산자를 이용하는 방법func maximumValue(in list: [Int]) -&gt; Int &#123; var maxValue = Int.min for number in list &#123; maxValue = max(maxValue, number) // 위 함수는 다음의 3항 연산자와 동일 // maxValue = maxValue &lt; number ? number : maxValue &#125; return maxValue&#125;maximumValue(in: [50, 23, 29, 1, 45, 39, 59, 19, 15])maximumValue(in: [10, 20, 30, 80, 50, 40])maximumValue(in: [-6, -5, -4, -3, -2, -1]) Dictionary Element = Unique Key + Value Unordered Collection 12345678910// value는 같아도 상관없지만, key는 중복되면 안됨var dictFromLiteral = [\"key 1\": \"value 1\", \"key 2\": \"value 2\"]// key의 타입과 value의 타입이 같을 필요는 없다var dictFromLiteral = [1: \"value 1\", 2: \"value 2\"]var dictFromLiteral = [\"1\": 1, \"2\": 2]dictFromLiteral = [:]// 오류//var dictFromLiteral = [:] Q. 키가 String이고, Int 타입인, 자료가 없는 상태의 빈 딕셔너리를 만드세요1var emptyDic : [String:Int] = [:] Type Annotation 과 Type Inference 방식을 모두 이용해 여러 가지 데이터를 넣어 딕셔너리를 만들어보세요.1var variousDic = [1 : \"커피\", 2 : \"고기\"] Number of ElementsCount 속성으로 키와 값 쌍의 갯수를 반환할 수 있다 12345678var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]let countOfWords = words.countif !words.isEmpty &#123; print(\"\\(countOfWords) element(s)\")&#125; else &#123; print(\"empty dictionary\")&#125; Retrieve(회수하다) an Element키를 이용하여 값을 조회할 수 있다. 12345678910111213141516var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]words[\"A\"]words[\"Q\"]if let aValue = words[\"A\"] &#123; print(aValue)&#125; else &#123; print(\"Not found\")&#125;if let zValue = words[\"Z\"] &#123; print(zValue)&#125; else &#123; print(\"Not found\")&#125; 키만 출력하는 것도 가능, 조회한 키들을 배열에 담는 것도 가능 12345print(words.keys)print(words.values)let keys = Array(words.keys)let values = Array(words.values) Enumerating(나열하기) an DictionaryFor 문을 이용하여 키와 값을 순회탐색 할 수 있다 123456789101112131415161718192021222324252627282930313233let dict = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]//키 &amp; 값 조회for (key, value) in dict &#123; print(\"\\(key): \\(value)\")&#125;//A: Apple//C: City//B: Banana// 키만 조회for (key, _) in dict &#123; print(\"Key :\", key)&#125;//Key : A//Key : C//Key : B// 값만 조회for (_, value) in dict &#123; print(\"Value :\", value)&#125;//Value : Apple//Value : City//Value : Banana// values 속성을 이용하여 값만 조회for value in dict.values &#123; print(\"Value :\", value)&#125;//Value : Apple//Value : City//Value : Banana Searching키 값 검색 1234567891011121314151617var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]for (key, _) in words &#123; if key == \"A\" &#123; print(\"contains A key.\") &#125;&#125;// contains A key.if words.contains(where: &#123; (key, value) -&gt; Bool in return key == \"A\" &#125;) &#123; print(\"contains A key.\")&#125;// contains A key. 추가 / 변경 12345678910111213141516words = [\"A\": \"A\"]words// 키 A의 값 A로 변경words[\"A\"] // Key -&gt; Unique// 키 A의 값 Apple 로 변경words[\"A\"] = \"Apple\"wordswords[\"B\"] = \"Banana\"words// 값을 변경한다.words[\"B\"] = \"Blue\"words// 키 B의 값 Banana로 변경 Change an Existing Element기존의 딕셔너리에 키가 이미 존재하면 value를 업데이트 한 후 기존 값을 반환한다. 12345678words[\"A\"] = \"App\"if let oldValue = words.updateValue(\"Apple\", forKey: \"A\") &#123; print(\"\\(oldValue) =&gt; \\(words[\"A\"]!)\")&#125; else &#123; print(\"Insert \\(words[\"A\"]!)\")&#125;words// App =&gt; Apple 출력 기존의 딕셔너리에 키가 없으면 value를 추가한 후 nil을 반환한다. 12345678if let oldValue = words.updateValue(\"Steve Jobs\", forKey: \"S\") &#123; print(\"\\(oldValue) =&gt; \\(words[\"S\"]!)\")&#125; else &#123; print(\"Add S Key with \\(words[\"S\"]!)\")&#125;words// S는 추가 되었지만// Add S Key with Steve Jobs 가 출력된다 Remove an Element삭제하기! 12345words = [\"A\": \"Apple\", \"I\": \"IPhone\", \"S\": \"Steve Jobs\", \"T\": \"Timothy Cook\"]words[\"S\"] = nilwords[\"Z\"] = nilwords// S와 Z의 키와 값이 모두 사라짐 지우려는 키가 존재하면 데이터를 지운 후 지운 데이터 반환, 없으면 nil 반환 1234567if let removedValue = words.removeValue(forKey: \"T\") &#123; print(\"\\(removedValue) removed!\")&#125;words// Timothy Cook removed! 반환words.removeAll() // 모두 제거 Nested딕셔너리 내부에 딕셔너리, 그 딕셔너리 내부에 딕셔너리 12345678910111213141516var dict1 = [String: [String]]()//dict1[\"arr\"] = \"A\"dict1[\"arr1\"] = [\"A\", \"B\", \"C\"]dict1[\"arr2\"] = [\"D\", \"E\", \"F\"]print(dict1)//[\"arr1\": [\"A\", \"B\", \"C\"], \"arr2\": [\"D\", \"E\", \"F\"]]var dict2 = [String: [String: String]]()dict2[\"user\"] = [ \"name\": \"나개발\", \"job\": \"iOS 개발자\", \"hobby\": \"코딩\",]print(dict2)//[\"user\": [\"name\": \"나개발\", \"job\": \"iOS 개발자\", \"hobby\": \"코딩\"]] 값의 타입이 다양한 딕셔너리도 가능하다 1234567891011121314151617[ \"name\": \"나개발\", // String : String \"job\": \"iOS 개발자\", \"age\": 20, // String : Int \"hobby\": \"코딩\", \"apps\": [ // String : Array \"이런 앱\", \"저런 앱\", \"잘된 앱\", \"망한 앱\", ], \"teamMember\": [ // String : Dictionary \"designer\": \"김철수\", \"marketer\": \"홍길동\" ]] as [String: Any]// 이 전체가 하나의 딕셔너리! Q. Dictionary 로 저장되어 있는 시험 성적의 평균 점수 구하기12345678let scores = [\"kor\": 92,\"eng\": 88, \"math\": 96, \"science\": 89]var sum = 0for score in scores.values &#123; sum += score&#125;var average = Double(sum) / Double(scores.values.count)print(average) Q. Dictionary로 저장된 scores 데이터를 튜플 타입을 지닌 배열로 변환하여 저장하기123456789101112131415let scores = [\"kor\": 92,\"eng\": 88, \"math\": 96, \"science\": 89]var scoreArr: [(String, Int)] = []// case 1for (key, value) in scores &#123; scoreArr.append((key, value))&#125;// case 2for dict in scores &#123; scoreArr.append(dict)&#125;// case 3scoreArr = Array(scores) Q. 주어진 자료를 보고 Dictionary 자료형에 맞게 데이터를 변수에 저장하기12345678910111213/* 패스트캠퍼스 - 스쿨 * iOS 스쿨 * 백엔드 스쿨 * 프론트엔드 스쿨 - 캠프 * A 강의 * B 강의 - 온라인 * C 강의 * D 강의 */ 1234567let fastcampus = [ \"패스트캠퍼스\": [ \"스쿨\": [\"iOS 스쿨\", \"백엔드 스쿨\", \"프론트엔드 스쿨\"], \"캠프\": [\"A 강의\", \"B 강의\"], \"온라인\": [\"C 강의\", \"D 강의\"], ]] Q. 위 문제에서 정의한 변수의 데이터 중 스쿨 배열에 저장된 첫번째 데이터를 꺼내어 출력하기 (자세한 내용은 Optional 시간에!)1234567891011121314if let 패캠 = fastcampus[\"패스트캠퍼스\"] &#123; if let 스쿨 = 패캠[\"스쿨\"] &#123; print(스쿨[0]) &#125;&#125;if let 패캠 = fastcampus[\"패스트캠퍼스\"], let 스쿨 = 패캠[\"스쿨\"], let iOS = 스쿨.first &#123; print(iOS)&#125;print(fastcampus[\"패스트캠퍼스\"]![\"스쿨\"]![0])// 결과는 모두 동일하다.// iOS 스쿨 Set 정렬 되지 않은 모음 unique value 전반적으로 배열과 유사함 Array와 Dictionary에 비하면 사용빈도가 낮다 선언 123let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]let numbers: Set = [1, 2, 3, 3, 3]let emptySet = Set&lt;String&gt;() Number of Elements데이터의 갯수 반환하기! 배열과 같음 count 속성을 이용한다. 12345678910let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]fruitsSet.countif !fruitsSet.isEmpty &#123; print(\"\\(fruitsSet.count) element(s)\")&#125; else &#123; print(\"empty set\")&#125;//3 element(s) 출력 Searching배열과는 달리 순서가 정렬되어 있는 것이 아니기 때문에 인덱스 주소로 검색할 수 없다. 123456789let x: Set = [1, 2, 3, 4, 5]let y: Set = [1, 2, 3, 4, 5]xy// 출력해 보면 같은 모양의 집합이지만 순서는 엉망진창이다. 완전 다름fruitsSet[0] // 오류!!!!!!x.first // 첫 번째 값만 반환한다 contains 속성을 이용하여 참조 가능하다 12345let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]if fruitsSet.contains(\"Apple\") &#123; print(\"Contains Apple\")&#125; Has prefix 속성을 이용하여 첫 번째 글자를 통해 참조도 가능하다 1234567891011let productSet: Set = [\"iPhone\", \"iPad\", \"Mac Pro\", \"iPad Pro\", \"Macbook Pro\"]for element in productSet &#123; if element.hasPrefix(\"i\") &#123; print(element) &#125;&#125;// iPad Pro// iPhone// iPad Add a New Element역시 배열과 달리 인덱싱을 통해 데이터를 추가하는 append 속성과 at 속성은 사용할 수 없다. 1234[1,2,3].append(1)[1,2,3].insert(2, at: 0)// 둘다 에러!!!!! Insert 속성을 통해 밀어넣는다 1234567891011var stringSet: Set&lt;String&gt; = []stringSet.insert(\"Apple\")stringSetstringSet.insert(\"Orange\")stringSetstringSet.insert(\"Orange\")stringSet// 물론 넣은 순서대로 정렬되지는 않는다. Remove an Element데이터를 지울 때 역시 인덱스를 통하지 않고 직접 remove 속성을 이용하여 지운다. 1234567891011stringSet = [\"Apple\", \"Orange\", \"Melon\"]stringSet.remove(\"Apple\")if let removed = stringSet.remove(\"Orange\") &#123; print(\"\\(removed) has been removed!\")&#125;stringSetstringSet.removeAll() Compare two sets비교 연산자를 사용하여 두 개의 집합을 비교할 수 있다. bool 타입을 반환한다. 123456789var favoriteFruits = Set([\"Apple\", \"Orange\", \"Melon\"])var tropicalFruits = Set([\"Banana\", \"Papaya\", \"Kiwi\", \"Pineapple\"])if favoriteFruits == tropicalFruits &#123; print(\"favoriteFruits == tropicalFruits\")&#125; else &#123; print(\"favoriteFruits != tropicalFruits\")&#125;// favoriteFruits != tropicalFruits 출력 그런데 elementsEqual 속성은 순서까지 같아야 한다. 12345var favoriteFruits1 = Set([\"Orange\", \"Melon\", \"Apple\"])var favoriteFruits2 = Set([\"Apple\", \"Melon\", \"Orange\"])favoriteFruits1 == favoriteFruits2 // true 반환favoriteFruits1.elementsEqual(favoriteFruits2) // false 반환 Fundamental Set Operations intersection - 교집합 symmetricDifference - 교집합의 여집합 union - 합집합 subtracting - 차집합 관련 업계 종사자가 아닌 이상 딱히 쓸 기능은 아니므로 이런게 있다고만 알고 넘어간다. Q&amp;AQ. 배열의 크기를 ‘굳이’ 상수에 할당하여 순회탐색을 하는 이유가 뭔가요?123456var cities = [\"Seoul\", \"Newyork\", \"LA\", \"Santiago\"]let length = cities.countfor i in 0..&lt;length &#123; print(\"\\(i)번째 배열 원소는 \\(cities[i]입니다)\")&#125; 이와 같이 상수 length에 담아서 탐색하지 않고, 123for i in 0..&lt;cities.count &#123;// ~~~&#125; 위와 같은 식으로 직접 배열의 크기를 계산하여 사용하면 코드가 더 간결해지지만, 잠재적으로 문제가 될 소지가 있는 구문이 된다. for~in 구문은 루프를 반복할 때마다 매번 조건식을 평가하기 때문에, 배열의 크기를 매번 다시 계산하게 된다. 배열의 크기가 작다면 크게 문제가 되진 않겠지만, 배열이 크다면 매번 배열의 크기를 계산하는 것은 전체적으로 실행 속도를 떨어뜨리는 원인이 된다. 무슨 차이인건가요?12345678// 특정 값의 위치를 알고 싶을 때if let index = alphabet.firstIndex(of: \"D\") &#123; print(\"index of D: \\(index)\")&#125;let idx1 = alphabet.firstIndex(of: \"D\")//print(idx1) 위 두 가지 코드는 if로 감싼 것 외에는 별 다른 차이가 없다. 설명하기 위해서는 Optional 이라는 개념을 이해해야 하니 내일로 넘어간다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"swift, iOS","slug":"swift-iOS","permalink":"http://yoursite.com/tags/swift-iOS/"}]},{"title":"hexo / github","slug":"12","date":"2019-11-12T08:25:51.000Z","updated":"2019-11-13T10:34:47.283Z","comments":true,"path":"2019/11/12/","link":"","permalink":"http://yoursite.com/2019/11/12/","excerpt":"","text":"hexo 블로그 테마 적용하기한국어 지원 안하는 테마들 지원해주는 경험도 좋음 Ghblog 디렉토리에 클론 경로 주의! vi _config.yml 켜서 theme 수정 나와서 hexo clean &amp;&amp; hexo generate hexo server 로 로컬 서버 돌리고 확인 성공! iTerm 이런저런 설정은 ulgoon.github.io 가서 확인! branch 어떤 시점에 분기점을 치는 행위 -&gt; 브랜치를 친다 분기점을 생성하고 독립적으로 코드를 변경할 수 있도록 도와주는 모델 일단 로컬 저장소로 이동! 1cd iOS-git-first 마블 멀티 유니버스의 개념이랑 유사함 스파이더맨이라는 캐릭터가 있는데 유니버스마다 스파이더맨의 성향이 다르게 설정할 수 있음 브랜치도 이와 유사함 1git branch 위 명령어를 치면 현재 브랜치 목록 출력 1git branch earth123 earth123 브랜치 생성 1git checkout earth123 Earth123 브랜치로 이동! readme.md 수정하고 저장 1git add README.md git status 를 찍어서 상황을 확인해보자 Commit.. 1git commit -m &quot;docs: remove contents from README.md&quot; branch test 작업한 내용이 마음에 안들면 브랜치 날려버리면 된다. Earth123 브랜치의 작업 내용이 맘에 안든다! 날려버리자 1git branch -D earth123 연습해보자 Edit-readme 브랜치 생성 checkout 하고 readme.md 수정 add, commit 확인 master 브랜치로 이동한 상태에서 git diff edit-readme 명령어를치면 차이점을 확인 할 수 있다 merge Edit-readme의 작업이 맘에 든다! Master 로 병합하자! 1git merge edit-readme 과제 Add-profile 브랜치 생성해서 readme.md 수정 하고 병합 마스터에 병합이 끝나면 해당 기능 개발에 대한 작업이 완료 된 것이기 때문에 이미 완료된 브랜치들이 남아있을 필요가 없음 완료된 브랜치들 날려버리자 123git branch -D add-profilegit branch -D edit-readmegit branch // 현재 브랜치 상태 확인 git flow strategy브랜치 목록 master develop feature : 기능 개발 브랜치 feature 기능 개발 브랜치 version naming 마스터 브랜치가 진행 될 수록 버전이 진행 되는 개념 매니저가 release 합시다! 하면 알아서 할것 우리가 건드릴 일은 별로 없음, 팀장급이 아니라면. Ex) v1.0.1 맨 앞에 최초 상용 버전이 되었을때 1이 됨 맨 앞 숫자는 메이저한 변화를 반영한다. 완전 새로운데 앱 이름만 바뀐 경우 등 뭔가 기능(feature)가 추가 되면 가운데 숫자 올라감 v1.2.1, v1.3.1 Develop 을 앞에서 배운 master 브랜치 느낌으로 이해하면 됨 git flow프로젝트를 시작할 때 1git flow init 으로 시작 후 엔터엔터엔터엔터… 1git flow feature start flow-init touch main.swift // 작업 끝 git gi 콜라보레이터 사용 잘 안함 팀장today lunch 레포를 생성하자 리드미파일 수정하는 식으로 해볼거임 클론 하자 Today-lunch 들어가서 git flow init git branch Readme.md 수정 날짜 적을 것 git status git add readme.md git commit -m “docs: add date for today” git push origin -u develop 팀원팀장 레포 들어가서 Fork : 남의 레포에 push를 하려면 접근이 안됨, 그래서 사본을 만드는 거임 fork를 뜨는거다! Fork를 하면 팀장꺼를 복사해서 팀원이 사용한다. 그리고 팀장레포에 가서 issue를 하나 만들면 된다. Issue 에서는 제안, 신고 등 의견을 내는 곳임 실습에서는 점심메뉴를 적는 것으로 업데이트 한다. 이슈넘버가 생성된다. 복사한 레포, git clone 그런데 팀장은 분명 branch를 쳤는데 반영이 안되어있다. Readme도 팀장이 수정한 내용이 없음 그랴서 팀장의 상태를 땡겨와야함! git flow init git pull origin develop 요렇게 해서 팀장의 레포와 상태를 똑같이 만들어 놓고 팀원 본인의 기능 개발을 시작한다. git flow feature start 1112-팀원명 이 실습은 readme.md 파일에 점심메뉴를 적는것으로 한다. git add README.md git commit -m “docs: blah blah” git flow feature finish git push origin develop 다 끝나면 팀장의 develop으로 pull 요청해야함. 접근권한이 없어서 사본을 떴으니깐. (master로 요청하면 안됨! 확인 주의) pull request solved #1 (이슈넘버) 팀장pull request를 확인한다 merge를 눌러주면 팀원의 작업 내용이 팀장의 레포에 반영이 됨","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo, github, blog","slug":"hexo-github-blog","permalink":"http://yoursite.com/tags/hexo-github-blog/"}]},{"title":"조건문 / 반복문","slug":"11","date":"2019-11-11T01:43:31.000Z","updated":"2019-11-13T10:33:52.697Z","comments":true,"path":"2019/11/11/","link":"","permalink":"http://yoursite.com/2019/11/11/","excerpt":"","text":"if statement조건문이 true이면 출력, else는 false일 때 출력, else if는 다른 조건이 true일 때 출력 1234567891011// Logical And Operatorif (temperatureInFahrenheit &gt; 0) &amp;&amp; (temperatureInFahrenheit % 2 == 0) &#123;&#125;// Logical And Operatorif temperatureInFahrenheit &gt; 0, temperatureInFahrenheit % 2 == 0 &#123;&#125;// Logical Or Operatorif temperatureInFahrenheit &gt; 0 || temperatureInFahrenheit % 2 == 0 &#123;&#125; &amp;&amp; 연산자는 자주 사용하니 , 로 대체 가능하다 Q. if ~ else if / if 문을 2개 하는 것과 차이점?123456789var number = 9if number &lt; 10 &#123; print(\"10보다 작다\")&#125;if number &lt; 20 &#123; print(\"20보다 작다\")&#125;// if 문을 두번 사용 하면 위와 같은 경우 두 개 다 실행된다. if ~ else if 만 있을 때 else 없이 동일하게 처리하려면?12345678910var = 25if number &lt; 10 &#123; print(\"10보다 작다\")&#125; else if number &lt; 20 &#123; print(\"20보다 작다\")&#125; else if number &gt;= 20 &#123; print(\"20과 같거나 크다\")&#125;// else if에 해당하지 않는 모든 경우를 else가 들어갈 자리에 조건을 걸어줘야한다. Switch statement12345678910111213/* switch &lt;#value#&gt; &#123; case &lt;#value 1#&gt;: &lt;#respond to value 1#&gt; case &lt;#value 2#&gt;, &lt;#value 3#&gt;: &lt;#respond to value 2 or 3#&gt; default: &lt;#otherwise, do something else#&gt; &#125; - switch 문은 가능한 모든 사례를 반드시 다루어야 함 (Switch must be exhaustive) */ Q. 아래의 if - else if - else 문을 switch 문으로 바꿔보세요.1234567if temperatureInFahrenheit &lt;= 32 &#123; print(\"It's very cold. Consider wearing a scarf.\") &#125; else if temperatureInFahrenheit &gt;= 86 &#123; print(\"It's really warm. Don't forget to wear sunscreen.\") &#125; else &#123; print(\"It's not that cold. Wear a t-shirt.\") &#125; 12345678910var temp = 44switch temp &#123;case ...32 : print(\"It's very cold. Consider wearing a scarf.\")case 33...86 : print(\"It's really warm. Don't forget to wear sunscreen.\")default: print(\"It's not that cold. Wear a t-shirt.\")&#125; Compound case if문은 콤마(,)가 And(&amp;&amp;)연산인 것과 반대로 switch문은 콤마(,)가 Or(||) 연산 123456789let somePoint = (9, 0)switch somePoint &#123;case (let distance, 0), (0, let distance): print(\"On an axis, \\(distance) from the origin\")default: print(\"Not on an axis\")&#125;// x나 y 둘중 하나가 0이면 On an axis가 출력됨 where clause12345678910let anotherPoint = (1, -1)switch anotherPoint &#123;case let (x, y) where x == y: print(\"(\\(x), \\(y)) is on the line x == y\")case let (x, y) where x == -y: print(\"(\\(x), \\(y)) is on the line x == -y\")case let (x, y): print(\"(\\(x), \\(y)) is just some arbitrary point\")&#125; Q. 어떤 숫자가 주어졌을 때 짝수인지 홀수인지 출력 (switch의 where 절 이용)12345678var num = 89switch num &#123;case num where num % 2 == 0: print(\"짝수입니다.\")default: print(\"홀수입니다.\")&#125; Fallthrough 다른 언어들은 swith문이 계속 break를 써주어야 한다. 안쓰면 그 다음 구문도 실행됨 그런데 swift는 안넣어도 되는게 기본임 반대로 fallthrough를 넣어주어야 다음 구문도 실행 됨 1234567891011121314let integerToDescribe = 5var description = \"The number \\(integerToDescribe) is\"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += \" a prime number, and also\" fallthroughdefault: description += \" an integer.\"&#125;print(description)// 위 코드에서 fallthrough를 빼면 default 부분은 실행이 안됨 Guard statement 조건에 맞지 않으면 바로 종료 12345func update(age: Int) &#123; if 1...100 ~= age &#123; print(\"Update\") &#125;&#125; 1234func update(age: Int) &#123; guard 1...100 ~= age else &#123; return &#125; print(\"Update\")&#125; Tuple1234567891011121314let numbers = threeNumbersnumbersnumbers.0numbers.1// 위와 같이 매번 인덱스로 접근하고 싶지 않으면 아래와 같이 각각의 변수에 저장하는 것도 가능하다. let (first, second, third) = threeNumbersfirstsecond// wildcard patternlet (_, second1, third1) = threeNumberssecond1third1 Named Tuple1234567891011let iOS = (language: \"Swift\", version: \"4\")//let iOS: (language: String, version: String) = (language: \"Swift\", version: \"4\")//let iOS: (language: String, version: String) = (\"Swift\", \"4\")//let iOS = (language: \"Swift\", version: \"4\")iOS.0iOS.1iOS.languageiOS.version Comparison Operators Tuple 은 7개 미만 요소에 대한 비교 연산자가 포함되어 있음 7개 이상의 요소를 비교하기 위해서는 비교 연산자를 직접 구현해야 함 Q. 다음의 비교 결과는?123456789(1, \"zebra\") &lt; (2, \"apple\") // true(3, \"apple\") &gt; (3, \"bird\") // false(\"3.14\", 99) &gt; (\"1.99\", 1) // true(\"blue\", 1) &gt; (\"bluesky\", -1) // false(4, \"dog\") == (4, \"dog\") // true(\"일\", 1) &gt; (\"이\", 2.0)(1, \"zebra\") &lt; (\"2\", \"apple\") // 에러남 비교하는 값들의 타입이 다르기 때문(\"blue\", false) &lt; (\"purple\", true) // 에러남 불 값은 크기비교를 할 수 없어서 Loops for 문 while for문Q. for 문을 이용하여 3 의 10 제곱에 대한 결과값을 표현하는 코드 구현1234567let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print(answer) Q. for 문을 이용하여 10부터 1까지 내림차순으로 출력하는 코드 구현12 While 문 조건이 거짓이 될 때까지 일련의 명령문 수행 첫 번째 반복이 시작되기 전에 반복 횟수를 알지 못할 때 많이 사용 while / repeat-while Q. 자연수 하나를 입력받아 1부터 해당 숫자 사이의 모든 숫자의 합을 구해 그 합을 반환하는 함수1234567891011121314151617181920212223func sumNumbers(max: Int) -&gt; Int &#123; var num = 1 var sum = 0 repeat &#123; sum += num // num += 1 &#125; while num &lt;= max return sum&#125;func totalNum(max: Int) -&gt; Int &#123; var num = 1 var sum = 0 while num &lt;= max &#123; sum += num num += 1 &#125; return sum&#125;print(totalNum(max: 3))print(sumNumbers(max: 10)) Control Transfer Statement continue - 현재 반복문의 작업을 중단하고 다음 반복 아이템에 대한 작업 수행 break - break가 포함된 해당 제어문의 흐름을 즉각 중단 (반복문, switch 문) fallthrough - switch 문에서 매칭된 case 의 실행이 종료된 후 그 다음의 case 까지 실행 return - 함수를 즉시 종료하고, return type에 해당하는 자료를 반환 Practice123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// - 학점을 입력받아 각각의 등급을 반환해주는 함수 (4.5 = A+, 4.0 = A, 3.5 = B+ ...)func returnGrade (score : Float) -&gt; String &#123; if score &gt;= 4.5 &#123; return \"A+\" &#125; else if score &gt;= 4.0 &#123; return \"A\" &#125; else if score &gt;= 3.5 &#123; return \"B+\" &#125; else if score &gt;= 3.0 &#123; return \"B\" &#125; else if score &gt;= 2.5 &#123; return \"C+\" &#125; else if score &gt;= 2.0 &#123; return \"C\" &#125; else &#123; return \"F\" &#125;&#125;returnGrade(score: 4.3)// - 특정 달을 숫자로 입력 받아서 문자열로 반환하는 함수 (1 = \"Jan\" , 2 = \"Feb\", ...)func transMonth (month: Int) -&gt; String &#123; switch month &#123; case month where month == 1: return \"Jan\" case month where month == 2: return \"Feb\" case month where month == 3: return \"Mar\" case month where month == 4: return \"Apr\" case month where month == 5: return \"May\" case month where month == 6: return \"Jun\" case month where month == 7: return \"Jul\" case month where month == 8: return \"Aug\" case month where month == 9: return \"Sep\" case month where month == 10: return \"Oct\" case month where month == 11: return \"Nov\" case month where month == 12: return \"Dec\" default : return \"not month\" &#125;&#125;transMonth(month: 12)// - 세 수를 입력받아 세 수의 곱이 양수이면 true, 그렇지 않으면 false 를 반환하는 함수// (switch where clause 를 이용해 풀어볼 수 있으면 해보기)func num (a: Int, b: Int, c: Int) -&gt; Bool &#123; let mul = a * b * c switch mul &#123; case mul where mul &gt; 0: return true case mul where mul == 0: return false default : return false &#125;&#125;num(a: 2, b: 92, c: 0)/*: --- ## Loops --- */// 반복문(for , while , repeat - while)을 이용해 아래 문제들을 구현해보세요.// - 자연수 하나를 입력받아 그 수의 Factorial 을 구하는 함수// (Factorial 참고: 어떤 수가 주어졌을 때 그 수를 포함해 그 수보다 작은 모든 수를 곱한 것)// ex) 5! = 5 x 4 x 3 x 2 x 1 func factorial (a: Int) -&gt; Int &#123; var mul = 1 var num = 1 while num &lt;= a &#123; mul *= num num += 1 &#125; return mul &#125;factorial(a:10)// - 자연수 두 개를 입력받아 첫 번째 수를 두 번째 수만큼 제곱하여 반환하는 함수// (2, 5 를 입력한 경우 결과는 2의 5제곱)func squard (a: Int, b: Int) -&gt; Int &#123; var squ = 1 for _ in 0..&lt;b &#123; squ *= a &#125; return squ&#125;squard(a: 2, b: 3)// - 자연수 하나를 입력받아 각 자리수 숫자들의 합을 반환해주는 함수// (1234 인 경우 각 자리 숫자를 합치면 10)func sumSeat (a: Int) -&gt; Int &#123; let str = String(a) var sum: [Character] = [] var total = 0 for char in str &#123; sum.append(char) &#125; for i in 1...sum.count &#123; total += i &#125; return total&#125;print(sumSeat(a: 21347))/*: --- ## Control Transfer --- */// - 자연수 하나를 입력받아 1부터 해당 숫자 사이의 모든 숫자의 합을 구해 반환하는 함수를 만들되,// 그 합이 2000 을 넘는 순간 더하기를 멈추고 바로 반환하는 함수 func sum (a: Int) -&gt; Int &#123; var sum = 0 var num = 1 while num &lt;= a &#123; if sum &lt;= 2000 &#123; sum += num num += 1 &#125; else &#123; break &#125; &#125; return sum &#125;sum(a: 67)// - 1 ~ 50 사이의 숫자 중에서 20 ~ 30 사이의 숫자만 제외하고 그 나머지를 모두 더해 출력하는 함수func remainSum() -&gt; Int &#123; var sum = 0 for i in 1...50 &#123; if i &gt;= 20 &amp;&amp; i &lt;= 30 &#123; continue &#125; else &#123; sum += i &#125; &#125; return sum&#125;print(remainSum())","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"swift, iOS","slug":"swift-iOS","permalink":"http://yoursite.com/tags/swift-iOS/"}]}]}