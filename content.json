{"meta":{"title":"Let's Swift!","subtitle":"SangMin's study blog","description":"","author":"SangMin Jeon","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-11-12T10:29:11.000Z","updated":"2019-11-12T10:30:20.095Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-11-12T10:28:48.000Z","updated":"2019-11-12T10:28:48.191Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-12T10:28:56.000Z","updated":"2019-11-12T10:28:56.814Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"배열 / 집합 / 딕셔너리","slug":"2019-11-13","date":"2019-11-13T01:43:31.000Z","updated":"2019-11-13T10:40:22.642Z","comments":true,"path":"2019/11/2019-11-13/","link":"","permalink":"http://yoursite.com/2019/11/2019-11-13/","excerpt":"","text":"Collection array - 순서가 있는 값들의 모음 set - 순서가 없는, 정렬 되지 않은 특정 값 (unique values) dictionary - 키와 값의 쌍으로 정렬되지 않은 값들의 모음 배열 (Array) Zero-based integer Index 인덱스가 0부터 시작 대부분의 프로그래밍 언어들은 0부터 시작한다. 상수나 변수처럼 배열에 저장된 타입으로 타입추론이 된다. 초기화1234567891011// Type Annotationlet strArray1: Array&lt;String&gt; = [\"apple\", \"orange\", \"melon\"]let strArray2: [String] = [\"apple\", \"orange\", \"melon\"]// Type Inferencelet strArray3 = [\"apple\", \"orange\", \"melon\"]let strArray4 = Array&lt;String&gt;(repeating: \"iOS\", count: 5)// [ios, ios, ios, ios, ios] 와 같은 뜻// Error//let strArray5 = [\"apple\", 3.14, 1] // 같은 타입의 값이 아니기 때문에 에러 Q. String 타입과 Int 타입으로 각각 자료가 없는 상태인 빈 배열을 만들어보세요.12var strEmpty: [String] = []var intEmpty: [Int] = [] Q. Double 타입은 Type Annotation, Bool 타입은 Type Inference 방식으로 각각 임의의 값을 넣어 배열을 만들어보세요.12var dou: [Double] = [1.2, 3.4, 5.6]var boo = [true, false, false, true] Number of Elements123456789let fruits = [\"Apple\", \"Orange\", \"Banana\"]let countOfFruits = fruits.count // 요소의 갯수를 출력// fruits가 비어있지 않으면, 몇 개의 요소가 있는지 출력, 비어있으면 empty array 출력if !fruits.isEmpty &#123; print(\"\\(countOfFruits) element(s)\")&#125; else &#123; print(\"empty array\")&#125; Retrieve an Element1234567891011121314151617// 0 1 2 endIndexfruits = [\"Apple\", \"Orange\", \"Banana\"]fruits[0]fruits[2]//fruits[123] =&gt; 값의 범위를 벗어난 위치를 참조하려 했기 때문에 오류fruits.startIndex // 0fruits.endIndex // 마지막 요소의 바로 다음 위치를 가리킨다. 여기서는 3이 나온다fruits[fruits.startIndex] // Apple 참조fruits[fruits.endIndex - 1] // Banana 참조fruits.startIndex == 0fruits.endIndex - 1 == 2 Searching12345678910111213141516171819202122232425262728let alphabet = [\"A\", \"B\", \"C\", \"D\", \"E\"]// A 가 있는지 검색if alphabet.contains(\"A\") &#123; print(\"contains A\")&#125;// 클로저 사용. 뭔 소린지는 아직 모르겠음if alphabet.contains(where: &#123; str -&gt; Bool in // code... return str == \"A\"&#125;) &#123; print(\"contains A\")&#125;// 특정 값의 위치를 알 고 싶을 때if let index = alphabet.firstIndex(of: \"D\") &#123; print(\"index of D: \\(index)\")&#125;// 이런 경우에는 옵셔널이라는 개념이 사용된다.// 왜 옵셔널이라는 값이 사용될까? if로 감싼것 빼고는 차이가 없는데//let idx1 = alphabet.firstIndex(of: \"D\")//print(idx1)// 값이 아예 존재하지 않을 때는 nil을 반환한다.//let idx2 = alphabet.firstIndex(of: \"Q\")//print(idx2) Add a new Element append 12345678910111213var alphabetArray = [\"A\"]alphabetArray.append(\"B\")alphabetArray += [\"C\"]// [\"A\", \"B\", \"C\"]var alphabetArray2 = [\"Q\", \"W\", \"E\"]// [\"A\", \"B\", \"C\", \"Q\", \"W\", \"E\"]alphabetArray + alphabetArray2// 오류가 발생한다! 타입이 다르니까 //alphabetArray.append(5.0)//alphabetArray + 1 insert 1234// 0번째 위치에 S 삽입alphabetArray.insert(\"S\", at: 0)alphabetArray.insert(\"F\", at: 3)alphabetArray Change an Existing Element12345678910alphabetArray = [\"A\", \"B\", \"C\"]alphabetArray[0] = \"Z\"alphabetArray // A 가 Z로 바뀜alphabetArray = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]alphabetArray[2...] = [\"Q\", \"W\", \"E\", \"R\"]alphabetArray // [\"A\", \"B\", \"Q\", \"W\", \"E\", \"R\"]lphabetArray[2...] = [\"Q\", \"W\"]alphabetArray // [\"A\", \"B\", \"Q\", \"W\"] 2번째 위치부터 뒤의 전부를 대체하는 뜻이기 때문에 맨뒤 e, r은 없어짐 Remove an Element1234567891011121314151617alphabetArray = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]let removed = alphabetArray.remove(at: 0)alphabetArray // A 사라짐alphabetArray.removeAll() // 다 없어짐// index 찾아 지우기alphabetArray = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;]// C의 위치를 찾아서 반환한 뒤, remove로 지움, 리터럴이 중복되면, 앞선 위치의 값을 지운다.if let indexC = alphabetArray.firstIndex(of: &quot;C&quot;) &#123; alphabetArray.remove(at: indexC)&#125;alphabetArray Sorting123456789101112131415161718192021222324252627282930alphabetArray = [\"A\", \"B\", \"C\", \"D\", \"E\"]alphabetArray.shuffle() // 순서를 섞음alphabetArray.sort() // 정렬alphabetArray// shuffle vs shuffledprint(alphabetArray.shuffle()) // 자기 자신, 즉 배열 자체가 변함, 반환 값이 없음print(alphabetArray.shuffled()) // 자기 자신은 변하지 않고, 바꾼 결과를 반환// sorted vs sortprint(alphabetArray.sort()) // 반환 값 없음print(alphabetArray.sorted()) // 정렬 된 상태로 반환함//func sorted() -&gt; [Element]//mutating func sort()alphabetArray.shuffle()alphabetArray.shuffledvar sortedArray = alphabetArray.sorted()sortedArrayalphabetArray// sort by closure syntax// 클로저 배울 때 다시 배울 거지만 이런 형태로도 사용 가능하다.// 원하는 형태로 정렬할 수 있음sortedArray = alphabetArray.sorted &#123; $0 &gt; $1 &#125;alphabetArray.sorted(by: &gt;= )sortedArray Enumerating an Array1234567891011121314151617181920212223242526272829303132// 배열의 인덱스와 내용을 함께 알고 싶을 때let array = [\"Apple\", \"Orange\", \"Melon\"]for value in array &#123; if let index = array.firstIndex(of: value) &#123; print(\"\\(index) - \\(value)\") &#125;&#125;// 0 - Apple// 1 - Orange// 2 - Melon//위와 같은 기능for tuple in array.enumerated() &#123; print(\"\\(tuple.0) - \\(tuple.1)\")// print(\"\\(tuple.offset) - \\(tuple.element)\")&#125;// 바로 위의 코드를 아래와 같이 사용할 수 있다.for (index, element) in array.enumerated() &#123; print(\"\\(index) - \\(element)\")&#125;// element를 거꾸로 출력한다. for (index, element) in array.reversed().enumerated() &#123; print(\"\\(index) - \\(element)\")&#125;// 0 - Melon// 1 - Orange// 2 - Apple Q.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;] 라는 배열에서 마지막 &quot;p&quot; 문자 하나만 삭제하기 */var puppy = [&quot;p&quot;, &quot;u&quot;, &quot;p&quot;, &quot;p&quot;, &quot;y&quot;]if let lastIndexOfP = puppy.lastIndex(of: &quot;p&quot;) &#123; puppy.remove(at: lastIndexOfP)&#125;puppy/* 정수 타입의 배열을 2개 선언하고 두 배열의 값 중 겹치는 숫자들로만 이루어진 배열 만들기 ex) [1, 2, 4, 8, 9, 12, 13] , [2, 5, 6, 9, 13] --&gt; [2, 9, 13] */let firstArray = [1, 2, 4, 8, 9, 12, 13]let secondArray = [2, 5, 6, 9, 13]var result: [Int] = []for i in firstArray &#123; for j in secondArray &#123; if i == j &#123; result.append(j) &#125; &#125;&#125;result/* 정수 타입의 배열을 선언하고 해당 배열 요소 중 가장 큰 값을 반환하는 함수 만들기 ex) [50, 23, 29, 1, 45, 39, 59, 19, 15] -&gt; 59 */// 1) Swift 에서 제공하는 기본 함수인 max() 를 이용하는 방법let arr = [50, 23, 29, 1, 45, 39, 59, 19, 15]arr.max()// 2) 두 수 중 높은 값을 반환하는 max 를 이용하거나, 3항 연산자를 이용하는 방법func maximumValue(in list: [Int]) -&gt; Int &#123; var maxValue = Int.min for number in list &#123; maxValue = max(maxValue, number) // 위 함수는 다음의 3항 연산자와 동일 // maxValue = maxValue &lt; number ? number : maxValue &#125; return maxValue&#125;maximumValue(in: [50, 23, 29, 1, 45, 39, 59, 19, 15])maximumValue(in: [10, 20, 30, 80, 50, 40])maximumValue(in: [-6, -5, -4, -3, -2, -1]) Dictionary Element = Unique Key + Value Unordered Collection 12345678910// value는 같아도 상관없지만, key는 중복되면 안됨var dictFromLiteral = [\"key 1\": \"value 1\", \"key 2\": \"value 2\"]// key의 타입과 value의 타입이 같을 필요는 없다var dictFromLiteral = [1: \"value 1\", 2: \"value 2\"]var dictFromLiteral = [\"1\": 1, \"2\": 2]dictFromLiteral = [:]// 오류//var dictFromLiteral = [:] Q. 키가 String이고, Int 타입인, 자료가 없는 상태의 빈 딕셔너리를 만드세요1var emptyDic : [String:Int] = [:] Type Annotation 과 Type Inference 방식을 모두 이용해 여러 가지 데이터를 넣어 딕셔너리를 만들어보세요.1var variousDic = [1 : \"커피\", 2 : \"고기\"] Number of ElementsCount 속성으로 키와 값 쌍의 갯수를 반환할 수 있다 12345678var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]let countOfWords = words.countif !words.isEmpty &#123; print(\"\\(countOfWords) element(s)\")&#125; else &#123; print(\"empty dictionary\")&#125; Retrieve(회수하다) an Element키를 이용하여 값을 조회할 수 있다. 12345678910111213141516var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]words[\"A\"]words[\"Q\"]if let aValue = words[\"A\"] &#123; print(aValue)&#125; else &#123; print(\"Not found\")&#125;if let zValue = words[\"Z\"] &#123; print(zValue)&#125; else &#123; print(\"Not found\")&#125; 키만 출력하는 것도 가능, 조회한 키들을 배열에 담는 것도 가능 12345print(words.keys)print(words.values)let keys = Array(words.keys)let values = Array(words.values) Enumerating(나열하기) an DictionaryFor 문을 이용하여 키와 값을 순회탐색 할 수 있다 123456789101112131415161718192021222324252627282930313233let dict = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]//키 &amp; 값 조회for (key, value) in dict &#123; print(\"\\(key): \\(value)\")&#125;//A: Apple//C: City//B: Banana// 키만 조회for (key, _) in dict &#123; print(\"Key :\", key)&#125;//Key : A//Key : C//Key : B// 값만 조회for (_, value) in dict &#123; print(\"Value :\", value)&#125;//Value : Apple//Value : City//Value : Banana// values 속성을 이용하여 값만 조회for value in dict.values &#123; print(\"Value :\", value)&#125;//Value : Apple//Value : City//Value : Banana Searching키 값 검색 1234567891011121314151617var words = [\"A\": \"Apple\", \"B\": \"Banana\", \"C\": \"City\"]for (key, _) in words &#123; if key == \"A\" &#123; print(\"contains A key.\") &#125;&#125;// contains A key.if words.contains(where: &#123; (key, value) -&gt; Bool in return key == \"A\" &#125;) &#123; print(\"contains A key.\")&#125;// contains A key. 추가 / 변경 12345678910111213141516words = [\"A\": \"A\"]words// 키 A의 값 A로 변경words[\"A\"] // Key -&gt; Unique// 키 A의 값 Apple 로 변경words[\"A\"] = \"Apple\"wordswords[\"B\"] = \"Banana\"words// 값을 변경한다.words[\"B\"] = \"Blue\"words// 키 B의 값 Banana로 변경 Change an Existing Element기존의 딕셔너리에 키가 이미 존재하면 value를 업데이트 한 후 기존 값을 반환한다. 12345678words[\"A\"] = \"App\"if let oldValue = words.updateValue(\"Apple\", forKey: \"A\") &#123; print(\"\\(oldValue) =&gt; \\(words[\"A\"]!)\")&#125; else &#123; print(\"Insert \\(words[\"A\"]!)\")&#125;words// App =&gt; Apple 출력 기존의 딕셔너리에 키가 없으면 value를 추가한 후 nil을 반환한다. 12345678if let oldValue = words.updateValue(\"Steve Jobs\", forKey: \"S\") &#123; print(\"\\(oldValue) =&gt; \\(words[\"S\"]!)\")&#125; else &#123; print(\"Add S Key with \\(words[\"S\"]!)\")&#125;words// S는 추가 되었지만// Add S Key with Steve Jobs 가 출력된다 Remove an Element삭제하기! 12345words = [\"A\": \"Apple\", \"I\": \"IPhone\", \"S\": \"Steve Jobs\", \"T\": \"Timothy Cook\"]words[\"S\"] = nilwords[\"Z\"] = nilwords// S와 Z의 키와 값이 모두 사라짐 지우려는 키가 존재하면 데이터를 지운 후 지운 데이터 반환, 없으면 nil 반환 1234567if let removedValue = words.removeValue(forKey: \"T\") &#123; print(\"\\(removedValue) removed!\")&#125;words// Timothy Cook removed! 반환words.removeAll() // 모두 제거 Nested딕셔너리 내부에 딕셔너리, 그 딕셔너리 내부에 딕셔너리 12345678910111213141516var dict1 = [String: [String]]()//dict1[\"arr\"] = \"A\"dict1[\"arr1\"] = [\"A\", \"B\", \"C\"]dict1[\"arr2\"] = [\"D\", \"E\", \"F\"]print(dict1)//[\"arr1\": [\"A\", \"B\", \"C\"], \"arr2\": [\"D\", \"E\", \"F\"]]var dict2 = [String: [String: String]]()dict2[\"user\"] = [ \"name\": \"나개발\", \"job\": \"iOS 개발자\", \"hobby\": \"코딩\",]print(dict2)//[\"user\": [\"name\": \"나개발\", \"job\": \"iOS 개발자\", \"hobby\": \"코딩\"]] 값의 타입이 다양한 딕셔너리도 가능하다 1234567891011121314151617[ \"name\": \"나개발\", // String : String \"job\": \"iOS 개발자\", \"age\": 20, // String : Int \"hobby\": \"코딩\", \"apps\": [ // String : Array \"이런 앱\", \"저런 앱\", \"잘된 앱\", \"망한 앱\", ], \"teamMember\": [ // String : Dictionary \"designer\": \"김철수\", \"marketer\": \"홍길동\" ]] as [String: Any]// 이 전체가 하나의 딕셔너리! Q. Dictionary 로 저장되어 있는 시험 성적의 평균 점수 구하기12345678let scores = [\"kor\": 92,\"eng\": 88, \"math\": 96, \"science\": 89]var sum = 0for score in scores.values &#123; sum += score&#125;var average = Double(sum) / Double(scores.values.count)print(average) Q. Dictionary로 저장된 scores 데이터를 튜플 타입을 지닌 배열로 변환하여 저장하기123456789101112131415let scores = [\"kor\": 92,\"eng\": 88, \"math\": 96, \"science\": 89]var scoreArr: [(String, Int)] = []// case 1for (key, value) in scores &#123; scoreArr.append((key, value))&#125;// case 2for dict in scores &#123; scoreArr.append(dict)&#125;// case 3scoreArr = Array(scores) Q. 주어진 자료를 보고 Dictionary 자료형에 맞게 데이터를 변수에 저장하기12345678910111213/* 패스트캠퍼스 - 스쿨 * iOS 스쿨 * 백엔드 스쿨 * 프론트엔드 스쿨 - 캠프 * A 강의 * B 강의 - 온라인 * C 강의 * D 강의 */ 1234567let fastcampus = [ \"패스트캠퍼스\": [ \"스쿨\": [\"iOS 스쿨\", \"백엔드 스쿨\", \"프론트엔드 스쿨\"], \"캠프\": [\"A 강의\", \"B 강의\"], \"온라인\": [\"C 강의\", \"D 강의\"], ]] Q. 위 문제에서 정의한 변수의 데이터 중 스쿨 배열에 저장된 첫번째 데이터를 꺼내어 출력하기 (자세한 내용은 Optional 시간에!)1234567891011121314if let 패캠 = fastcampus[\"패스트캠퍼스\"] &#123; if let 스쿨 = 패캠[\"스쿨\"] &#123; print(스쿨[0]) &#125;&#125;if let 패캠 = fastcampus[\"패스트캠퍼스\"], let 스쿨 = 패캠[\"스쿨\"], let iOS = 스쿨.first &#123; print(iOS)&#125;print(fastcampus[\"패스트캠퍼스\"]![\"스쿨\"]![0])// 결과는 모두 동일하다.// iOS 스쿨 Set 정렬 되지 않은 모음 unique value 전반적으로 배열과 유사함 Array와 Dictionary에 비하면 사용빈도가 낮다 선언 123let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]let numbers: Set = [1, 2, 3, 3, 3]let emptySet = Set&lt;String&gt;() Number of Elements데이터의 갯수 반환하기! 배열과 같음 count 속성을 이용한다. 12345678910let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]fruitsSet.countif !fruitsSet.isEmpty &#123; print(\"\\(fruitsSet.count) element(s)\")&#125; else &#123; print(\"empty set\")&#125;//3 element(s) 출력 Searching배열과는 달리 순서가 정렬되어 있는 것이 아니기 때문에 인덱스 주소로 검색할 수 없다. 123456789let x: Set = [1, 2, 3, 4, 5]let y: Set = [1, 2, 3, 4, 5]xy// 출력해 보면 같은 모양의 집합이지만 순서는 엉망진창이다. 완전 다름fruitsSet[0] // 오류!!!!!!x.first // 첫 번째 값만 반환한다 contains 속성을 이용하여 참조 가능하다 12345let fruitsSet: Set&lt;String&gt; = [\"Apple\", \"Orange\", \"Melon\"]if fruitsSet.contains(\"Apple\") &#123; print(\"Contains Apple\")&#125; Has prefix 속성을 이용하여 첫 번째 글자를 통해 참조도 가능하다 1234567891011let productSet: Set = [\"iPhone\", \"iPad\", \"Mac Pro\", \"iPad Pro\", \"Macbook Pro\"]for element in productSet &#123; if element.hasPrefix(\"i\") &#123; print(element) &#125;&#125;// iPad Pro// iPhone// iPad Add a New Element역시 배열과 달리 인덱싱을 통해 데이터를 추가하는 append 속성과 at 속성은 사용할 수 없다. 1234[1,2,3].append(1)[1,2,3].insert(2, at: 0)// 둘다 에러!!!!! Insert 속성을 통해 밀어넣는다 1234567891011var stringSet: Set&lt;String&gt; = []stringSet.insert(\"Apple\")stringSetstringSet.insert(\"Orange\")stringSetstringSet.insert(\"Orange\")stringSet// 물론 넣은 순서대로 정렬되지는 않는다. Remove an Element데이터를 지울 때 역시 인덱스를 통하지 않고 직접 remove 속성을 이용하여 지운다. 1234567891011stringSet = [\"Apple\", \"Orange\", \"Melon\"]stringSet.remove(\"Apple\")if let removed = stringSet.remove(\"Orange\") &#123; print(\"\\(removed) has been removed!\")&#125;stringSetstringSet.removeAll() Compare two sets비교 연산자를 사용하여 두 개의 집합을 비교할 수 있다. bool 타입을 반환한다. 123456789var favoriteFruits = Set([\"Apple\", \"Orange\", \"Melon\"])var tropicalFruits = Set([\"Banana\", \"Papaya\", \"Kiwi\", \"Pineapple\"])if favoriteFruits == tropicalFruits &#123; print(\"favoriteFruits == tropicalFruits\")&#125; else &#123; print(\"favoriteFruits != tropicalFruits\")&#125;// favoriteFruits != tropicalFruits 출력 그런데 elementsEqual 속성은 순서까지 같아야 한다. 12345var favoriteFruits1 = Set([\"Orange\", \"Melon\", \"Apple\"])var favoriteFruits2 = Set([\"Apple\", \"Melon\", \"Orange\"])favoriteFruits1 == favoriteFruits2 // true 반환favoriteFruits1.elementsEqual(favoriteFruits2) // false 반환 Fundamental Set Operations intersection - 교집합 symmetricDifference - 교집합의 여집합 union - 합집합 subtracting - 차집합 관련 업계 종사자가 아닌 이상 딱히 쓸 기능은 아니므로 이런게 있다고만 알고 넘어간다. Q&amp;AQ. 배열의 크기를 ‘굳이’ 상수에 할당하여 순회탐색을 하는 이유가 뭔가요?123456var cities = [\"Seoul\", \"Newyork\", \"LA\", \"Santiago\"]let length = cities.countfor i in 0..&lt;length &#123; print(\"\\(i)번째 배열 원소는 \\(cities[i]입니다)\")&#125; 이와 같이 상수 length에 담아서 탐색하지 않고, 123for i in 0..&lt;cities.count &#123;// ~~~&#125; 위와 같은 식으로 직접 배열의 크기를 계산하여 사용하면 코드가 더 간결해지지만, 잠재적으로 문제가 될 소지가 있는 구문이 된다. for~in 구문은 루프를 반복할 때마다 매번 조건식을 평가하기 때문에, 배열의 크기를 매번 다시 계산하게 된다. 배열의 크기가 작다면 크게 문제가 되진 않겠지만, 배열이 크다면 매번 배열의 크기를 계산하는 것은 전체적으로 실행 속도를 떨어뜨리는 원인이 된다. 무슨 차이인건가요?12345678// 특정 값의 위치를 알고 싶을 때if let index = alphabet.firstIndex(of: \"D\") &#123; print(\"index of D: \\(index)\")&#125;let idx1 = alphabet.firstIndex(of: \"D\")//print(idx1) 위 두 가지 코드는 if로 감싼 것 외에는 별 다른 차이가 없다. 설명하기 위해서는 Optional 이라는 개념을 이해해야 하니 내일로 넘어간다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"swift, iOS","slug":"swift-iOS","permalink":"http://yoursite.com/tags/swift-iOS/"}]},{"title":"hexo / github","slug":"2019-11-12","date":"2019-11-12T08:25:51.000Z","updated":"2019-11-13T10:34:47.283Z","comments":true,"path":"2019/11/2019-11-12/","link":"","permalink":"http://yoursite.com/2019/11/2019-11-12/","excerpt":"","text":"hexo 블로그 테마 적용하기한국어 지원 안하는 테마들 지원해주는 경험도 좋음 Ghblog 디렉토리에 클론 경로 주의! vi _config.yml 켜서 theme 수정 나와서 hexo clean &amp;&amp; hexo generate hexo server 로 로컬 서버 돌리고 확인 성공! iTerm 이런저런 설정은 ulgoon.github.io 가서 확인! branch 어떤 시점에 분기점을 치는 행위 -&gt; 브랜치를 친다 분기점을 생성하고 독립적으로 코드를 변경할 수 있도록 도와주는 모델 일단 로컬 저장소로 이동! 1cd iOS-git-first 마블 멀티 유니버스의 개념이랑 유사함 스파이더맨이라는 캐릭터가 있는데 유니버스마다 스파이더맨의 성향이 다르게 설정할 수 있음 브랜치도 이와 유사함 1git branch 위 명령어를 치면 현재 브랜치 목록 출력 1git branch earth123 earth123 브랜치 생성 1git checkout earth123 Earth123 브랜치로 이동! readme.md 수정하고 저장 1git add README.md git status 를 찍어서 상황을 확인해보자 Commit.. 1git commit -m &quot;docs: remove contents from README.md&quot; branch test 작업한 내용이 마음에 안들면 브랜치 날려버리면 된다. Earth123 브랜치의 작업 내용이 맘에 안든다! 날려버리자 1git branch -D earth123 연습해보자 Edit-readme 브랜치 생성 checkout 하고 readme.md 수정 add, commit 확인 master 브랜치로 이동한 상태에서 git diff edit-readme 명령어를치면 차이점을 확인 할 수 있다 merge Edit-readme의 작업이 맘에 든다! Master 로 병합하자! 1git merge edit-readme 과제 Add-profile 브랜치 생성해서 readme.md 수정 하고 병합 마스터에 병합이 끝나면 해당 기능 개발에 대한 작업이 완료 된 것이기 때문에 이미 완료된 브랜치들이 남아있을 필요가 없음 완료된 브랜치들 날려버리자 123git branch -D add-profilegit branch -D edit-readmegit branch // 현재 브랜치 상태 확인 git flow strategy브랜치 목록 master develop feature : 기능 개발 브랜치 feature 기능 개발 브랜치 version naming 마스터 브랜치가 진행 될 수록 버전이 진행 되는 개념 매니저가 release 합시다! 하면 알아서 할것 우리가 건드릴 일은 별로 없음, 팀장급이 아니라면. Ex) v1.0.1 맨 앞에 최초 상용 버전이 되었을때 1이 됨 맨 앞 숫자는 메이저한 변화를 반영한다. 완전 새로운데 앱 이름만 바뀐 경우 등 뭔가 기능(feature)가 추가 되면 가운데 숫자 올라감 v1.2.1, v1.3.1 Develop 을 앞에서 배운 master 브랜치 느낌으로 이해하면 됨 git flow프로젝트를 시작할 때 1git flow init 으로 시작 후 엔터엔터엔터엔터… 1git flow feature start flow-init touch main.swift // 작업 끝 git gi 콜라보레이터 사용 잘 안함 팀장today lunch 레포를 생성하자 리드미파일 수정하는 식으로 해볼거임 클론 하자 Today-lunch 들어가서 git flow init git branch Readme.md 수정 날짜 적을 것 git status git add readme.md git commit -m “docs: add date for today” git push origin -u develop 팀원팀장 레포 들어가서 Fork : 남의 레포에 push를 하려면 접근이 안됨, 그래서 사본을 만드는 거임 fork를 뜨는거다! Fork를 하면 팀장꺼를 복사해서 팀원이 사용한다. 그리고 팀장레포에 가서 issue를 하나 만들면 된다. Issue 에서는 제안, 신고 등 의견을 내는 곳임 실습에서는 점심메뉴를 적는 것으로 업데이트 한다. 이슈넘버가 생성된다. 복사한 레포, git clone 그런데 팀장은 분명 branch를 쳤는데 반영이 안되어있다. Readme도 팀장이 수정한 내용이 없음 그랴서 팀장의 상태를 땡겨와야함! git flow init git pull origin develop 요렇게 해서 팀장의 레포와 상태를 똑같이 만들어 놓고 팀원 본인의 기능 개발을 시작한다. git flow feature start 1112-팀원명 이 실습은 readme.md 파일에 점심메뉴를 적는것으로 한다. git add README.md git commit -m “docs: blah blah” git flow feature finish git push origin develop 다 끝나면 팀장의 develop으로 pull 요청해야함. 접근권한이 없어서 사본을 떴으니깐. (master로 요청하면 안됨! 확인 주의) pull request solved #1 (이슈넘버) 팀장pull request를 확인한다 merge를 눌러주면 팀원의 작업 내용이 팀장의 레포에 반영이 됨","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"hexo, github, blog","slug":"hexo-github-blog","permalink":"http://yoursite.com/tags/hexo-github-blog/"}]},{"title":"조건문 / 반복문","slug":"2019-11-11","date":"2019-11-11T01:43:31.000Z","updated":"2019-11-13T10:33:52.697Z","comments":true,"path":"2019/11/2019-11-11/","link":"","permalink":"http://yoursite.com/2019/11/2019-11-11/","excerpt":"","text":"if statement조건문이 true이면 출력, else는 false일 때 출력, else if는 다른 조건이 true일 때 출력 1234567891011// Logical And Operatorif (temperatureInFahrenheit &gt; 0) &amp;&amp; (temperatureInFahrenheit % 2 == 0) &#123;&#125;// Logical And Operatorif temperatureInFahrenheit &gt; 0, temperatureInFahrenheit % 2 == 0 &#123;&#125;// Logical Or Operatorif temperatureInFahrenheit &gt; 0 || temperatureInFahrenheit % 2 == 0 &#123;&#125; &amp;&amp; 연산자는 자주 사용하니 , 로 대체 가능하다 Q. if ~ else if / if 문을 2개 하는 것과 차이점?123456789var number = 9if number &lt; 10 &#123; print(\"10보다 작다\")&#125;if number &lt; 20 &#123; print(\"20보다 작다\")&#125;// if 문을 두번 사용 하면 위와 같은 경우 두 개 다 실행된다. if ~ else if 만 있을 때 else 없이 동일하게 처리하려면?12345678910var = 25if number &lt; 10 &#123; print(\"10보다 작다\")&#125; else if number &lt; 20 &#123; print(\"20보다 작다\")&#125; else if number &gt;= 20 &#123; print(\"20과 같거나 크다\")&#125;// else if에 해당하지 않는 모든 경우를 else가 들어갈 자리에 조건을 걸어줘야한다. Switch statement12345678910111213/* switch &lt;#value#&gt; &#123; case &lt;#value 1#&gt;: &lt;#respond to value 1#&gt; case &lt;#value 2#&gt;, &lt;#value 3#&gt;: &lt;#respond to value 2 or 3#&gt; default: &lt;#otherwise, do something else#&gt; &#125; - switch 문은 가능한 모든 사례를 반드시 다루어야 함 (Switch must be exhaustive) */ Q. 아래의 if - else if - else 문을 switch 문으로 바꿔보세요.1234567if temperatureInFahrenheit &lt;= 32 &#123; print(\"It's very cold. Consider wearing a scarf.\") &#125; else if temperatureInFahrenheit &gt;= 86 &#123; print(\"It's really warm. Don't forget to wear sunscreen.\") &#125; else &#123; print(\"It's not that cold. Wear a t-shirt.\") &#125; 12345678910var temp = 44switch temp &#123;case ...32 : print(\"It's very cold. Consider wearing a scarf.\")case 33...86 : print(\"It's really warm. Don't forget to wear sunscreen.\")default: print(\"It's not that cold. Wear a t-shirt.\")&#125; Compound case if문은 콤마(,)가 And(&amp;&amp;)연산인 것과 반대로 switch문은 콤마(,)가 Or(||) 연산 123456789let somePoint = (9, 0)switch somePoint &#123;case (let distance, 0), (0, let distance): print(\"On an axis, \\(distance) from the origin\")default: print(\"Not on an axis\")&#125;// x나 y 둘중 하나가 0이면 On an axis가 출력됨 where clause12345678910let anotherPoint = (1, -1)switch anotherPoint &#123;case let (x, y) where x == y: print(\"(\\(x), \\(y)) is on the line x == y\")case let (x, y) where x == -y: print(\"(\\(x), \\(y)) is on the line x == -y\")case let (x, y): print(\"(\\(x), \\(y)) is just some arbitrary point\")&#125; Q. 어떤 숫자가 주어졌을 때 짝수인지 홀수인지 출력 (switch의 where 절 이용)12345678var num = 89switch num &#123;case num where num % 2 == 0: print(\"짝수입니다.\")default: print(\"홀수입니다.\")&#125; Fallthrough 다른 언어들은 swith문이 계속 break를 써주어야 한다. 안쓰면 그 다음 구문도 실행됨 그런데 swift는 안넣어도 되는게 기본임 반대로 fallthrough를 넣어주어야 다음 구문도 실행 됨 1234567891011121314let integerToDescribe = 5var description = \"The number \\(integerToDescribe) is\"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += \" a prime number, and also\" fallthroughdefault: description += \" an integer.\"&#125;print(description)// 위 코드에서 fallthrough를 빼면 default 부분은 실행이 안됨 Guard statement 조건에 맞지 않으면 바로 종료 12345func update(age: Int) &#123; if 1...100 ~= age &#123; print(\"Update\") &#125;&#125; 1234func update(age: Int) &#123; guard 1...100 ~= age else &#123; return &#125; print(\"Update\")&#125; Tuple1234567891011121314let numbers = threeNumbersnumbersnumbers.0numbers.1// 위와 같이 매번 인덱스로 접근하고 싶지 않으면 아래와 같이 각각의 변수에 저장하는 것도 가능하다. let (first, second, third) = threeNumbersfirstsecond// wildcard patternlet (_, second1, third1) = threeNumberssecond1third1 Named Tuple1234567891011let iOS = (language: \"Swift\", version: \"4\")//let iOS: (language: String, version: String) = (language: \"Swift\", version: \"4\")//let iOS: (language: String, version: String) = (\"Swift\", \"4\")//let iOS = (language: \"Swift\", version: \"4\")iOS.0iOS.1iOS.languageiOS.version Comparison Operators Tuple 은 7개 미만 요소에 대한 비교 연산자가 포함되어 있음 7개 이상의 요소를 비교하기 위해서는 비교 연산자를 직접 구현해야 함 Q. 다음의 비교 결과는?123456789(1, \"zebra\") &lt; (2, \"apple\") // true(3, \"apple\") &gt; (3, \"bird\") // false(\"3.14\", 99) &gt; (\"1.99\", 1) // true(\"blue\", 1) &gt; (\"bluesky\", -1) // false(4, \"dog\") == (4, \"dog\") // true(\"일\", 1) &gt; (\"이\", 2.0)(1, \"zebra\") &lt; (\"2\", \"apple\") // 에러남 비교하는 값들의 타입이 다르기 때문(\"blue\", false) &lt; (\"purple\", true) // 에러남 불 값은 크기비교를 할 수 없어서 Loops for 문 while for문Q. for 문을 이용하여 3 의 10 제곱에 대한 결과값을 표현하는 코드 구현1234567let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print(answer) Q. for 문을 이용하여 10부터 1까지 내림차순으로 출력하는 코드 구현12 While 문 조건이 거짓이 될 때까지 일련의 명령문 수행 첫 번째 반복이 시작되기 전에 반복 횟수를 알지 못할 때 많이 사용 while / repeat-while Q. 자연수 하나를 입력받아 1부터 해당 숫자 사이의 모든 숫자의 합을 구해 그 합을 반환하는 함수1234567891011121314151617181920212223func sumNumbers(max: Int) -&gt; Int &#123; var num = 1 var sum = 0 repeat &#123; sum += num // num += 1 &#125; while num &lt;= max return sum&#125;func totalNum(max: Int) -&gt; Int &#123; var num = 1 var sum = 0 while num &lt;= max &#123; sum += num num += 1 &#125; return sum&#125;print(totalNum(max: 3))print(sumNumbers(max: 10)) Control Transfer Statement continue - 현재 반복문의 작업을 중단하고 다음 반복 아이템에 대한 작업 수행 break - break가 포함된 해당 제어문의 흐름을 즉각 중단 (반복문, switch 문) fallthrough - switch 문에서 매칭된 case 의 실행이 종료된 후 그 다음의 case 까지 실행 return - 함수를 즉시 종료하고, return type에 해당하는 자료를 반환 Practice123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160// - 학점을 입력받아 각각의 등급을 반환해주는 함수 (4.5 = A+, 4.0 = A, 3.5 = B+ ...)func returnGrade (score : Float) -&gt; String &#123; if score &gt;= 4.5 &#123; return \"A+\" &#125; else if score &gt;= 4.0 &#123; return \"A\" &#125; else if score &gt;= 3.5 &#123; return \"B+\" &#125; else if score &gt;= 3.0 &#123; return \"B\" &#125; else if score &gt;= 2.5 &#123; return \"C+\" &#125; else if score &gt;= 2.0 &#123; return \"C\" &#125; else &#123; return \"F\" &#125;&#125;returnGrade(score: 4.3)// - 특정 달을 숫자로 입력 받아서 문자열로 반환하는 함수 (1 = \"Jan\" , 2 = \"Feb\", ...)func transMonth (month: Int) -&gt; String &#123; switch month &#123; case month where month == 1: return \"Jan\" case month where month == 2: return \"Feb\" case month where month == 3: return \"Mar\" case month where month == 4: return \"Apr\" case month where month == 5: return \"May\" case month where month == 6: return \"Jun\" case month where month == 7: return \"Jul\" case month where month == 8: return \"Aug\" case month where month == 9: return \"Sep\" case month where month == 10: return \"Oct\" case month where month == 11: return \"Nov\" case month where month == 12: return \"Dec\" default : return \"not month\" &#125;&#125;transMonth(month: 12)// - 세 수를 입력받아 세 수의 곱이 양수이면 true, 그렇지 않으면 false 를 반환하는 함수// (switch where clause 를 이용해 풀어볼 수 있으면 해보기)func num (a: Int, b: Int, c: Int) -&gt; Bool &#123; let mul = a * b * c switch mul &#123; case mul where mul &gt; 0: return true case mul where mul == 0: return false default : return false &#125;&#125;num(a: 2, b: 92, c: 0)/*: --- ## Loops --- */// 반복문(for , while , repeat - while)을 이용해 아래 문제들을 구현해보세요.// - 자연수 하나를 입력받아 그 수의 Factorial 을 구하는 함수// (Factorial 참고: 어떤 수가 주어졌을 때 그 수를 포함해 그 수보다 작은 모든 수를 곱한 것)// ex) 5! = 5 x 4 x 3 x 2 x 1 func factorial (a: Int) -&gt; Int &#123; var mul = 1 var num = 1 while num &lt;= a &#123; mul *= num num += 1 &#125; return mul &#125;factorial(a:10)// - 자연수 두 개를 입력받아 첫 번째 수를 두 번째 수만큼 제곱하여 반환하는 함수// (2, 5 를 입력한 경우 결과는 2의 5제곱)func squard (a: Int, b: Int) -&gt; Int &#123; var squ = 1 for _ in 0..&lt;b &#123; squ *= a &#125; return squ&#125;squard(a: 2, b: 3)// - 자연수 하나를 입력받아 각 자리수 숫자들의 합을 반환해주는 함수// (1234 인 경우 각 자리 숫자를 합치면 10)func sumSeat (a: Int) -&gt; Int &#123; let str = String(a) var sum: [Character] = [] var total = 0 for char in str &#123; sum.append(char) &#125; for i in 1...sum.count &#123; total += i &#125; return total&#125;print(sumSeat(a: 21347))/*: --- ## Control Transfer --- */// - 자연수 하나를 입력받아 1부터 해당 숫자 사이의 모든 숫자의 합을 구해 반환하는 함수를 만들되,// 그 합이 2000 을 넘는 순간 더하기를 멈추고 바로 반환하는 함수 func sum (a: Int) -&gt; Int &#123; var sum = 0 var num = 1 while num &lt;= a &#123; if sum &lt;= 2000 &#123; sum += num num += 1 &#125; else &#123; break &#125; &#125; return sum &#125;sum(a: 67)// - 1 ~ 50 사이의 숫자 중에서 20 ~ 30 사이의 숫자만 제외하고 그 나머지를 모두 더해 출력하는 함수func remainSum() -&gt; Int &#123; var sum = 0 for i in 1...50 &#123; if i &gt;= 20 &amp;&amp; i &lt;= 30 &#123; continue &#125; else &#123; sum += i &#125; &#125; return sum&#125;print(remainSum())","categories":[{"name":"TIL","slug":"TIL","permalink":"http://yoursite.com/categories/TIL/"}],"tags":[{"name":"swift, iOS","slug":"swift-iOS","permalink":"http://yoursite.com/tags/swift-iOS/"}]}]}